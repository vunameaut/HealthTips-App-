<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/data/repository/ChatRepositoryImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/data/repository/ChatRepositoryImpl.java" />
              <option name="originalContent" value="package com.vhn.doan.data.repository;&#10;&#10;import android.os.Handler;&#10;import android.os.Looper;&#10;import android.util.Log;&#10;&#10;import com.google.firebase.database.DataSnapshot;&#10;import com.google.firebase.database.DatabaseError;&#10;import com.google.firebase.database.DatabaseReference;&#10;import com.google.firebase.database.FirebaseDatabase;&#10;import com.google.firebase.database.Query;&#10;import com.google.firebase.database.ValueEventListener;&#10;import com.google.gson.Gson;&#10;import com.google.gson.JsonObject;&#10;import com.google.gson.JsonArray;&#10;import com.vhn.doan.data.ChatMessage;&#10;import com.vhn.doan.data.ChatApiResponse;&#10;import com.vhn.doan.data.Conversation;&#10;&#10;import java.io.IOException;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.List;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;import okhttp3.Call;&#10;import okhttp3.Callback;&#10;import okhttp3.MediaType;&#10;import okhttp3.OkHttpClient;&#10;import okhttp3.Request;&#10;import okhttp3.RequestBody;&#10;import okhttp3.Response;&#10;&#10;/**&#10; * Implementation của ChatRepository với hỗ trợ multiple conversations&#10; */&#10;public class ChatRepositoryImpl implements ChatRepository {&#10;&#10;    private static final String TAG = &quot;ChatRepositoryImpl&quot;;&#10;    // Thay đổi sang RapidAPI ChatGPT-42&#10;    private static final String RAPIDAPI_URL = &quot;https://chatgpt-42.p.rapidapi.com/chatgpt&quot;;&#10;    private static final String RAPIDAPI_KEY = &quot;062f6aca45mshe36de3f71654aecp1590e4jsn0d0d26277bde&quot;;&#10;    private static final String RAPIDAPI_HOST = &quot;chatgpt-42.p.rapidapi.com&quot;;&#10;&#10;    // Firebase paths&#10;    private static final String CONVERSATIONS_PATH = &quot;conversations&quot;;&#10;    private static final String CHAT_MESSAGES_PATH = &quot;chat_messages&quot;;&#10;    private static final String USER_TOPICS_PATH = &quot;user_topics&quot;;&#10;&#10;    // Pagination constants&#10;    private static final int DEFAULT_CONVERSATIONS_LIMIT = 8;&#10;    private static final int LOAD_MORE_CONVERSATIONS_LIMIT = 3;&#10;&#10;    private final DatabaseReference database;&#10;    private final OkHttpClient httpClient;&#10;    private final Gson gson;&#10;    private final Handler mainHandler;&#10;&#10;    public ChatRepositoryImpl() {&#10;        this.database = FirebaseDatabase.getInstance().getReference();&#10;        this.httpClient = new OkHttpClient.Builder()&#10;                .connectTimeout(30, TimeUnit.SECONDS)&#10;                .readTimeout(30, TimeUnit.SECONDS)&#10;                .writeTimeout(30, TimeUnit.SECONDS)&#10;                .build();&#10;        this.gson = new Gson();&#10;        this.mainHandler = new Handler(Looper.getMainLooper());&#10;    }&#10;&#10;    // ========== CONVERSATION MANAGEMENT ==========&#10;&#10;    @Override&#10;    public void createConversation(String userId, String firstMessage, RepositoryCallback&lt;Conversation&gt; callback) {&#10;        try {&#10;            long currentTime = System.currentTimeMillis();&#10;            String title = Conversation.generateTitle(firstMessage);&#10;            String topic = extractTopic(firstMessage);&#10;&#10;            Conversation conversation = new Conversation(userId, title, currentTime);&#10;            conversation.setTopic(topic);&#10;&#10;            String conversationId = database.child(CONVERSATIONS_PATH)&#10;                    .child(userId)&#10;                    .push().getKey();&#10;&#10;            if (conversationId != null) {&#10;                conversation.setId(conversationId);&#10;&#10;                database.child(CONVERSATIONS_PATH)&#10;                        .child(userId)&#10;                        .child(conversationId)&#10;                        .setValue(conversation.toMap())&#10;                        .addOnSuccessListener(aVoid -&gt; {&#10;                            Log.d(TAG, &quot;Conversation created successfully: &quot; + conversationId);&#10;                            callback.onSuccess(conversation);&#10;                        })&#10;                        .addOnFailureListener(e -&gt; {&#10;                            Log.e(TAG, &quot;Failed to create conversation&quot;, e);&#10;                            callback.onError(&quot;Không thể tạo cuộc trò chuyện: &quot; + e.getMessage());&#10;                        });&#10;            } else {&#10;                callback.onError(&quot;Không thể tạo ID cho cuộc trò chuyện&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error creating conversation&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi tạo cuộc trò chuyện: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void getConversations(String userId, int limit, Long lastConversationTime, RepositoryCallback&lt;List&lt;Conversation&gt;&gt; callback) {&#10;        try {&#10;            DatabaseReference conversationsRef = database.child(CONVERSATIONS_PATH).child(userId);&#10;&#10;            // Sắp xếp theo lastMessageTime giảm dần (mới nhất trước)&#10;            Query query = conversationsRef.orderByChild(&quot;lastMessageTime&quot;);&#10;&#10;            // Nếu có lastConversationTime, query từ thời điểm đó trở về trước&#10;            if (lastConversationTime != null) {&#10;                query = query.endBefore(lastConversationTime);&#10;            }&#10;&#10;            // Giới hạn số lượng kết quả&#10;            query = query.limitToLast(limit);&#10;&#10;            query.addListenerForSingleValueEvent(new ValueEventListener() {&#10;                @Override&#10;                public void onDataChange(DataSnapshot dataSnapshot) {&#10;                    List&lt;Conversation&gt; conversations = new ArrayList&lt;&gt;();&#10;&#10;                    for (DataSnapshot conversationSnapshot : dataSnapshot.getChildren()) {&#10;                        try {&#10;                            Conversation conversation = parseConversationFromSnapshot(conversationSnapshot);&#10;                            if (conversation != null) {&#10;                                conversations.add(conversation);&#10;                            }&#10;                        } catch (Exception e) {&#10;                            Log.e(TAG, &quot;Error parsing conversation&quot;, e);&#10;                        }&#10;                    }&#10;&#10;                    // Sắp xếp lại theo thời gian giảm dần (mới nhất trước)&#10;                    Collections.sort(conversations, (c1, c2) -&gt;&#10;                        Long.compare(c2.getLastMessageTime(), c1.getLastMessageTime()));&#10;&#10;                    Log.d(TAG, &quot;Loaded &quot; + conversations.size() + &quot; conversations&quot;);&#10;                    callback.onSuccess(conversations);&#10;                }&#10;&#10;                @Override&#10;                public void onCancelled(DatabaseError databaseError) {&#10;                    Log.e(TAG, &quot;Failed to load conversations&quot;, databaseError.toException());&#10;                    callback.onError(&quot;Không thể tải danh sách cuộc trò chuyện: &quot; + databaseError.getMessage());&#10;                }&#10;            });&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error loading conversations&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi tải danh sách cuộc trò chuyện: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void updateConversation(Conversation conversation, RepositoryCallback&lt;Conversation&gt; callback) {&#10;        try {&#10;            if (conversation.getId() == null || conversation.getUserId() == null) {&#10;                callback.onError(&quot;Thông tin cuộc trò chuyện không hợp lệ&quot;);&#10;                return;&#10;            }&#10;&#10;            database.child(CONVERSATIONS_PATH)&#10;                    .child(conversation.getUserId())&#10;                    .child(conversation.getId())&#10;                    .setValue(conversation.toMap())&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Conversation updated successfully: &quot; + conversation.getId());&#10;                        callback.onSuccess(conversation);&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Failed to update conversation&quot;, e);&#10;                        callback.onError(&quot;Không thể cập nhật cuộc trò chuyện: &quot; + e.getMessage());&#10;                    });&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error updating conversation&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi cập nhật cuộc trò chuyện: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void deleteConversation(String conversationId, RepositoryCallback&lt;Boolean&gt; callback) {&#10;        try {&#10;            if (conversationId == null || conversationId.isEmpty()) {&#10;                callback.onError(&quot;ID cuộc trò chuyện không hợp lệ&quot;);&#10;                return;&#10;            }&#10;&#10;            // Đầu tiên, xóa tất cả tin nhắn trong cuộc trò chuyện&#10;            clearChatMessages(conversationId, new RepositoryCallback&lt;Boolean&gt;() {&#10;                @Override&#10;                public void onSuccess(Boolean result) {&#10;                    // Sau khi xóa tin nhắn thành công, tìm và xóa cuộc trò chuyện&#10;                    deleteConversationFromAllUsers(conversationId, callback);&#10;                }&#10;&#10;                @Override&#10;                public void onError(String error) {&#10;                    Log.e(TAG, &quot;Failed to clear messages before deleting conversation: &quot; + error);&#10;                    callback.onError(&quot;Không thể xóa tin nhắn: &quot; + error);&#10;                }&#10;            });&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error deleting conversation&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi xóa cuộc trò chuyện: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Tìm và xóa cuộc trò chuyện từ tất cả người dùng&#10;     */&#10;    private void deleteConversationFromAllUsers(String conversationId, RepositoryCallback&lt;Boolean&gt; callback) {&#10;        // Query tất cả users để tìm cuộc trò chuyện&#10;        DatabaseReference conversationsRef = database.child(CONVERSATIONS_PATH);&#10;&#10;        conversationsRef.addListenerForSingleValueEvent(new ValueEventListener() {&#10;            @Override&#10;            public void onDataChange(DataSnapshot dataSnapshot) {&#10;                boolean conversationFound = false;&#10;&#10;                for (DataSnapshot userSnapshot : dataSnapshot.getChildren()) {&#10;                    String userId = userSnapshot.getKey();&#10;&#10;                    if (userSnapshot.hasChild(conversationId)) {&#10;                        conversationFound = true;&#10;&#10;                        // Xóa cuộc trò chuyện từ user này&#10;                        database.child(CONVERSATIONS_PATH)&#10;                                .child(userId)&#10;                                .child(conversationId)&#10;                                .removeValue()&#10;                                .addOnSuccessListener(aVoid -&gt; {&#10;                                    Log.d(TAG, &quot;Conversation deleted successfully: &quot; + conversationId);&#10;                                    callback.onSuccess(true);&#10;                                })&#10;                                .addOnFailureListener(e -&gt; {&#10;                                    Log.e(TAG, &quot;Failed to delete conversation: &quot; + conversationId, e);&#10;                                    callback.onError(&quot;Không thể xóa cuộc trò chuyện: &quot; + e.getMessage());&#10;                                });&#10;                        break;&#10;                    }&#10;                }&#10;&#10;                if (!conversationFound) {&#10;                    callback.onError(&quot;Không tìm thấy cuộc trò chuyện để xóa&quot;);&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onCancelled(DatabaseError databaseError) {&#10;                Log.e(TAG, &quot;Error finding conversation to delete&quot;, databaseError.toException());&#10;                callback.onError(&quot;Lỗi tìm kiếm cuộc trò chuyện: &quot; + databaseError.getMessage());&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void hasMoreConversations(String userId, Long lastConversationTime, RepositoryCallback&lt;Boolean&gt; callback) {&#10;        try {&#10;            DatabaseReference conversationsRef = database.child(CONVERSATIONS_PATH).child(userId);&#10;&#10;            Query query = conversationsRef.orderByChild(&quot;lastMessageTime&quot;);&#10;            if (lastConversationTime != null) {&#10;                query = query.endBefore(lastConversationTime);&#10;            }&#10;            query = query.limitToLast(1);&#10;&#10;            query.addListenerForSingleValueEvent(new ValueEventListener() {&#10;                @Override&#10;                public void onDataChange(DataSnapshot dataSnapshot) {&#10;                    boolean hasMore = dataSnapshot.exists() &amp;&amp; dataSnapshot.getChildrenCount() &gt; 0;&#10;                    callback.onSuccess(hasMore);&#10;                }&#10;&#10;                @Override&#10;                public void onCancelled(DatabaseError databaseError) {&#10;                    Log.e(TAG, &quot;Failed to check more conversations&quot;, databaseError.toException());&#10;                    callback.onError(&quot;Không thể kiểm tra cuộc trò chuyện: &quot; + databaseError.getMessage());&#10;                }&#10;            });&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error checking more conversations&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi kiểm tra cuộc trò chuyện: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    // ========== MESSAGE MANAGEMENT ==========&#10;&#10;    @Override&#10;    public void sendMessageToAI(String message, RepositoryCallback&lt;String&gt; callback) {&#10;        try {&#10;            // Tạo JSON request body theo format chính xác của OpenRouter&#10;            JsonObject requestJson = new JsonObject();&#10;            requestJson.addProperty(&quot;model&quot;, &quot;openai/gpt-3.5-turbo&quot;);&#10;&#10;            // Thêm các parameters bổ sung theo yêu cầu OpenRouter&#10;            requestJson.addProperty(&quot;max_tokens&quot;, 1000);&#10;            requestJson.addProperty(&quot;temperature&quot;, 0.7);&#10;&#10;            JsonArray messagesArray = new JsonArray();&#10;&#10;            // System message&#10;            JsonObject systemMessage = new JsonObject();&#10;            systemMessage.addProperty(&quot;role&quot;, &quot;system&quot;);&#10;            systemMessage.addProperty(&quot;content&quot;, &quot;Bạn là trợ lý AI chuyên về sức khỏe. Chỉ trả lời các câu hỏi liên quan đến sức khỏe, y tế, dinh dưỡng, thể dục thể thao. Nếu người dùng hỏi ngoài lĩnh vực sức khỏe thì từ chối một cách lịch sự và đề nghị họ hỏi về sức khỏe.&quot;);&#10;            messagesArray.add(systemMessage);&#10;&#10;            // User message&#10;            JsonObject userMessage = new JsonObject();&#10;            userMessage.addProperty(&quot;role&quot;, &quot;user&quot;);&#10;            userMessage.addProperty(&quot;content&quot;, message);&#10;            messagesArray.add(userMessage);&#10;&#10;            requestJson.add(&quot;messages&quot;, messagesArray);&#10;&#10;            String jsonString = gson.toJson(requestJson);&#10;            Log.d(TAG, &quot;Request JSON: &quot; + jsonString);&#10;&#10;            RequestBody body = RequestBody.create(&#10;                    MediaType.parse(&quot;application/json&quot;),&#10;                    jsonString&#10;            );&#10;&#10;            Request request = new Request.Builder()&#10;                    .url(RAPIDAPI_URL)&#10;                    .post(body)&#10;                    .addHeader(&quot;Authorization&quot;, &quot;Bearer &quot; + RAPIDAPI_KEY)&#10;                    .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                    .addHeader(&quot;HTTP-Referer&quot;, &quot;https://healthtips-vn.app&quot;)&#10;                    .addHeader(&quot;X-Title&quot;, &quot;HealthTips Vietnam&quot;)&#10;                    .build();&#10;&#10;            Log.d(TAG, &quot;Sending request to: &quot; + RAPIDAPI_URL);&#10;            Log.d(TAG, &quot;Authorization header: Bearer &quot; + RAPIDAPI_KEY.substring(0, 20) + &quot;...&quot;);&#10;&#10;            httpClient.newCall(request).enqueue(new Callback() {&#10;                @Override&#10;                public void onFailure(Call call, IOException e) {&#10;                    Log.e(TAG, &quot;Network request failed&quot;, e);&#10;                    mainHandler.post(() -&gt; {&#10;                        callback.onError(&quot;Không thể kết nối đến máy chủ AI. Kiểm tra kết nối mạng của bạn.&quot;);&#10;                    });&#10;                }&#10;&#10;                @Override&#10;                public void onResponse(Call call, Response response) throws IOException {&#10;                    String responseBody = &quot;&quot;;&#10;                    try {&#10;                        if (response.body() != null) {&#10;                            responseBody = response.body().string();&#10;                        }&#10;&#10;                        Log.d(TAG, &quot;Response Code: &quot; + response.code());&#10;                        Log.d(TAG, &quot;Response Headers: &quot; + response.headers().toString());&#10;                        Log.d(TAG, &quot;Response Body: &quot; + responseBody);&#10;&#10;                        if (response.isSuccessful()) {&#10;                            ChatApiResponse apiResponse = gson.fromJson(responseBody, ChatApiResponse.class);&#10;&#10;                            if (apiResponse != null &amp;&amp;&#10;                                apiResponse.getChoices() != null &amp;&amp;&#10;                                !apiResponse.getChoices().isEmpty() &amp;&amp;&#10;                                apiResponse.getChoices().get(0).getMessage() != null) {&#10;&#10;                                String aiMessage = apiResponse.getChoices().get(0).getMessage().getContent();&#10;                                if (aiMessage != null &amp;&amp; !aiMessage.trim().isEmpty()) {&#10;                                    mainHandler.post(() -&gt; callback.onSuccess(aiMessage.trim()));&#10;                                } else {&#10;                                    mainHandler.post(() -&gt; callback.onError(&quot;AI trả về phản hồi trống.&quot;));&#10;                                }&#10;                            } else {&#10;                                mainHandler.post(() -&gt; callback.onError(&quot;Định dạng phản hồi từ AI không hợp lệ.&quot;));&#10;                            }&#10;                        } else {&#10;                            // Xử lý các lỗi HTTP cụ thể&#10;                            String errorMessage = parseErrorMessage(response.code(), responseBody);&#10;                            Log.e(TAG, &quot;API Error: &quot; + errorMessage);&#10;&#10;                            mainHandler.post(() -&gt; callback.onError(errorMessage));&#10;                        }&#10;                    } catch (Exception e) {&#10;                        Log.e(TAG, &quot;Error parsing response&quot;, e);&#10;                        Log.e(TAG, &quot;Response body was: &quot; + responseBody);&#10;&#10;                        mainHandler.post(() -&gt; {&#10;                            callback.onError(&quot;Lỗi xử lý phản hồi từ AI. Vui lòng thử lại.&quot;);&#10;                        });&#10;                    }&#10;                }&#10;            });&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error creating request&quot;, e);&#10;            callback.onError(&quot;Lỗi tạo yêu cầu gửi đến AI.&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Phân tích thông báo lỗi từ API response&#10;     */&#10;    private String parseErrorMessage(int responseCode, String responseBody) {&#10;        try {&#10;            // Thử parse JSON error response&#10;            JsonObject errorResponse = gson.fromJson(responseBody, JsonObject.class);&#10;            if (errorResponse.has(&quot;error&quot;)) {&#10;                JsonObject error = errorResponse.getAsJsonObject(&quot;error&quot;);&#10;                if (error.has(&quot;message&quot;)) {&#10;                    String apiErrorMessage = error.get(&quot;message&quot;).getAsString();&#10;                    Log.d(TAG, &quot;API Error Message: &quot; + apiErrorMessage);&#10;&#10;                    // Dịch một số lỗi phổ biến&#10;                    if (apiErrorMessage.contains(&quot;No auth credentials&quot;)) {&#10;                        return &quot;Lỗi xác thực API. Vui lòng liên hệ quản trị viên.&quot;;&#10;                    } else if (apiErrorMessage.contains(&quot;Rate limit&quot;)) {&#10;                        return &quot;Đã vượt quá giới hạn yêu cầu. Vui lòng thử lại sau ít phút.&quot;;&#10;                    } else if (apiErrorMessage.contains(&quot;Invalid model&quot;)) {&#10;                        return &quot;Mô hình AI không hợp lệ. Vui lòng thử lại.&quot;;&#10;                    }&#10;                    return &quot;Lỗi từ AI: &quot; + apiErrorMessage;&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error parsing error response&quot;, e);&#10;        }&#10;&#10;        // Fallback cho các HTTP status codes&#10;        switch (responseCode) {&#10;            case 401:&#10;                return &quot;Lỗi xác thực. API key có thể đã hết hạn hoặc không hợp lệ.&quot;;&#10;            case 403:&#10;                return &quot;Không có quyền truy cập. Vui lòng kiểm tra cấu hình API.&quot;;&#10;            case 429:&#10;                return &quot;Quá nhiều yêu cầu. Vui lòng chờ một chút rồi thử lại.&quot;;&#10;            case 500:&#10;                return &quot;Lỗi máy chủ AI. Vui lòng thử lại sau.&quot;;&#10;            case 502:&#10;            case 503:&#10;            case 504:&#10;                return &quot;Máy chủ AI tạm thời không khả dụng. Vui lòng thử lại sau.&quot;;&#10;            default:&#10;                return &quot;Lỗi không xác định từ AI (Mã: &quot; + responseCode + &quot;). Vui lòng thử lại.&quot;;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public String extractTopic(String content) {&#10;        try {&#10;            // Các từ khóa chủ đề về sức khỏe&#10;            String[] healthTopics = {&#10;                &quot;tim mạch&quot;, &quot;huyết áp&quot;, &quot;cholesterol&quot;, &quot;đường huyết&quot;, &quot;tiểu đường&quot;,&#10;                &quot;dinh dưỡng&quot;, &quot;vitamin&quot;, &quot;protein&quot;, &quot;carb&quot;, &quot;chất béo&quot;,&#10;                &quot;tập luyện&quot;, &quot;thể dục&quot;, &quot;yoga&quot;, &quot;cardio&quot;, &quot;cơ bắp&quot;,&#10;                &quot;giảm cân&quot;, &quot;tăng cân&quot;, &quot;béo phì&quot;, &quot;ăn kiêng&quot;,&#10;                &quot;stress&quot;, &quot;lo âu&quot;, &quot;trầm cảm&quot;, &quot;tâm lý&quot;, &quot;tinh thần&quot;,&#10;                &quot;giấc ngủ&quot;, &quot;mất ngủ&quot;, &quot;ngủ&quot;, &quot;nghỉ ngơi&quot;,&#10;                &quot;da&quot;, &quot;tóc&quot;, &quot;móng&quot;, &quot;mỹ phẩm&quot;, &quot;chăm sóc da&quot;,&#10;                &quot;mang thai&quot;, &quot;sinh sản&quot;, &quot;kinh nguyệt&quot;, &quot;phụ khoa&quot;,&#10;                &quot;trẻ em&quot;, &quot;em bé&quot;, &quot;sức khỏe trẻ&quot;, &quot;phát triển&quot;,&#10;                &quot;người cao tuổi&quot;, &quot;lão hóa&quot;, &quot;xương khớp&quot;, &quot;cột sống&quot;,&#10;                &quot;mắt&quot;, &quot;thị lực&quot;, &quot;tai&quot;, &quot;thính giác&quot;,&#10;                &quot;răng&quot;, &quot;miệng&quot;, &quot;nha khoa&quot;, &quot;vệ sinh răng miệng&quot;,&#10;                &quot;cảm cúm&quot;, &quot;sốt&quot;, &quot;ho&quot;, &quot;viêm họng&quot;, &quot;virus&quot;,&#10;                &quot;thuốc&quot;, &quot;dược phẩm&quot;, &quot;tác dụng phụ&quot;, &quot;liều dùng&quot;&#10;            };&#10;&#10;            content = content.toLowerCase();&#10;&#10;            for (String topic : healthTopics) {&#10;                if (content.contains(topic)) {&#10;                    return topic;&#10;                }&#10;            }&#10;&#10;            // Nếu không tìm thấy chủ đề cụ thể, trả về chủ đề chung&#10;            return &quot;sức khỏe tổng quát&quot;;&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error extracting topic&quot;, e);&#10;            return &quot;sức khỏe tổng quát&quot;;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lưu chủ đề mà người dùng quan tâm vào Firebase&#10;     */&#10;    private void saveUserTopic(String userId, String topic) {&#10;        try {&#10;            database.child(USER_TOPICS_PATH)&#10;                    .child(userId)&#10;                    .child(topic)&#10;                    .setValue(System.currentTimeMillis())&#10;                    .addOnSuccessListener(aVoid -&gt; Log.d(TAG, &quot;User topic saved: &quot; + topic))&#10;                    .addOnFailureListener(e -&gt; Log.e(TAG, &quot;Failed to save user topic&quot;, e));&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error saving user topic&quot;, e);&#10;        }&#10;    }&#10;&#10;    // ========== HELPER METHODS ==========&#10;&#10;    @Override&#10;    public void saveChatMessage(ChatMessage chatMessage, RepositoryCallback&lt;ChatMessage&gt; callback) {&#10;        try {&#10;            if (chatMessage.getConversationId() == null || chatMessage.getUserId() == null || chatMessage.getContent() == null) {&#10;                callback.onError(&quot;Thông tin tin nhắn không hợp lệ&quot;);&#10;                return;&#10;            }&#10;&#10;            String messageId = database.child(CHAT_MESSAGES_PATH)&#10;                    .child(chatMessage.getConversationId())&#10;                    .push().getKey();&#10;&#10;            if (messageId != null) {&#10;                chatMessage.setId(messageId);&#10;&#10;                database.child(CHAT_MESSAGES_PATH)&#10;                        .child(chatMessage.getConversationId())&#10;                        .child(messageId)&#10;                        .setValue(chatMessage.toMap())&#10;                        .addOnSuccessListener(aVoid -&gt; {&#10;                            Log.d(TAG, &quot;Chat message saved successfully: &quot; + messageId);&#10;                            callback.onSuccess(chatMessage);&#10;                        })&#10;                        .addOnFailureListener(e -&gt; {&#10;                            Log.e(TAG, &quot;Failed to save chat message&quot;, e);&#10;                            callback.onError(&quot;Không thể lưu tin nhắn: &quot; + e.getMessage());&#10;                        });&#10;            } else {&#10;                callback.onError(&quot;Không thể tạo ID cho tin nhắn&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error saving chat message&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi lưu tin nhắn: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void getChatMessages(String conversationId, RepositoryCallback&lt;List&lt;ChatMessage&gt;&gt; callback) {&#10;        try {&#10;            DatabaseReference messagesRef = database.child(CHAT_MESSAGES_PATH).child(conversationId);&#10;&#10;            messagesRef.orderByChild(&quot;timestamp&quot;).addListenerForSingleValueEvent(new ValueEventListener() {&#10;                @Override&#10;                public void onDataChange(DataSnapshot dataSnapshot) {&#10;                    List&lt;ChatMessage&gt; messages = new ArrayList&lt;&gt;();&#10;&#10;                    for (DataSnapshot messageSnapshot : dataSnapshot.getChildren()) {&#10;                        try {&#10;                            ChatMessage message = parseChatMessageFromSnapshot(messageSnapshot);&#10;                            if (message != null) {&#10;                                messages.add(message);&#10;                            }&#10;                        } catch (Exception e) {&#10;                            Log.e(TAG, &quot;Error parsing chat message&quot;, e);&#10;                        }&#10;                    }&#10;&#10;                    Log.d(TAG, &quot;Loaded &quot; + messages.size() + &quot; chat messages&quot;);&#10;                    callback.onSuccess(messages);&#10;                }&#10;&#10;                @Override&#10;                public void onCancelled(DatabaseError databaseError) {&#10;                    Log.e(TAG, &quot;Failed to load chat messages&quot;, databaseError.toException());&#10;                    callback.onError(&quot;Không thể tải tin nhắn: &quot; + databaseError.getMessage());&#10;                }&#10;            });&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error loading chat messages&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi tải tin nhắn: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void clearChatMessages(String conversationId, RepositoryCallback&lt;Boolean&gt; callback) {&#10;        try {&#10;            database.child(CHAT_MESSAGES_PATH)&#10;                    .child(conversationId)&#10;                    .removeValue()&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Chat messages cleared successfully for conversation: &quot; + conversationId);&#10;                        callback.onSuccess(true);&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Failed to clear chat messages&quot;, e);&#10;                        callback.onError(&quot;Không thể xóa tin nhắn: &quot; + e.getMessage());&#10;                    });&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error clearing chat messages&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi xóa tin nhắn: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Parse Conversation từ Firebase DataSnapshot&#10;     */&#10;    private Conversation parseConversationFromSnapshot(DataSnapshot snapshot) {&#10;        try {&#10;            Conversation conversation = new Conversation();&#10;            conversation.setId(snapshot.getKey());&#10;            conversation.setUserId(snapshot.child(&quot;userId&quot;).getValue(String.class));&#10;            conversation.setTitle(snapshot.child(&quot;title&quot;).getValue(String.class));&#10;            conversation.setLastMessage(snapshot.child(&quot;lastMessage&quot;).getValue(String.class));&#10;&#10;            Long lastMessageTime = snapshot.child(&quot;lastMessageTime&quot;).getValue(Long.class);&#10;            if (lastMessageTime != null) {&#10;                conversation.setLastMessageTime(lastMessageTime);&#10;            }&#10;&#10;            Boolean isFromUser = snapshot.child(&quot;isFromUser&quot;).getValue(Boolean.class);&#10;            if (isFromUser != null) {&#10;                conversation.setFromUser(isFromUser);&#10;            }&#10;&#10;            Integer messageCount = snapshot.child(&quot;messageCount&quot;).getValue(Integer.class);&#10;            if (messageCount != null) {&#10;                conversation.setMessageCount(messageCount);&#10;            }&#10;&#10;            Long createdTime = snapshot.child(&quot;createdTime&quot;).getValue(Long.class);&#10;            if (createdTime != null) {&#10;                conversation.setCreatedTime(createdTime);&#10;            }&#10;&#10;            conversation.setTopic(snapshot.child(&quot;topic&quot;).getValue(String.class));&#10;&#10;            // Parse các thuộc tính mới cho menu ngữ cảnh&#10;            Boolean isPinned = snapshot.child(&quot;isPinned&quot;).getValue(Boolean.class);&#10;            if (isPinned != null) {&#10;                conversation.setPinned(isPinned);&#10;            }&#10;&#10;            Boolean isMuted = snapshot.child(&quot;isMuted&quot;).getValue(Boolean.class);&#10;            if (isMuted != null) {&#10;                conversation.setMuted(isMuted);&#10;            }&#10;&#10;            Boolean isRead = snapshot.child(&quot;isRead&quot;).getValue(Boolean.class);&#10;            if (isRead != null) {&#10;                conversation.setRead(isRead);&#10;            }&#10;&#10;            return conversation;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error parsing conversation from snapshot&quot;, e);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Parse ChatMessage từ Firebase DataSnapshot&#10;     */&#10;    private ChatMessage parseChatMessageFromSnapshot(DataSnapshot snapshot) {&#10;        try {&#10;            ChatMessage message = new ChatMessage();&#10;            message.setId(snapshot.getKey());&#10;            message.setConversationId(snapshot.child(&quot;conversationId&quot;).getValue(String.class));&#10;            message.setUserId(snapshot.child(&quot;userId&quot;).getValue(String.class));&#10;            message.setContent(snapshot.child(&quot;content&quot;).getValue(String.class));&#10;&#10;            Boolean isFromUser = snapshot.child(&quot;isFromUser&quot;).getValue(Boolean.class);&#10;            if (isFromUser != null) {&#10;                message.setFromUser(isFromUser);&#10;            }&#10;&#10;            Long timestamp = snapshot.child(&quot;timestamp&quot;).getValue(Long.class);&#10;            if (timestamp != null) {&#10;                message.setTimestamp(timestamp);&#10;            }&#10;&#10;            message.setTopic(snapshot.child(&quot;topic&quot;).getValue(String.class));&#10;            return message;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error parsing message from snapshot&quot;, e);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void clearChatHistory(String userId, RepositoryCallback&lt;Boolean&gt; callback) {&#10;        try {&#10;            // Xóa tất cả cuộc trò chuyện của user&#10;            DatabaseReference userConversationsRef = database.child(CONVERSATIONS_PATH).child(userId);&#10;&#10;            userConversationsRef.addListenerForSingleValueEvent(new ValueEventListener() {&#10;                @Override&#10;                public void onDataChange(DataSnapshot dataSnapshot) {&#10;                    try {&#10;                        List&lt;String&gt; conversationIds = new ArrayList&lt;&gt;();&#10;&#10;                        // Lấy danh sách ID các cuộc trò chuyện&#10;                        for (DataSnapshot conversationSnapshot : dataSnapshot.getChildren()) {&#10;                            conversationIds.add(conversationSnapshot.getKey());&#10;                        }&#10;&#10;                        if (conversationIds.isEmpty()) {&#10;                            callback.onSuccess(true);&#10;                            return;&#10;                        }&#10;&#10;                        // Xóa từng cuộc trò chuyện và tin nhắn của nó&#10;                        deleteConversationsRecursively(conversationIds, 0, userId, callback);&#10;&#10;                    } catch (Exception e) {&#10;                        Log.e(TAG, &quot;Error processing chat history deletion&quot;, e);&#10;                        callback.onError(&quot;Lỗi xử lý xóa lịch sử chat: &quot; + e.getMessage());&#10;                    }&#10;                }&#10;&#10;                @Override&#10;                public void onCancelled(DatabaseError databaseError) {&#10;                    Log.e(TAG, &quot;Error clearing chat history&quot;, databaseError.toException());&#10;                    callback.onError(&quot;Lỗi xóa lịch sử chat: &quot; + databaseError.getMessage());&#10;                }&#10;            });&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error initiating chat history clear&quot;, e);&#10;            callback.onError(&quot;Lỗi khởi tạo xóa lịch sử chat: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Xóa các cuộc trò chuyện một cách đệ quy&#10;     */&#10;    private void deleteConversationsRecursively(List&lt;String&gt; conversationIds, int index, String userId, RepositoryCallback&lt;Boolean&gt; callback) {&#10;        if (index &gt;= conversationIds.size()) {&#10;            // Xóa xong tất cả cuộc trò chuyện, xóa thư mục user trong conversations&#10;            database.child(CONVERSATIONS_PATH).child(userId).removeValue()&#10;                    .addOnSuccessListener(aVoid -&gt; callback.onSuccess(true))&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error removing user conversations folder&quot;, e);&#10;                        callback.onError(&quot;Lỗi xóa thư mục cuộc trò chuyện: &quot; + e.getMessage());&#10;                    });&#10;            return;&#10;        }&#10;&#10;        String conversationId = conversationIds.get(index);&#10;&#10;        // Xóa tin nhắn của cuộc trò chuyện này trước&#10;        clearChatMessages(conversationId, new RepositoryCallback&lt;Boolean&gt;() {&#10;            @Override&#10;            public void onSuccess(Boolean result) {&#10;                // Sau khi xóa tin nhắn, xóa cuộc trò chuyện&#10;                database.child(CONVERSATIONS_PATH).child(userId).child(conversationId).removeValue()&#10;                        .addOnSuccessListener(aVoid -&gt; {&#10;                            // Tiếp tục xóa cuộc trò chuyện tiếp theo&#10;                            deleteConversationsRecursively(conversationIds, index + 1, userId, callback);&#10;                        })&#10;                        .addOnFailureListener(e -&gt; {&#10;                            Log.e(TAG, &quot;Error deleting conversation: &quot; + conversationId, e);&#10;                            callback.onError(&quot;Lỗi xóa cuộc trò chuyện: &quot; + e.getMessage());&#10;                        });&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                Log.e(TAG, &quot;Error clearing messages for conversation: &quot; + conversationId + &quot;, error: &quot; + error);&#10;                callback.onError(&quot;Lỗi xóa tin nhắn cuộc trò chuyện: &quot; + error);&#10;            }&#10;        });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.data.repository;&#10;&#10;import android.os.Handler;&#10;import android.os.Looper;&#10;import android.util.Log;&#10;&#10;import com.google.firebase.database.DataSnapshot;&#10;import com.google.firebase.database.DatabaseError;&#10;import com.google.firebase.database.DatabaseReference;&#10;import com.google.firebase.database.FirebaseDatabase;&#10;import com.google.firebase.database.Query;&#10;import com.google.firebase.database.ValueEventListener;&#10;import com.google.gson.Gson;&#10;import com.google.gson.JsonObject;&#10;import com.google.gson.JsonArray;&#10;import com.vhn.doan.data.ChatMessage;&#10;import com.vhn.doan.data.ChatApiResponse;&#10;import com.vhn.doan.data.Conversation;&#10;&#10;import java.io.IOException;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.List;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;import okhttp3.Call;&#10;import okhttp3.Callback;&#10;import okhttp3.MediaType;&#10;import okhttp3.OkHttpClient;&#10;import okhttp3.Request;&#10;import okhttp3.RequestBody;&#10;import okhttp3.Response;&#10;&#10;/**&#10; * Implementation của ChatRepository với hỗ trợ multiple conversations&#10; */&#10;public class ChatRepositoryImpl implements ChatRepository {&#10;&#10;    private static final String TAG = &quot;ChatRepositoryImpl&quot;;&#10;    // Thay đổi sang RapidAPI ChatGPT-42&#10;    private static final String RAPIDAPI_URL = &quot;https://chatgpt-42.p.rapidapi.com/chatgpt&quot;;&#10;    private static final String RAPIDAPI_KEY = &quot;062f6aca45mshe36de3f71654aecp1590e4jsn0d0d26277bde&quot;;&#10;    private static final String RAPIDAPI_HOST = &quot;chatgpt-42.p.rapidapi.com&quot;;&#10;&#10;    // Firebase paths&#10;    private static final String CONVERSATIONS_PATH = &quot;conversations&quot;;&#10;    private static final String CHAT_MESSAGES_PATH = &quot;chat_messages&quot;;&#10;    private static final String USER_TOPICS_PATH = &quot;user_topics&quot;;&#10;&#10;    // Pagination constants&#10;    private static final int DEFAULT_CONVERSATIONS_LIMIT = 8;&#10;    private static final int LOAD_MORE_CONVERSATIONS_LIMIT = 3;&#10;&#10;    private final DatabaseReference database;&#10;    private final OkHttpClient httpClient;&#10;    private final Gson gson;&#10;    private final Handler mainHandler;&#10;&#10;    public ChatRepositoryImpl() {&#10;        this.database = FirebaseDatabase.getInstance().getReference();&#10;        this.httpClient = new OkHttpClient.Builder()&#10;                .connectTimeout(30, TimeUnit.SECONDS)&#10;                .readTimeout(30, TimeUnit.SECONDS)&#10;                .writeTimeout(30, TimeUnit.SECONDS)&#10;                .build();&#10;        this.gson = new Gson();&#10;        this.mainHandler = new Handler(Looper.getMainLooper());&#10;    }&#10;&#10;    // ========== CONVERSATION MANAGEMENT ==========&#10;&#10;    @Override&#10;    public void createConversation(String userId, String firstMessage, RepositoryCallback&lt;Conversation&gt; callback) {&#10;        try {&#10;            long currentTime = System.currentTimeMillis();&#10;            String title = Conversation.generateTitle(firstMessage);&#10;            String topic = extractTopic(firstMessage);&#10;&#10;            Conversation conversation = new Conversation(userId, title, currentTime);&#10;            conversation.setTopic(topic);&#10;&#10;            String conversationId = database.child(CONVERSATIONS_PATH)&#10;                    .child(userId)&#10;                    .push().getKey();&#10;&#10;            if (conversationId != null) {&#10;                conversation.setId(conversationId);&#10;&#10;                database.child(CONVERSATIONS_PATH)&#10;                        .child(userId)&#10;                        .child(conversationId)&#10;                        .setValue(conversation.toMap())&#10;                        .addOnSuccessListener(aVoid -&gt; {&#10;                            Log.d(TAG, &quot;Conversation created successfully: &quot; + conversationId);&#10;                            callback.onSuccess(conversation);&#10;                        })&#10;                        .addOnFailureListener(e -&gt; {&#10;                            Log.e(TAG, &quot;Failed to create conversation&quot;, e);&#10;                            callback.onError(&quot;Không thể tạo cuộc trò chuyện: &quot; + e.getMessage());&#10;                        });&#10;            } else {&#10;                callback.onError(&quot;Không thể tạo ID cho cuộc trò chuyện&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error creating conversation&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi tạo cuộc trò chuyện: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void getConversations(String userId, int limit, Long lastConversationTime, RepositoryCallback&lt;List&lt;Conversation&gt;&gt; callback) {&#10;        try {&#10;            DatabaseReference conversationsRef = database.child(CONVERSATIONS_PATH).child(userId);&#10;&#10;            // Sắp xếp theo lastMessageTime giảm dần (mới nhất trước)&#10;            Query query = conversationsRef.orderByChild(&quot;lastMessageTime&quot;);&#10;&#10;            // Nếu có lastConversationTime, query từ thời điểm đó trở về trước&#10;            if (lastConversationTime != null) {&#10;                query = query.endBefore(lastConversationTime);&#10;            }&#10;&#10;            // Giới hạn số lượng kết quả&#10;            query = query.limitToLast(limit);&#10;&#10;            query.addListenerForSingleValueEvent(new ValueEventListener() {&#10;                @Override&#10;                public void onDataChange(DataSnapshot dataSnapshot) {&#10;                    List&lt;Conversation&gt; conversations = new ArrayList&lt;&gt;();&#10;&#10;                    for (DataSnapshot conversationSnapshot : dataSnapshot.getChildren()) {&#10;                        try {&#10;                            Conversation conversation = parseConversationFromSnapshot(conversationSnapshot);&#10;                            if (conversation != null) {&#10;                                conversations.add(conversation);&#10;                            }&#10;                        } catch (Exception e) {&#10;                            Log.e(TAG, &quot;Error parsing conversation&quot;, e);&#10;                        }&#10;                    }&#10;&#10;                    // Sắp xếp lại theo thời gian giảm dần (mới nhất trước)&#10;                    Collections.sort(conversations, (c1, c2) -&gt;&#10;                        Long.compare(c2.getLastMessageTime(), c1.getLastMessageTime()));&#10;&#10;                    Log.d(TAG, &quot;Loaded &quot; + conversations.size() + &quot; conversations&quot;);&#10;                    callback.onSuccess(conversations);&#10;                }&#10;&#10;                @Override&#10;                public void onCancelled(DatabaseError databaseError) {&#10;                    Log.e(TAG, &quot;Failed to load conversations&quot;, databaseError.toException());&#10;                    callback.onError(&quot;Không thể tải danh sách cuộc trò chuyện: &quot; + databaseError.getMessage());&#10;                }&#10;            });&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error loading conversations&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi tải danh sách cuộc trò chuyện: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void updateConversation(Conversation conversation, RepositoryCallback&lt;Conversation&gt; callback) {&#10;        try {&#10;            if (conversation.getId() == null || conversation.getUserId() == null) {&#10;                callback.onError(&quot;Thông tin cuộc trò chuyện không hợp lệ&quot;);&#10;                return;&#10;            }&#10;&#10;            database.child(CONVERSATIONS_PATH)&#10;                    .child(conversation.getUserId())&#10;                    .child(conversation.getId())&#10;                    .setValue(conversation.toMap())&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Conversation updated successfully: &quot; + conversation.getId());&#10;                        callback.onSuccess(conversation);&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Failed to update conversation&quot;, e);&#10;                        callback.onError(&quot;Không thể cập nhật cuộc trò chuyện: &quot; + e.getMessage());&#10;                    });&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error updating conversation&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi cập nhật cuộc trò chuyện: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void deleteConversation(String conversationId, RepositoryCallback&lt;Boolean&gt; callback) {&#10;        try {&#10;            if (conversationId == null || conversationId.isEmpty()) {&#10;                callback.onError(&quot;ID cuộc trò chuyện không hợp lệ&quot;);&#10;                return;&#10;            }&#10;&#10;            // Đầu tiên, xóa tất cả tin nhắn trong cuộc trò chuyện&#10;            clearChatMessages(conversationId, new RepositoryCallback&lt;Boolean&gt;() {&#10;                @Override&#10;                public void onSuccess(Boolean result) {&#10;                    // Sau khi xóa tin nhắn thành công, tìm và xóa cuộc trò chuyện&#10;                    deleteConversationFromAllUsers(conversationId, callback);&#10;                }&#10;&#10;                @Override&#10;                public void onError(String error) {&#10;                    Log.e(TAG, &quot;Failed to clear messages before deleting conversation: &quot; + error);&#10;                    callback.onError(&quot;Không thể xóa tin nhắn: &quot; + error);&#10;                }&#10;            });&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error deleting conversation&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi xóa cuộc trò chuyện: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Tìm và xóa cuộc trò chuyện từ tất cả người dùng&#10;     */&#10;    private void deleteConversationFromAllUsers(String conversationId, RepositoryCallback&lt;Boolean&gt; callback) {&#10;        // Query tất cả users để tìm cuộc trò chuyện&#10;        DatabaseReference conversationsRef = database.child(CONVERSATIONS_PATH);&#10;&#10;        conversationsRef.addListenerForSingleValueEvent(new ValueEventListener() {&#10;            @Override&#10;            public void onDataChange(DataSnapshot dataSnapshot) {&#10;                boolean conversationFound = false;&#10;&#10;                for (DataSnapshot userSnapshot : dataSnapshot.getChildren()) {&#10;                    String userId = userSnapshot.getKey();&#10;&#10;                    if (userSnapshot.hasChild(conversationId)) {&#10;                        conversationFound = true;&#10;&#10;                        // Xóa cuộc trò chuyện từ user này&#10;                        database.child(CONVERSATIONS_PATH)&#10;                                .child(userId)&#10;                                .child(conversationId)&#10;                                .removeValue()&#10;                                .addOnSuccessListener(aVoid -&gt; {&#10;                                    Log.d(TAG, &quot;Conversation deleted successfully: &quot; + conversationId);&#10;                                    callback.onSuccess(true);&#10;                                })&#10;                                .addOnFailureListener(e -&gt; {&#10;                                    Log.e(TAG, &quot;Failed to delete conversation: &quot; + conversationId, e);&#10;                                    callback.onError(&quot;Không thể xóa cuộc trò chuyện: &quot; + e.getMessage());&#10;                                });&#10;                        break;&#10;                    }&#10;                }&#10;&#10;                if (!conversationFound) {&#10;                    callback.onError(&quot;Không tìm thấy cuộc trò chuyện để xóa&quot;);&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onCancelled(DatabaseError databaseError) {&#10;                Log.e(TAG, &quot;Error finding conversation to delete&quot;, databaseError.toException());&#10;                callback.onError(&quot;Lỗi tìm kiếm cuộc trò chuyện: &quot; + databaseError.getMessage());&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void hasMoreConversations(String userId, Long lastConversationTime, RepositoryCallback&lt;Boolean&gt; callback) {&#10;        try {&#10;            DatabaseReference conversationsRef = database.child(CONVERSATIONS_PATH).child(userId);&#10;&#10;            Query query = conversationsRef.orderByChild(&quot;lastMessageTime&quot;);&#10;            if (lastConversationTime != null) {&#10;                query = query.endBefore(lastConversationTime);&#10;            }&#10;            query = query.limitToLast(1);&#10;&#10;            query.addListenerForSingleValueEvent(new ValueEventListener() {&#10;                @Override&#10;                public void onDataChange(DataSnapshot dataSnapshot) {&#10;                    boolean hasMore = dataSnapshot.exists() &amp;&amp; dataSnapshot.getChildrenCount() &gt; 0;&#10;                    callback.onSuccess(hasMore);&#10;                }&#10;&#10;                @Override&#10;                public void onCancelled(DatabaseError databaseError) {&#10;                    Log.e(TAG, &quot;Failed to check more conversations&quot;, databaseError.toException());&#10;                    callback.onError(&quot;Không thể kiểm tra cuộc trò chuyện: &quot; + databaseError.getMessage());&#10;                }&#10;            });&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error checking more conversations&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi kiểm tra cuộc trò chuyện: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    // ========== MESSAGE MANAGEMENT ==========&#10;&#10;    @Override&#10;    public void sendMessageToAI(String message, RepositoryCallback&lt;String&gt; callback) {&#10;        try {&#10;            // Tạo JSON request body theo format của RapidAPI ChatGPT-42&#10;            JsonObject requestJson = new JsonObject();&#10;            &#10;            JsonArray messagesArray = new JsonArray();&#10;&#10;            // System message để định hướng AI về sức khỏe&#10;            JsonObject systemMessage = new JsonObject();&#10;            systemMessage.addProperty(&quot;role&quot;, &quot;system&quot;);&#10;            systemMessage.addProperty(&quot;content&quot;, &quot;Bạn là trợ lý AI chuyên về sức khỏe. Chỉ trả lời các câu hỏi liên quan đến sức khỏe, y tế, dinh dưỡng, thể dục thể thao. Nếu người dùng hỏi ngoài lĩnh vực sức khỏe thì từ chối một cách lịch sự và đề nghị họ hỏi về sức khỏe.&quot;);&#10;            messagesArray.add(systemMessage);&#10;&#10;            // User message&#10;            JsonObject userMessage = new JsonObject();&#10;            userMessage.addProperty(&quot;role&quot;, &quot;user&quot;);&#10;            userMessage.addProperty(&quot;content&quot;, message);&#10;            messagesArray.add(userMessage);&#10;&#10;            requestJson.add(&quot;messages&quot;, messagesArray);&#10;            requestJson.addProperty(&quot;web_access&quot;, false);&#10;&#10;            String jsonString = gson.toJson(requestJson);&#10;            Log.d(TAG, &quot;RapidAPI Request JSON: &quot; + jsonString);&#10;&#10;            RequestBody body = RequestBody.create(&#10;                    MediaType.parse(&quot;application/json&quot;),&#10;                    jsonString&#10;            );&#10;&#10;            Request request = new Request.Builder()&#10;                    .url(RAPIDAPI_URL)&#10;                    .post(body)&#10;                    .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                    .addHeader(&quot;x-rapidapi-host&quot;, RAPIDAPI_HOST)&#10;                    .addHeader(&quot;x-rapidapi-key&quot;, RAPIDAPI_KEY)&#10;                    .build();&#10;&#10;            Log.d(TAG, &quot;Sending request to RapidAPI: &quot; + RAPIDAPI_URL);&#10;            Log.d(TAG, &quot;RapidAPI key: &quot; + RAPIDAPI_KEY.substring(0, 20) + &quot;...&quot;);&#10;&#10;            httpClient.newCall(request).enqueue(new Callback() {&#10;                @Override&#10;                public void onFailure(Call call, IOException e) {&#10;                    Log.e(TAG, &quot;Network request failed&quot;, e);&#10;                    mainHandler.post(() -&gt; {&#10;                        callback.onError(&quot;Không thể kết nối đến máy chủ AI. Kiểm tra kết nối mạng của bạn.&quot;);&#10;                    });&#10;                }&#10;&#10;                @Override&#10;                public void onResponse(Call call, Response response) throws IOException {&#10;                    String responseBody = &quot;&quot;;&#10;                    try {&#10;                        if (response.body() != null) {&#10;                            responseBody = response.body().string();&#10;                        }&#10;&#10;                        Log.d(TAG, &quot;RapidAPI Response Code: &quot; + response.code());&#10;                        Log.d(TAG, &quot;RapidAPI Response Headers: &quot; + response.headers().toString());&#10;                        Log.d(TAG, &quot;RapidAPI Response Body: &quot; + responseBody);&#10;&#10;                        if (response.isSuccessful()) {&#10;                            // Parse response theo format của RapidAPI ChatGPT-42&#10;                            JsonObject responseJson = gson.fromJson(responseBody, JsonObject.class);&#10;                            &#10;                            if (responseJson != null &amp;&amp; responseJson.has(&quot;result&quot;)) {&#10;                                String aiMessage = responseJson.get(&quot;result&quot;).getAsString();&#10;                                if (aiMessage != null &amp;&amp; !aiMessage.trim().isEmpty()) {&#10;                                    mainHandler.post(() -&gt; callback.onSuccess(aiMessage.trim()));&#10;                                } else {&#10;                                    mainHandler.post(() -&gt; callback.onError(&quot;AI trả về phản hồi trống.&quot;));&#10;                                }&#10;                            } else {&#10;                                // Fallback: thử parse theo format OpenAI cũ nếu có&#10;                                ChatApiResponse apiResponse = gson.fromJson(responseBody, ChatApiResponse.class);&#10;                                if (apiResponse != null &amp;&amp;&#10;                                    apiResponse.getChoices() != null &amp;&amp;&#10;                                    !apiResponse.getChoices().isEmpty() &amp;&amp;&#10;                                    apiResponse.getChoices().get(0).getMessage() != null) {&#10;&#10;                                    String aiMessage = apiResponse.getChoices().get(0).getMessage().getContent();&#10;                                    if (aiMessage != null &amp;&amp; !aiMessage.trim().isEmpty()) {&#10;                                        mainHandler.post(() -&gt; callback.onSuccess(aiMessage.trim()));&#10;                                    } else {&#10;                                        mainHandler.post(() -&gt; callback.onError(&quot;AI trả về phản hồi trống.&quot;));&#10;                                    }&#10;                                } else {&#10;                                    mainHandler.post(() -&gt; callback.onError(&quot;Định dạng phản hồi từ AI không hợp lệ.&quot;));&#10;                                }&#10;                            }&#10;                        } else {&#10;                            // Xử lý các lỗi HTTP cụ thể cho RapidAPI&#10;                            String errorMessage = parseRapidAPIErrorMessage(response.code(), responseBody);&#10;                            Log.e(TAG, &quot;RapidAPI Error: &quot; + errorMessage);&#10;&#10;                            mainHandler.post(() -&gt; callback.onError(errorMessage));&#10;                        }&#10;                    } catch (Exception e) {&#10;                        Log.e(TAG, &quot;Error parsing RapidAPI response&quot;, e);&#10;                        Log.e(TAG, &quot;Response body was: &quot; + responseBody);&#10;&#10;                        mainHandler.post(() -&gt; {&#10;                            callback.onError(&quot;Lỗi xử lý phản hồi từ AI. Vui lòng thử lại.&quot;);&#10;                        });&#10;                    }&#10;                }&#10;            });&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error creating RapidAPI request&quot;, e);&#10;            callback.onError(&quot;Lỗi tạo yêu cầu gửi đến AI.&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Phân tích thông báo lỗi từ RapidAPI response&#10;     */&#10;    private String parseRapidAPIErrorMessage(int responseCode, String responseBody) {&#10;        try {&#10;            // Thử parse JSON error response từ RapidAPI&#10;            JsonObject errorResponse = gson.fromJson(responseBody, JsonObject.class);&#10;            if (errorResponse.has(&quot;error&quot;)) {&#10;                String apiErrorMessage = errorResponse.get(&quot;error&quot;).getAsString();&#10;                Log.d(TAG, &quot;RapidAPI Error Message: &quot; + apiErrorMessage);&#10;                &#10;                // Dịch một số lỗi phổ biến của RapidAPI&#10;                if (apiErrorMessage.contains(&quot;invalid key&quot;)) {&#10;                    return &quot;Lỗi xác thực RapidAPI. API key không hợp lệ.&quot;;&#10;                } else if (apiErrorMessage.contains(&quot;quota exceeded&quot;)) {&#10;                    return &quot;Đã vượt quá hạn mức sử dụng API. Vui lòng thử lại sau.&quot;;&#10;                } else if (apiErrorMessage.contains(&quot;rate limit&quot;)) {&#10;                    return &quot;Đã vượt quá giới hạn yêu cầu. Vui lòng thử lại sau ít phút.&quot;;&#10;                }&#10;                return &quot;Lỗi từ RapidAPI: &quot; + apiErrorMessage;&#10;            } else if (errorResponse.has(&quot;message&quot;)) {&#10;                String message = errorResponse.get(&quot;message&quot;).getAsString();&#10;                return &quot;Lỗi từ AI: &quot; + message;&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error parsing RapidAPI error response&quot;, e);&#10;        }&#10;&#10;        // Fallback cho các HTTP status codes của RapidAPI&#10;        switch (responseCode) {&#10;            case 401:&#10;                return &quot;Lỗi xác thực RapidAPI. API key có thể đã hết hạn hoặc không hợp lệ.&quot;;&#10;            case 403:&#10;                return &quot;Không có quyền truy cập RapidAPI. Vui lòng kiểm tra subscription.&quot;;&#10;            case 429:&#10;                return &quot;Quá nhiều yêu cầu tới RapidAPI. Vui lòng chờ một chút rồi thử lại.&quot;;&#10;            case 500:&#10;                return &quot;Lỗi máy chủ RapidAPI. Vui lòng thử lại sau.&quot;;&#10;            case 502:&#10;            case 503:&#10;            case 504:&#10;                return &quot;RapidAPI tạm thời không khả dụng. Vui lòng thử lại sau.&quot;;&#10;            default:&#10;                return &quot;Lỗi không xác định từ RapidAPI (Mã: &quot; + responseCode + &quot;). Vui lòng thử lại.&quot;;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public String extractTopic(String content) {&#10;        try {&#10;            // Các từ khóa chủ đề về sức khỏe&#10;            String[] healthTopics = {&#10;                &quot;tim mạch&quot;, &quot;huyết áp&quot;, &quot;cholesterol&quot;, &quot;đường huyết&quot;, &quot;tiểu đường&quot;,&#10;                &quot;dinh dưỡng&quot;, &quot;vitamin&quot;, &quot;protein&quot;, &quot;carb&quot;, &quot;chất béo&quot;,&#10;                &quot;tập luyện&quot;, &quot;thể dục&quot;, &quot;yoga&quot;, &quot;cardio&quot;, &quot;cơ bắp&quot;,&#10;                &quot;giảm cân&quot;, &quot;tăng cân&quot;, &quot;béo phì&quot;, &quot;ăn kiêng&quot;,&#10;                &quot;stress&quot;, &quot;lo âu&quot;, &quot;trầm cảm&quot;, &quot;tâm lý&quot;, &quot;tinh thần&quot;,&#10;                &quot;giấc ngủ&quot;, &quot;mất ngủ&quot;, &quot;ngủ&quot;, &quot;nghỉ ngơi&quot;,&#10;                &quot;da&quot;, &quot;tóc&quot;, &quot;móng&quot;, &quot;mỹ phẩm&quot;, &quot;chăm sóc da&quot;,&#10;                &quot;mang thai&quot;, &quot;sinh sản&quot;, &quot;kinh nguyệt&quot;, &quot;phụ khoa&quot;,&#10;                &quot;trẻ em&quot;, &quot;em bé&quot;, &quot;sức khỏe trẻ&quot;, &quot;phát triển&quot;,&#10;                &quot;người cao tuổi&quot;, &quot;lão hóa&quot;, &quot;xương khớp&quot;, &quot;cột sống&quot;,&#10;                &quot;mắt&quot;, &quot;thị lực&quot;, &quot;tai&quot;, &quot;thính giác&quot;,&#10;                &quot;răng&quot;, &quot;miệng&quot;, &quot;nha khoa&quot;, &quot;vệ sinh răng miệng&quot;,&#10;                &quot;cảm cúm&quot;, &quot;sốt&quot;, &quot;ho&quot;, &quot;viêm họng&quot;, &quot;virus&quot;,&#10;                &quot;thuốc&quot;, &quot;dược phẩm&quot;, &quot;tác dụng phụ&quot;, &quot;liều dùng&quot;&#10;            };&#10;&#10;            content = content.toLowerCase();&#10;&#10;            for (String topic : healthTopics) {&#10;                if (content.contains(topic)) {&#10;                    return topic;&#10;                }&#10;            }&#10;&#10;            // Nếu không tìm thấy chủ đề cụ thể, trả về chủ đề chung&#10;            return &quot;sức khỏe tổng quát&quot;;&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error extracting topic&quot;, e);&#10;            return &quot;sức khỏe tổng quát&quot;;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lưu chủ đề mà người dùng quan tâm vào Firebase&#10;     */&#10;    private void saveUserTopic(String userId, String topic) {&#10;        try {&#10;            database.child(USER_TOPICS_PATH)&#10;                    .child(userId)&#10;                    .child(topic)&#10;                    .setValue(System.currentTimeMillis())&#10;                    .addOnSuccessListener(aVoid -&gt; Log.d(TAG, &quot;User topic saved: &quot; + topic))&#10;                    .addOnFailureListener(e -&gt; Log.e(TAG, &quot;Failed to save user topic&quot;, e));&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error saving user topic&quot;, e);&#10;        }&#10;    }&#10;&#10;    // ========== HELPER METHODS ==========&#10;&#10;    @Override&#10;    public void saveChatMessage(ChatMessage chatMessage, RepositoryCallback&lt;ChatMessage&gt; callback) {&#10;        try {&#10;            if (chatMessage.getConversationId() == null || chatMessage.getUserId() == null || chatMessage.getContent() == null) {&#10;                callback.onError(&quot;Thông tin tin nhắn không hợp lệ&quot;);&#10;                return;&#10;            }&#10;&#10;            String messageId = database.child(CHAT_MESSAGES_PATH)&#10;                    .child(chatMessage.getConversationId())&#10;                    .push().getKey();&#10;&#10;            if (messageId != null) {&#10;                chatMessage.setId(messageId);&#10;&#10;                database.child(CHAT_MESSAGES_PATH)&#10;                        .child(chatMessage.getConversationId())&#10;                        .child(messageId)&#10;                        .setValue(chatMessage.toMap())&#10;                        .addOnSuccessListener(aVoid -&gt; {&#10;                            Log.d(TAG, &quot;Chat message saved successfully: &quot; + messageId);&#10;                            callback.onSuccess(chatMessage);&#10;                        })&#10;                        .addOnFailureListener(e -&gt; {&#10;                            Log.e(TAG, &quot;Failed to save chat message&quot;, e);&#10;                            callback.onError(&quot;Không thể lưu tin nhắn: &quot; + e.getMessage());&#10;                        });&#10;            } else {&#10;                callback.onError(&quot;Không thể tạo ID cho tin nhắn&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error saving chat message&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi lưu tin nhắn: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void getChatMessages(String conversationId, RepositoryCallback&lt;List&lt;ChatMessage&gt;&gt; callback) {&#10;        try {&#10;            DatabaseReference messagesRef = database.child(CHAT_MESSAGES_PATH).child(conversationId);&#10;&#10;            messagesRef.orderByChild(&quot;timestamp&quot;).addListenerForSingleValueEvent(new ValueEventListener() {&#10;                @Override&#10;                public void onDataChange(DataSnapshot dataSnapshot) {&#10;                    List&lt;ChatMessage&gt; messages = new ArrayList&lt;&gt;();&#10;&#10;                    for (DataSnapshot messageSnapshot : dataSnapshot.getChildren()) {&#10;                        try {&#10;                            ChatMessage message = parseChatMessageFromSnapshot(messageSnapshot);&#10;                            if (message != null) {&#10;                                messages.add(message);&#10;                            }&#10;                        } catch (Exception e) {&#10;                            Log.e(TAG, &quot;Error parsing chat message&quot;, e);&#10;                        }&#10;                    }&#10;&#10;                    Log.d(TAG, &quot;Loaded &quot; + messages.size() + &quot; chat messages&quot;);&#10;                    callback.onSuccess(messages);&#10;                }&#10;&#10;                @Override&#10;                public void onCancelled(DatabaseError databaseError) {&#10;                    Log.e(TAG, &quot;Failed to load chat messages&quot;, databaseError.toException());&#10;                    callback.onError(&quot;Không thể tải tin nhắn: &quot; + databaseError.getMessage());&#10;                }&#10;            });&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error loading chat messages&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi tải tin nhắn: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void clearChatMessages(String conversationId, RepositoryCallback&lt;Boolean&gt; callback) {&#10;        try {&#10;            database.child(CHAT_MESSAGES_PATH)&#10;                    .child(conversationId)&#10;                    .removeValue()&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Chat messages cleared successfully for conversation: &quot; + conversationId);&#10;                        callback.onSuccess(true);&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Failed to clear chat messages&quot;, e);&#10;                        callback.onError(&quot;Không thể xóa tin nhắn: &quot; + e.getMessage());&#10;                    });&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error clearing chat messages&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi xóa tin nhắn: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Parse Conversation từ Firebase DataSnapshot&#10;     */&#10;    private Conversation parseConversationFromSnapshot(DataSnapshot snapshot) {&#10;        try {&#10;            Conversation conversation = new Conversation();&#10;            conversation.setId(snapshot.getKey());&#10;            conversation.setUserId(snapshot.child(&quot;userId&quot;).getValue(String.class));&#10;            conversation.setTitle(snapshot.child(&quot;title&quot;).getValue(String.class));&#10;            conversation.setLastMessage(snapshot.child(&quot;lastMessage&quot;).getValue(String.class));&#10;&#10;            Long lastMessageTime = snapshot.child(&quot;lastMessageTime&quot;).getValue(Long.class);&#10;            if (lastMessageTime != null) {&#10;                conversation.setLastMessageTime(lastMessageTime);&#10;            }&#10;&#10;            Boolean isFromUser = snapshot.child(&quot;isFromUser&quot;).getValue(Boolean.class);&#10;            if (isFromUser != null) {&#10;                conversation.setFromUser(isFromUser);&#10;            }&#10;&#10;            Integer messageCount = snapshot.child(&quot;messageCount&quot;).getValue(Integer.class);&#10;            if (messageCount != null) {&#10;                conversation.setMessageCount(messageCount);&#10;            }&#10;&#10;            Long createdTime = snapshot.child(&quot;createdTime&quot;).getValue(Long.class);&#10;            if (createdTime != null) {&#10;                conversation.setCreatedTime(createdTime);&#10;            }&#10;&#10;            conversation.setTopic(snapshot.child(&quot;topic&quot;).getValue(String.class));&#10;&#10;            // Parse các thuộc tính mới cho menu ngữ cảnh&#10;            Boolean isPinned = snapshot.child(&quot;isPinned&quot;).getValue(Boolean.class);&#10;            if (isPinned != null) {&#10;                conversation.setPinned(isPinned);&#10;            }&#10;&#10;            Boolean isMuted = snapshot.child(&quot;isMuted&quot;).getValue(Boolean.class);&#10;            if (isMuted != null) {&#10;                conversation.setMuted(isMuted);&#10;            }&#10;&#10;            Boolean isRead = snapshot.child(&quot;isRead&quot;).getValue(Boolean.class);&#10;            if (isRead != null) {&#10;                conversation.setRead(isRead);&#10;            }&#10;&#10;            return conversation;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error parsing conversation from snapshot&quot;, e);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Parse ChatMessage từ Firebase DataSnapshot&#10;     */&#10;    private ChatMessage parseChatMessageFromSnapshot(DataSnapshot snapshot) {&#10;        try {&#10;            ChatMessage message = new ChatMessage();&#10;            message.setId(snapshot.getKey());&#10;            message.setConversationId(snapshot.child(&quot;conversationId&quot;).getValue(String.class));&#10;            message.setUserId(snapshot.child(&quot;userId&quot;).getValue(String.class));&#10;            message.setContent(snapshot.child(&quot;content&quot;).getValue(String.class));&#10;&#10;            Boolean isFromUser = snapshot.child(&quot;isFromUser&quot;).getValue(Boolean.class);&#10;            if (isFromUser != null) {&#10;                message.setFromUser(isFromUser);&#10;            }&#10;&#10;            Long timestamp = snapshot.child(&quot;timestamp&quot;).getValue(Long.class);&#10;            if (timestamp != null) {&#10;                message.setTimestamp(timestamp);&#10;            }&#10;&#10;            message.setTopic(snapshot.child(&quot;topic&quot;).getValue(String.class));&#10;            return message;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error parsing message from snapshot&quot;, e);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void clearChatHistory(String userId, RepositoryCallback&lt;Boolean&gt; callback) {&#10;        try {&#10;            // Xóa tất cả cuộc trò chuyện của user&#10;            DatabaseReference userConversationsRef = database.child(CONVERSATIONS_PATH).child(userId);&#10;&#10;            userConversationsRef.addListenerForSingleValueEvent(new ValueEventListener() {&#10;                @Override&#10;                public void onDataChange(DataSnapshot dataSnapshot) {&#10;                    try {&#10;                        List&lt;String&gt; conversationIds = new ArrayList&lt;&gt;();&#10;&#10;                        // Lấy danh sách ID các cuộc trò chuyện&#10;                        for (DataSnapshot conversationSnapshot : dataSnapshot.getChildren()) {&#10;                            conversationIds.add(conversationSnapshot.getKey());&#10;                        }&#10;&#10;                        if (conversationIds.isEmpty()) {&#10;                            callback.onSuccess(true);&#10;                            return;&#10;                        }&#10;&#10;                        // Xóa từng cuộc trò chuyện và tin nhắn của nó&#10;                        deleteConversationsRecursively(conversationIds, 0, userId, callback);&#10;&#10;                    } catch (Exception e) {&#10;                        Log.e(TAG, &quot;Error processing chat history deletion&quot;, e);&#10;                        callback.onError(&quot;Lỗi xử lý xóa lịch sử chat: &quot; + e.getMessage());&#10;                    }&#10;                }&#10;&#10;                @Override&#10;                public void onCancelled(DatabaseError databaseError) {&#10;                    Log.e(TAG, &quot;Error clearing chat history&quot;, databaseError.toException());&#10;                    callback.onError(&quot;Lỗi xóa lịch sử chat: &quot; + databaseError.getMessage());&#10;                }&#10;            });&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error initiating chat history clear&quot;, e);&#10;            callback.onError(&quot;Lỗi khởi tạo xóa lịch sử chat: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Xóa các cuộc trò chuyện một cách đệ quy&#10;     */&#10;    private void deleteConversationsRecursively(List&lt;String&gt; conversationIds, int index, String userId, RepositoryCallback&lt;Boolean&gt; callback) {&#10;        if (index &gt;= conversationIds.size()) {&#10;            // Xóa xong tất cả cuộc trò chuyện, xóa thư mục user trong conversations&#10;            database.child(CONVERSATIONS_PATH).child(userId).removeValue()&#10;                    .addOnSuccessListener(aVoid -&gt; callback.onSuccess(true))&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error removing user conversations folder&quot;, e);&#10;                        callback.onError(&quot;Lỗi xóa thư mục cuộc trò chuyện: &quot; + e.getMessage());&#10;                    });&#10;            return;&#10;        }&#10;&#10;        String conversationId = conversationIds.get(index);&#10;&#10;        // Xóa tin nhắn của cuộc trò chuyện này trước&#10;        clearChatMessages(conversationId, new RepositoryCallback&lt;Boolean&gt;() {&#10;            @Override&#10;            public void onSuccess(Boolean result) {&#10;                // Sau khi xóa tin nhắn, xóa cuộc trò chuyện&#10;                database.child(CONVERSATIONS_PATH).child(userId).child(conversationId).removeValue()&#10;                        .addOnSuccessListener(aVoid -&gt; {&#10;                            // Tiếp tục xóa cuộc trò chuyện tiếp theo&#10;                            deleteConversationsRecursively(conversationIds, index + 1, userId, callback);&#10;                        })&#10;                        .addOnFailureListener(e -&gt; {&#10;                            Log.e(TAG, &quot;Error deleting conversation: &quot; + conversationId, e);&#10;                            callback.onError(&quot;Lỗi xóa cuộc trò chuyện: &quot; + e.getMessage());&#10;                        });&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                Log.e(TAG, &quot;Error clearing messages for conversation: &quot; + conversationId + &quot;, error: &quot; + error);&#10;                callback.onError(&quot;Lỗi xóa tin nhắn cuộc trò chuyện: &quot; + error);&#10;            }&#10;        });&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>