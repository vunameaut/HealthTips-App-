<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Quyền truy cập Internet --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;&#10;    &lt;!-- Quyền cho thông báo và alarm --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.SCHEDULE_EXACT_ALARM&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.USE_EXACT_ALARM&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;&#10;&#10;    &lt;!-- Quyền tắt tối ưu hóa pin để hoạt động trong Doze mode --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS&quot; /&gt;&#10;&#10;    &lt;!-- Quyền foreground service cho WorkManager --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_logo&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_logo_foreground&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.Doan&quot;&#10;        android:name=&quot;androidx.multidex.MultiDexApplication&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;&#10;        &lt;!-- Activities --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.auth.LoginActivity&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.auth.ForgotPasswordActivity&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.auth.RegisterActivity&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.home.HomeActivity&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.category.detail.CategoryDetailListActivity&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.healthtip.detail.HealthTipDetailActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.HealthTipDetail&quot; /&gt;&#10;&#10;        &lt;!-- Debug Activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.debug.ReminderTestActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;Debug Thông Báo&quot; /&gt;&#10;&#10;        &lt;!-- Broadcast Receivers cho Reminder --&gt;&#10;        &lt;receiver&#10;            android:name=&quot;.receivers.ReminderBroadcastReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;receiver&#10;            android:name=&quot;.receivers.ReminderActionReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;!-- Receiver để khởi động lại reminder sau khi boot --&gt;&#10;        &lt;receiver&#10;            android:name=&quot;.receivers.BootReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter android:priority=&quot;1000&quot;&gt;&#10;                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MY_PACKAGE_REPLACED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.PACKAGE_REPLACED&quot; /&gt;&#10;                &lt;data android:scheme=&quot;package&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;&#10;        &lt;!-- Services --&gt;&#10;        &lt;service&#10;            android:name=&quot;.services.ReminderForegroundService&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:foregroundServiceType=&quot;specialUse&quot; /&gt;&#10;&#10;            android:foregroundServiceType=&quot;specialUse&quot; /&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Quyền truy cập Internet --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;&#10;    &lt;!-- Quyền cho thông báo và alarm --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.SCHEDULE_EXACT_ALARM&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.USE_EXACT_ALARM&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;&#10;&#10;    &lt;!-- Quyền tắt tối ưu hóa pin để hoạt động trong Doze mode --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS&quot; /&gt;&#10;&#10;    &lt;!-- Quyền foreground service cho WorkManager --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#10;    &lt;!-- Quyền foreground service đặc biệt cho Android 14+ (API 34+) --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_SPECIAL_USE&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_logo&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_logo_foreground&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.Doan&quot;&#10;        android:name=&quot;androidx.multidex.MultiDexApplication&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;&#10;        &lt;!-- Activities --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.auth.LoginActivity&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.auth.ForgotPasswordActivity&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.auth.RegisterActivity&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.home.HomeActivity&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.category.detail.CategoryDetailListActivity&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.healthtip.detail.HealthTipDetailActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.HealthTipDetail&quot; /&gt;&#10;&#10;        &lt;!-- Debug Activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.debug.ReminderTestActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;Debug Thông Báo&quot; /&gt;&#10;&#10;        &lt;!-- Broadcast Receivers cho Reminder --&gt;&#10;        &lt;receiver&#10;            android:name=&quot;.receivers.ReminderBroadcastReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;receiver&#10;            android:name=&quot;.receivers.ReminderActionReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;!-- Receiver để khởi động lại reminder sau khi boot --&gt;&#10;        &lt;receiver&#10;            android:name=&quot;.receivers.BootReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter android:priority=&quot;1000&quot;&gt;&#10;                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MY_PACKAGE_REPLACED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.PACKAGE_REPLACED&quot; /&gt;&#10;                &lt;data android:scheme=&quot;package&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;&#10;        &lt;!-- Services --&gt;&#10;        &lt;service&#10;            android:name=&quot;.services.ReminderForegroundService&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:foregroundServiceType=&quot;specialUse&quot;&gt;&#10;            &lt;!-- Thêm property cho specialUse theo yêu cầu Android 14+ --&gt;&#10;            &lt;property &#10;                android:name=&quot;android.app.PROPERTY_SPECIAL_USE_FGS_SUBTYPE&quot;&#10;                android:value=&quot;explanation_needed&quot; /&gt;&#10;        &lt;/service&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/data/Reminder.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/data/Reminder.java" />
              <option name="originalContent" value="package com.vhn.doan.data;&#10;&#10;import com.google.firebase.database.PropertyName;&#10;import com.google.firebase.database.ServerValue;&#10;import com.google.firebase.database.Exclude;&#10;import java.util.Calendar;&#10;import java.util.Date;&#10;import java.util.Map;&#10;&#10;/**&#10; * Model class đại diện cho một nhắc nhở sức khỏe&#10; * Được tối ưu hóa để tương thích với Firebase Realtime Database&#10; */&#10;public class Reminder {&#10;    private String id;&#10;    private String userId;&#10;    private String title;&#10;    private String description;&#10;    private Long reminderTime; // Sử dụng Long thay vì Date để tương thích Firebase&#10;    private int repeatType; // 0: Không lặp, 1: Hàng ngày, 2: Hàng tuần, 3: Hàng tháng&#10;    private boolean isActive;&#10;    private Long createdAt; // Sử dụng Long thay vì Date&#10;    private Long updatedAt; // Sử dụng Long thay vì Date&#10;    private String healthTipId; // ID của mẹo sức khỏe liên quan (nếu có)&#10;&#10;    /**&#10;     * Các method bổ sung cho Reminder&#10;     */&#10;&#10;    // Field bổ sung cho lastNotified và completed&#10;    private Long lastNotified;&#10;    private boolean completed = false;&#10;&#10;    // Enum cho loại lặp lại&#10;    public static class RepeatType {&#10;        public static final int NO_REPEAT = 0;&#10;        public static final int DAILY = 1;&#10;        public static final int WEEKLY = 2;&#10;        public static final int MONTHLY = 3;&#10;    }&#10;&#10;    // Constructor mặc định (cần thiết cho Firebase)&#10;    public Reminder() {&#10;        long currentTime = System.currentTimeMillis();&#10;        this.createdAt = currentTime;&#10;        this.updatedAt = currentTime;&#10;        this.isActive = true;&#10;        this.repeatType = RepeatType.NO_REPEAT;&#10;    }&#10;&#10;    // Constructor đầy đủ&#10;    public Reminder(String id, String userId, String title, String description,&#10;                   Date reminderTime, int repeatType, boolean isActive, String healthTipId) {&#10;        this.id = id;&#10;        this.userId = userId;&#10;        this.title = title;&#10;        this.description = description;&#10;        this.reminderTime = reminderTime != null ? reminderTime.getTime() : null;&#10;        this.repeatType = repeatType;&#10;        this.isActive = isActive;&#10;        this.healthTipId = healthTipId;&#10;        long currentTime = System.currentTimeMillis();&#10;        this.createdAt = currentTime;&#10;        this.updatedAt = currentTime;&#10;    }&#10;&#10;    // Getters với Firebase annotations&#10;    public String getId() {&#10;        return id;&#10;    }&#10;&#10;    public String getUserId() {&#10;        return userId;&#10;    }&#10;&#10;    public String getTitle() {&#10;        return title;&#10;    }&#10;&#10;    public String getDescription() {&#10;        return description;&#10;    }&#10;&#10;    // Firebase getter - trả về Long&#10;    public Long getReminderTime() {&#10;        return reminderTime;&#10;    }&#10;&#10;    // UI helper method - trả về Date&#10;    @Exclude&#10;    public Date getReminderTimeAsDate() {&#10;        return reminderTime != null ? new Date(reminderTime) : null;&#10;    }&#10;&#10;    public int getRepeatType() {&#10;        return repeatType;&#10;    }&#10;&#10;    @PropertyName(&quot;isActive&quot;)&#10;    public boolean isActive() {&#10;        return isActive;&#10;    }&#10;&#10;    // Firebase getter - trả về Long&#10;    public Long getCreatedAt() {&#10;        return createdAt;&#10;    }&#10;&#10;    // UI helper method - trả về Date&#10;    @Exclude&#10;    public Date getCreatedAtAsDate() {&#10;        return createdAt != null ? new Date(createdAt) : null;&#10;    }&#10;&#10;    // Firebase getter - trả về Long&#10;    public Long getUpdatedAt() {&#10;        return updatedAt;&#10;    }&#10;&#10;    // UI helper method - trả về Date&#10;    @Exclude&#10;    public Date getUpdatedAtAsDate() {&#10;        return updatedAt != null ? new Date(updatedAt) : null;&#10;    }&#10;&#10;    public String getHealthTipId() {&#10;        return healthTipId;&#10;    }&#10;&#10;    // Field bổ sung cho lastNotified và completed&#10;    public Long getLastNotified() {&#10;        return lastNotified;&#10;    }&#10;&#10;    public boolean isCompleted() {&#10;        return completed;&#10;    }&#10;&#10;    // Setters&#10;    public void setId(String id) {&#10;        this.id = id;&#10;    }&#10;&#10;    public void setUserId(String userId) {&#10;        this.userId = userId;&#10;    }&#10;&#10;    public void setTitle(String title) {&#10;        this.title = title;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    public void setDescription(String description) {&#10;        this.description = description;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    // Firebase setter - nhận Long&#10;    public void setReminderTime(Long reminderTime) {&#10;        this.reminderTime = reminderTime;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    // UI helper method - nhận Date&#10;    @Exclude&#10;    public void setReminderTimeFromDate(Date reminderTime) {&#10;        this.reminderTime = reminderTime != null ? reminderTime.getTime() : null;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    public void setRepeatType(int repeatType) {&#10;        this.repeatType = repeatType;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    @PropertyName(&quot;isActive&quot;)&#10;    public void setActive(boolean active) {&#10;        isActive = active;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    // Firebase setter - nhận Long&#10;    public void setCreatedAt(Long createdAt) {&#10;        this.createdAt = createdAt;&#10;    }&#10;&#10;    // UI helper method - nhận Date&#10;    @Exclude&#10;    public void setCreatedAtFromDate(Date createdAt) {&#10;        this.createdAt = createdAt != null ? createdAt.getTime() : null;&#10;    }&#10;&#10;    // Firebase setter - nhận Long&#10;    public void setUpdatedAt(Long updatedAt) {&#10;        this.updatedAt = updatedAt;&#10;    }&#10;&#10;    // UI helper method - nhận Date&#10;    @Exclude&#10;    public void setUpdatedAtFromDate(Date updatedAt) {&#10;        this.updatedAt = updatedAt != null ? updatedAt.getTime() : null;&#10;    }&#10;&#10;    public void setHealthTipId(String healthTipId) {&#10;        this.healthTipId = healthTipId;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    public void setLastNotified(Long lastNotified) {&#10;        this.lastNotified = lastNotified;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    public void setCompleted(boolean completed) {&#10;        this.completed = completed;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    /**&#10;     * Tính toán thời gian nhắc nhở tiếp theo dựa trên loại lặp lại&#10;     */&#10;    @Exclude&#10;    public Date getNextReminderTime() {&#10;        if (reminderTime == null || repeatType == RepeatType.NO_REPEAT) {&#10;            return getReminderTimeAsDate();&#10;        }&#10;&#10;        Calendar calendar = Calendar.getInstance();&#10;        calendar.setTime(getReminderTimeAsDate());&#10;&#10;        switch (repeatType) {&#10;            case RepeatType.DAILY:&#10;                calendar.add(Calendar.DAY_OF_MONTH, 1);&#10;                break;&#10;            case RepeatType.WEEKLY:&#10;                calendar.add(Calendar.WEEK_OF_YEAR, 1);&#10;                break;&#10;            case RepeatType.MONTHLY:&#10;                calendar.add(Calendar.MONTH, 1);&#10;                break;&#10;            default:&#10;                return getReminderTimeAsDate();&#10;        }&#10;&#10;        return calendar.getTime();&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra xem nhắc nhở có đã đến giờ hay chưa&#10;     */&#10;    @Exclude&#10;    public boolean isDue() {&#10;        if (reminderTime == null || !isActive) {&#10;            return false;&#10;        }&#10;        return System.currentTimeMillis() &gt;= reminderTime;&#10;    }&#10;&#10;    /**&#10;     * Lấy tên hiển thị cho loại lặp lại&#10;     */&#10;    @Exclude&#10;    public String getRepeatTypeDisplayName() {&#10;        switch (repeatType) {&#10;            case RepeatType.NO_REPEAT:&#10;                return &quot;Không lặp lại&quot;;&#10;            case RepeatType.DAILY:&#10;                return &quot;Hàng ngày&quot;;&#10;            case RepeatType.WEEKLY:&#10;                return &quot;Hàng tuần&quot;;&#10;            case RepeatType.MONTHLY:&#10;                return &quot;Hàng tháng&quot;;&#10;            default:&#10;                return &quot;Không xác định&quot;;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lấy Map để ghi vào Firebase với ServerValue.TIMESTAMP&#10;     */&#10;    @Exclude&#10;    public Map&lt;String, Object&gt; toFirebaseMap() {&#10;        Map&lt;String, Object&gt; map = new java.util.HashMap&lt;&gt;();&#10;        map.put(&quot;id&quot;, id);&#10;        map.put(&quot;userId&quot;, userId);&#10;        map.put(&quot;title&quot;, title);&#10;        map.put(&quot;description&quot;, description);&#10;        map.put(&quot;reminderTime&quot;, reminderTime);&#10;        map.put(&quot;repeatType&quot;, repeatType);&#10;        map.put(&quot;isActive&quot;, isActive);&#10;        map.put(&quot;healthTipId&quot;, healthTipId);&#10;        map.put(&quot;createdAt&quot;, createdAt != null ? createdAt : ServerValue.TIMESTAMP);&#10;        map.put(&quot;updatedAt&quot;, ServerValue.TIMESTAMP);&#10;        return map;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;Reminder{&quot; +&#10;                &quot;id='&quot; + id + '\'' +&#10;                &quot;, title='&quot; + title + '\'' +&#10;                &quot;, reminderTime=&quot; + getReminderTimeAsDate() +&#10;                &quot;, isActive=&quot; + isActive +&#10;                '}';&#10;    }&#10;&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.data;&#10;&#10;import com.google.firebase.database.PropertyName;&#10;import com.google.firebase.database.ServerValue;&#10;import com.google.firebase.database.Exclude;&#10;import java.io.Serializable;&#10;import java.util.Calendar;&#10;import java.util.Date;&#10;import java.util.Map;&#10;&#10;/**&#10; * Model class đại diện cho một nhắc nhở sức khỏe&#10; * Được tối ưu hóa để tương thích với Firebase Realtime Database&#10; */&#10;public class Reminder implements Serializable {&#10;    private String id;&#10;    private String userId;&#10;    private String title;&#10;    private String description;&#10;    private Long reminderTime; // Sử dụng Long thay vì Date để tương thích Firebase&#10;    private int repeatType; // 0: Không lặp, 1: Hàng ngày, 2: Hàng tuần, 3: Hàng tháng&#10;    private boolean isActive;&#10;    private Long createdAt; // Sử dụng Long thay vì Date&#10;    private Long updatedAt; // Sử dụng Long thay vì Date&#10;    private String healthTipId; // ID của mẹo sức khỏe liên quan (nếu có)&#10;&#10;    /**&#10;     * Các method bổ sung cho Reminder&#10;     */&#10;&#10;    // Field bổ sung cho lastNotified và completed&#10;    private Long lastNotified;&#10;    private boolean completed = false;&#10;&#10;    // Enum cho loại lặp lại&#10;    public static class RepeatType {&#10;        public static final int NO_REPEAT = 0;&#10;        public static final int DAILY = 1;&#10;        public static final int WEEKLY = 2;&#10;        public static final int MONTHLY = 3;&#10;    }&#10;&#10;    // Constructor mặc định (cần thiết cho Firebase)&#10;    public Reminder() {&#10;        long currentTime = System.currentTimeMillis();&#10;        this.createdAt = currentTime;&#10;        this.updatedAt = currentTime;&#10;        this.isActive = true;&#10;        this.repeatType = RepeatType.NO_REPEAT;&#10;    }&#10;&#10;    // Constructor đầy đủ&#10;    public Reminder(String id, String userId, String title, String description,&#10;                   Date reminderTime, int repeatType, boolean isActive, String healthTipId) {&#10;        this.id = id;&#10;        this.userId = userId;&#10;        this.title = title;&#10;        this.description = description;&#10;        this.reminderTime = reminderTime != null ? reminderTime.getTime() : null;&#10;        this.repeatType = repeatType;&#10;        this.isActive = isActive;&#10;        this.healthTipId = healthTipId;&#10;        long currentTime = System.currentTimeMillis();&#10;        this.createdAt = currentTime;&#10;        this.updatedAt = currentTime;&#10;    }&#10;&#10;    // Getters với Firebase annotations&#10;    public String getId() {&#10;        return id;&#10;    }&#10;&#10;    public String getUserId() {&#10;        return userId;&#10;    }&#10;&#10;    public String getTitle() {&#10;        return title;&#10;    }&#10;&#10;    public String getDescription() {&#10;        return description;&#10;    }&#10;&#10;    // Firebase getter - trả về Long&#10;    public Long getReminderTime() {&#10;        return reminderTime;&#10;    }&#10;&#10;    // UI helper method - trả về Date&#10;    @Exclude&#10;    public Date getReminderTimeAsDate() {&#10;        return reminderTime != null ? new Date(reminderTime) : null;&#10;    }&#10;&#10;    public int getRepeatType() {&#10;        return repeatType;&#10;    }&#10;&#10;    @PropertyName(&quot;isActive&quot;)&#10;    public boolean isActive() {&#10;        return isActive;&#10;    }&#10;&#10;    // Firebase getter - trả về Long&#10;    public Long getCreatedAt() {&#10;        return createdAt;&#10;    }&#10;&#10;    // UI helper method - trả về Date&#10;    @Exclude&#10;    public Date getCreatedAtAsDate() {&#10;        return createdAt != null ? new Date(createdAt) : null;&#10;    }&#10;&#10;    // Firebase getter - trả về Long&#10;    public Long getUpdatedAt() {&#10;        return updatedAt;&#10;    }&#10;&#10;    // UI helper method - trả về Date&#10;    @Exclude&#10;    public Date getUpdatedAtAsDate() {&#10;        return updatedAt != null ? new Date(updatedAt) : null;&#10;    }&#10;&#10;    public String getHealthTipId() {&#10;        return healthTipId;&#10;    }&#10;&#10;    // Field bổ sung cho lastNotified và completed&#10;    public Long getLastNotified() {&#10;        return lastNotified;&#10;    }&#10;&#10;    public boolean isCompleted() {&#10;        return completed;&#10;    }&#10;&#10;    // Setters&#10;    public void setId(String id) {&#10;        this.id = id;&#10;    }&#10;&#10;    public void setUserId(String userId) {&#10;        this.userId = userId;&#10;    }&#10;&#10;    public void setTitle(String title) {&#10;        this.title = title;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    public void setDescription(String description) {&#10;        this.description = description;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    // Firebase setter - nhận Long&#10;    public void setReminderTime(Long reminderTime) {&#10;        this.reminderTime = reminderTime;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    // UI helper method - nhận Date&#10;    @Exclude&#10;    public void setReminderTimeFromDate(Date reminderTime) {&#10;        this.reminderTime = reminderTime != null ? reminderTime.getTime() : null;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    public void setRepeatType(int repeatType) {&#10;        this.repeatType = repeatType;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    @PropertyName(&quot;isActive&quot;)&#10;    public void setActive(boolean active) {&#10;        isActive = active;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    // Firebase setter - nhận Long&#10;    public void setCreatedAt(Long createdAt) {&#10;        this.createdAt = createdAt;&#10;    }&#10;&#10;    // UI helper method - nhận Date&#10;    @Exclude&#10;    public void setCreatedAtFromDate(Date createdAt) {&#10;        this.createdAt = createdAt != null ? createdAt.getTime() : null;&#10;    }&#10;&#10;    // Firebase setter - nhận Long&#10;    public void setUpdatedAt(Long updatedAt) {&#10;        this.updatedAt = updatedAt;&#10;    }&#10;&#10;    // UI helper method - nhận Date&#10;    @Exclude&#10;    public void setUpdatedAtFromDate(Date updatedAt) {&#10;        this.updatedAt = updatedAt != null ? updatedAt.getTime() : null;&#10;    }&#10;&#10;    public void setHealthTipId(String healthTipId) {&#10;        this.healthTipId = healthTipId;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    public void setLastNotified(Long lastNotified) {&#10;        this.lastNotified = lastNotified;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    public void setCompleted(boolean completed) {&#10;        this.completed = completed;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    /**&#10;     * Tính toán thời gian nhắc nhở tiếp theo dựa trên loại lặp lại&#10;     */&#10;    @Exclude&#10;    public Date getNextReminderTime() {&#10;        if (reminderTime == null || repeatType == RepeatType.NO_REPEAT) {&#10;            return getReminderTimeAsDate();&#10;        }&#10;&#10;        Calendar calendar = Calendar.getInstance();&#10;        calendar.setTime(getReminderTimeAsDate());&#10;&#10;        switch (repeatType) {&#10;            case RepeatType.DAILY:&#10;                calendar.add(Calendar.DAY_OF_MONTH, 1);&#10;                break;&#10;            case RepeatType.WEEKLY:&#10;                calendar.add(Calendar.WEEK_OF_YEAR, 1);&#10;                break;&#10;            case RepeatType.MONTHLY:&#10;                calendar.add(Calendar.MONTH, 1);&#10;                break;&#10;            default:&#10;                return getReminderTimeAsDate();&#10;        }&#10;&#10;        return calendar.getTime();&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra xem nhắc nhở có đã đến giờ hay chưa&#10;     */&#10;    @Exclude&#10;    public boolean isDue() {&#10;        if (reminderTime == null || !isActive) {&#10;            return false;&#10;        }&#10;        return System.currentTimeMillis() &gt;= reminderTime;&#10;    }&#10;&#10;    /**&#10;     * Lấy tên hiển thị cho loại lặp lại&#10;     */&#10;    @Exclude&#10;    public String getRepeatTypeDisplayName() {&#10;        switch (repeatType) {&#10;            case RepeatType.NO_REPEAT:&#10;                return &quot;Không lặp lại&quot;;&#10;            case RepeatType.DAILY:&#10;                return &quot;Hàng ngày&quot;;&#10;            case RepeatType.WEEKLY:&#10;                return &quot;Hàng tuần&quot;;&#10;            case RepeatType.MONTHLY:&#10;                return &quot;Hàng tháng&quot;;&#10;            default:&#10;                return &quot;Không xác định&quot;;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lấy Map để ghi vào Firebase với ServerValue.TIMESTAMP&#10;     */&#10;    @Exclude&#10;    public Map&lt;String, Object&gt; toFirebaseMap() {&#10;        Map&lt;String, Object&gt; map = new java.util.HashMap&lt;&gt;();&#10;        map.put(&quot;id&quot;, id);&#10;        map.put(&quot;userId&quot;, userId);&#10;        map.put(&quot;title&quot;, title);&#10;        map.put(&quot;description&quot;, description);&#10;        map.put(&quot;reminderTime&quot;, reminderTime);&#10;        map.put(&quot;repeatType&quot;, repeatType);&#10;        map.put(&quot;isActive&quot;, isActive);&#10;        map.put(&quot;healthTipId&quot;, healthTipId);&#10;        map.put(&quot;createdAt&quot;, createdAt != null ? createdAt : ServerValue.TIMESTAMP);&#10;        map.put(&quot;updatedAt&quot;, ServerValue.TIMESTAMP);&#10;        return map;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;Reminder{&quot; +&#10;                &quot;id='&quot; + id + '\'' +&#10;                &quot;, title='&quot; + title + '\'' +&#10;                &quot;, reminderTime=&quot; + getReminderTimeAsDate() +&#10;                &quot;, isActive=&quot; + isActive +&#10;                '}';&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra xem reminder có lặp lại hay không&#10;     */&#10;    @Exclude&#10;    public boolean isRepeating() {&#10;        return repeatType != RepeatType.NO_REPEAT;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/data/repository/RepositoryCallback.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/data/repository/RepositoryCallback.java" />
              <option name="updatedContent" value="package com.vhn.doan.data.repository;&#10;&#10;/**&#10; * Generic callback interface cho các thao tác repository&#10; * @param &lt;T&gt; Kiểu dữ liệu trả về&#10; */&#10;public interface RepositoryCallback&lt;T&gt; {&#10;    &#10;    /**&#10;     * Được gọi khi thao tác thành công&#10;     * @param result Kết quả trả về&#10;     */&#10;    void onSuccess(T result);&#10;    &#10;    /**&#10;     * Được gọi khi thao tác thất bại&#10;     * @param error Thông tin lỗi&#10;     */&#10;    void onError(String error);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/presentation/home/HomeActivity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/presentation/home/HomeActivity.java" />
              <option name="originalContent" value="package com.vhn.doan.presentation.home;&#10;&#10;import android.content.Intent;&#10;import android.os.Bundle;&#10;import android.view.MenuItem;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.fragment.app.Fragment;&#10;&#10;import com.google.android.material.bottomnavigation.BottomNavigationView;&#10;import com.google.android.material.navigation.NavigationBarView;&#10;import com.vhn.doan.R;&#10;import com.vhn.doan.presentation.auth.LoginActivity;&#10;import com.vhn.doan.presentation.favorite.FavoriteFragment;&#10;import com.vhn.doan.presentation.profile.ProfileFragment;&#10;import com.vhn.doan.presentation.reminder.ReminderFragment;&#10;import com.vhn.doan.services.AuthManager;&#10;&#10;/**&#10; * HomeActivity là màn hình chính của ứng dụng sau khi đăng nhập&#10; * Chứa HomeFragment và các Fragment khác thông qua BottomNavigationView&#10; */&#10;public class HomeActivity extends AppCompatActivity {&#10;&#10;    private BottomNavigationView bottomNavigationView;&#10;    private AuthManager authManager;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        setContentView(R.layout.activity_home);&#10;&#10;        // Khởi tạo AuthManager&#10;        authManager = new AuthManager(this);&#10;&#10;        // Kiểm tra đăng nhập&#10;        if (!authManager.isUserLoggedIn()) {&#10;            // Chuyển về màn hình đăng nhập nếu chưa đăng nhập&#10;            Intent intent = new Intent(this, LoginActivity.class);&#10;            intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);&#10;            startActivity(intent);&#10;            finish();&#10;            return;&#10;        }&#10;&#10;        // Khởi tạo và thiết lập BottomNavigationView&#10;        setupBottomNavigation();&#10;&#10;        // Mặc định hiển thị HomeFragment khi khởi động&#10;        if (savedInstanceState == null) {&#10;            loadFragment(new HomeFragment());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Method để xử lý onClick từ XML layout cho nút tạo reminder&#10;     * Sửa lỗi: IllegalStateException: Could not find method onCreateReminderClick&#10;     */&#10;    public void onCreateReminderClick(android.view.View view) {&#10;        // Tìm ReminderFragment hiện tại và gọi method tạo reminder&#10;        Fragment currentFragment = getSupportFragmentManager().findFragmentById(R.id.fragment_container);&#10;        if (currentFragment instanceof ReminderFragment) {&#10;            ReminderFragment reminderFragment = (ReminderFragment) currentFragment;&#10;            reminderFragment.onCreateReminderClick();&#10;        }&#10;    }&#10;&#10;    private void setupBottomNavigation() {&#10;        bottomNavigationView = findViewById(R.id.bottom_navigation);&#10;        bottomNavigationView.setOnItemSelectedListener(new NavigationBarView.OnItemSelectedListener() {&#10;            @Override&#10;            public boolean onNavigationItemSelected(@NonNull MenuItem item) {&#10;                Fragment fragment = null;&#10;                int itemId = item.getItemId();&#10;&#10;                if (itemId == R.id.nav_home) {&#10;                    fragment = HomeFragment.newInstance();&#10;                } else if (itemId == R.id.nav_reminders) {&#10;                    // Kích hoạt ReminderFragment&#10;                    fragment = ReminderFragment.newInstance();&#10;                } else if (itemId == R.id.nav_videos) {&#10;                    // Tạm thời vẫn dùng HomeFragment&#10;                    // Sẽ thay thế bằng ShortVideoFragment khi phát triển&#10;                    fragment = HomeFragment.newInstance();&#10;                    // fragment = ShortVideoFragment.newInstance();&#10;                } else if (itemId == R.id.nav_favorites) {&#10;                    // Kích hoạt FavoriteFragment&#10;                    fragment = FavoriteFragment.newInstance();&#10;                } else if (itemId == R.id.nav_profile) {&#10;                    // Sử dụng ProfileFragment thay vì HomeFragment&#10;                    fragment = ProfileFragment.newInstance();&#10;                }&#10;&#10;                return loadFragment(fragment);&#10;            }&#10;        });&#10;    }&#10;&#10;    private boolean loadFragment(Fragment fragment) {&#10;        if (fragment != null) {&#10;            getSupportFragmentManager()&#10;                    .beginTransaction()&#10;                    .replace(R.id.fragment_container, fragment)&#10;                    .commit();&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.presentation.home;&#10;&#10;import android.content.Intent;&#10;import android.os.Bundle;&#10;import android.util.Log;&#10;import android.view.MenuItem;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.fragment.app.Fragment;&#10;&#10;import com.google.android.material.bottomnavigation.BottomNavigationView;&#10;import com.google.android.material.navigation.NavigationBarView;&#10;import com.vhn.doan.R;&#10;import com.vhn.doan.presentation.auth.LoginActivity;&#10;import com.vhn.doan.presentation.favorite.FavoriteFragment;&#10;import com.vhn.doan.presentation.profile.ProfileFragment;&#10;import com.vhn.doan.presentation.reminder.ReminderFragment;&#10;import com.vhn.doan.services.AuthManager;&#10;import com.vhn.doan.services.ReminderManager;&#10;import com.vhn.doan.utils.UserSessionManager;&#10;&#10;/**&#10; * HomeActivity là màn hình chính của ứng dụng sau khi đăng nhập&#10; * Chứa HomeFragment và các Fragment khác thông qua BottomNavigationView&#10; */&#10;public class HomeActivity extends AppCompatActivity {&#10;&#10;    private static final String TAG = &quot;HomeActivity&quot;;&#10;    private BottomNavigationView bottomNavigationView;&#10;    private AuthManager authManager;&#10;    private ReminderManager reminderManager;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        setContentView(R.layout.activity_home);&#10;&#10;        // Khởi tạo AuthManager&#10;        authManager = new AuthManager(this);&#10;&#10;        // Kiểm tra đăng nhập&#10;        if (!authManager.isUserLoggedIn()) {&#10;            // Chuyển về màn hình đăng nhập nếu chưa đăng nhập&#10;            Intent intent = new Intent(this, LoginActivity.class);&#10;            intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);&#10;            startActivity(intent);&#10;            finish();&#10;            return;&#10;        }&#10;&#10;        // Khởi tạo ReminderManager&#10;        reminderManager = new ReminderManager(new UserSessionManager(this));&#10;        &#10;        // Khởi động ReminderForegroundService&#10;        reminderManager.startReminderService(this);&#10;        Log.d(TAG, &quot;ReminderForegroundService đã được khởi động từ HomeActivity&quot;);&#10;&#10;        // Khởi tạo và thiết lập BottomNavigationView&#10;        setupBottomNavigation();&#10;&#10;        // Mặc định hiển thị HomeFragment khi khởi động&#10;        if (savedInstanceState == null) {&#10;            loadFragment(new HomeFragment());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    protected void onResume() {&#10;        super.onResume();&#10;        &#10;        // Khởi động lại ReminderForegroundService khi activity được resume&#10;        if (reminderManager != null) {&#10;            // Khởi động lại service để đảm bảo nó đang chạy&#10;            reminderManager.startReminderService(this);&#10;            &#10;            // Khởi động lại tất cả reminders đang active&#10;            reminderManager.restartAllReminders(this);&#10;            &#10;            // Kiểm tra và hiển thị reminders đã bị miss&#10;            reminderManager.checkAndShowMissedReminders(this);&#10;            &#10;            Log.d(TAG, &quot;Đã khởi động lại và kiểm tra reminders trong onResume&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Method để xử lý onClick từ XML layout cho nút tạo reminder&#10;     * Sửa lỗi: IllegalStateException: Could not find method onCreateReminderClick&#10;     */&#10;    public void onCreateReminderClick(android.view.View view) {&#10;        // Tìm ReminderFragment hiện tại và gọi method tạo reminder&#10;        Fragment currentFragment = getSupportFragmentManager().findFragmentById(R.id.fragment_container);&#10;        if (currentFragment instanceof ReminderFragment) {&#10;            ReminderFragment reminderFragment = (ReminderFragment) currentFragment;&#10;            reminderFragment.onCreateReminderClick();&#10;        }&#10;    }&#10;&#10;    private void setupBottomNavigation() {&#10;        bottomNavigationView = findViewById(R.id.bottom_navigation);&#10;        bottomNavigationView.setOnItemSelectedListener(new NavigationBarView.OnItemSelectedListener() {&#10;            @Override&#10;            public boolean onNavigationItemSelected(@NonNull MenuItem item) {&#10;                Fragment fragment = null;&#10;                int itemId = item.getItemId();&#10;&#10;                if (itemId == R.id.nav_home) {&#10;                    fragment = HomeFragment.newInstance();&#10;                } else if (itemId == R.id.nav_reminders) {&#10;                    // Kích hoạt ReminderFragment&#10;                    fragment = ReminderFragment.newInstance();&#10;                } else if (itemId == R.id.nav_videos) {&#10;                    // Tạm thời vẫn dùng HomeFragment&#10;                    // Sẽ thay thế bằng ShortVideoFragment khi phát triển&#10;                    fragment = HomeFragment.newInstance();&#10;                    // fragment = ShortVideoFragment.newInstance();&#10;                } else if (itemId == R.id.nav_favorites) {&#10;                    // Kích hoạt FavoriteFragment&#10;                    fragment = FavoriteFragment.newInstance();&#10;                } else if (itemId == R.id.nav_profile) {&#10;                    // Sử dụng ProfileFragment thay vì HomeFragment&#10;                    fragment = ProfileFragment.newInstance();&#10;                }&#10;&#10;                return loadFragment(fragment);&#10;            }&#10;        });&#10;    }&#10;&#10;    private boolean loadFragment(Fragment fragment) {&#10;        if (fragment != null) {&#10;            getSupportFragmentManager()&#10;                    .beginTransaction()&#10;                    .replace(R.id.fragment_container, fragment)&#10;                    .commit();&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/receivers/ReminderBroadcastReceiver.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/receivers/ReminderBroadcastReceiver.java" />
              <option name="originalContent" value="package com.vhn.doan.receivers;&#10;&#10;import android.content.BroadcastReceiver;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.os.PowerManager;&#10;import android.util.Log;&#10;&#10;import com.vhn.doan.data.Reminder;&#10;import com.vhn.doan.data.repository.ReminderRepository;&#10;import com.vhn.doan.data.repository.ReminderRepositoryImpl;&#10;import com.vhn.doan.services.ReminderService;&#10;&#10;/**&#10; * BroadcastReceiver để xử lý khi thời gian nhắc nhở đã đến&#10; */&#10;public class ReminderBroadcastReceiver extends BroadcastReceiver {&#10;&#10;    private static final String TAG = &quot;ReminderBroadcastReceiver&quot;;&#10;&#10;    @Override&#10;    public void onReceive(Context context, Intent intent) {&#10;        // Acquire wake lock để đảm bảo thiết bị không sleep trong quá trình xử lý&#10;        PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);&#10;        PowerManager.WakeLock wakeLock = powerManager.newWakeLock(&#10;            PowerManager.PARTIAL_WAKE_LOCK,&#10;            &quot;HealthTips:ReminderReceiver&quot;&#10;        );&#10;&#10;        try {&#10;            // Acquire wake lock với timeout 10 giây&#10;            wakeLock.acquire(10 * 1000);&#10;&#10;            Log.d(TAG, &quot;ReminderBroadcastReceiver triggered&quot;);&#10;&#10;            String action = intent.getAction();&#10;            if (action == null) {&#10;                Log.w(TAG, &quot;Action is null&quot;);&#10;                return;&#10;            }&#10;&#10;            switch (action) {&#10;                case ReminderService.ACTION_REMINDER_TRIGGER:&#10;                    handleReminderTrigger(context, intent);&#10;                    break;&#10;                case &quot;REMINDER_STATUS_CHANGED&quot;:&#10;                    handleReminderStatusChanged(context, intent);&#10;                    break;&#10;                default:&#10;                    Log.w(TAG, &quot;Unknown action: &quot; + action);&#10;                    break;&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error in onReceive&quot;, e);&#10;        } finally {&#10;            // Luôn release wake lock&#10;            if (wakeLock.isHeld()) {&#10;                wakeLock.release();&#10;            }&#10;        }&#10;    }&#10;&#10;    private void handleReminderTrigger(Context context, Intent intent) {&#10;        String reminderId = intent.getStringExtra(&quot;reminder_id&quot;);&#10;        String title = intent.getStringExtra(&quot;title&quot;);&#10;        String message = intent.getStringExtra(&quot;message&quot;);&#10;&#10;        Log.d(TAG, &quot;Handling reminder trigger - ID: &quot; + reminderId + &quot;, Title: &quot; + title);&#10;&#10;        if (reminderId == null || title == null || message == null) {&#10;            Log.w(TAG, &quot;Missing reminder data&quot;);&#10;            return;&#10;        }&#10;&#10;        // Sử dụng Foreground Service để đảm bảo thông báo hiển thị&#10;        com.vhn.doan.services.ReminderForegroundService.showReminder(context, reminderId, title, message);&#10;&#10;        // Cập nhật trạng thái reminder&#10;        ReminderRepository reminderRepository = new ReminderRepositoryImpl();&#10;        reminderRepository.getReminderById(reminderId, new ReminderRepository.RepositoryCallback&lt;Reminder&gt;() {&#10;            @Override&#10;            public void onSuccess(Reminder reminder) {&#10;                if (reminder != null) {&#10;                    Log.d(TAG, &quot;Successfully retrieved reminder: &quot; + reminder.getTitle());&#10;&#10;                    // Cập nhật lần thông báo cuối&#10;                    reminder.setLastNotified(System.currentTimeMillis());&#10;&#10;                    // Nếu không phải reminder lặp lại, đánh dấu là đã hoàn thành&#10;                    if (!reminder.isRepeating()) {&#10;                        reminder.setCompleted(true);&#10;                        reminder.setActive(false);&#10;                    }&#10;&#10;                    reminderRepository.updateReminder(reminder, new ReminderRepository.RepositoryCallback&lt;Void&gt;() {&#10;                        @Override&#10;                        public void onSuccess(Void result) {&#10;                            Log.d(TAG, &quot;Reminder updated successfully&quot;);&#10;                        }&#10;&#10;                        @Override&#10;                        public void onError(String error) {&#10;                            Log.e(TAG, &quot;Failed to update reminder: &quot; + error);&#10;                        }&#10;                    });&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                Log.e(TAG, &quot;Failed to get reminder: &quot; + error);&#10;                // Vẫn hiển thị thông báo ngay cả khi không lấy được reminder từ database&#10;                com.vhn.doan.services.ReminderForegroundService.showReminder(context, reminderId, title, message);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void handleReminderStatusChanged(Context context, Intent intent) {&#10;        String reminderId = intent.getStringExtra(&quot;reminder_id&quot;);&#10;        boolean isActive = intent.getBooleanExtra(&quot;is_active&quot;, false);&#10;&#10;        Log.d(TAG, &quot;Reminder status changed - ID: &quot; + reminderId + &quot;, Active: &quot; + isActive);&#10;&#10;        // Xử lý thay đổi trạng thái reminder nếu cần&#10;        if (!isActive) {&#10;            // Hủy alarm nếu reminder bị tắt&#10;            ReminderService.cancelReminder(context, reminderId);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.receivers;&#10;&#10;import android.content.BroadcastReceiver;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.os.Build;&#10;import android.os.PowerManager;&#10;import android.util.Log;&#10;&#10;import com.vhn.doan.data.Reminder;&#10;import com.vhn.doan.data.repository.ReminderRepository;&#10;import com.vhn.doan.data.repository.ReminderRepositoryImpl;&#10;import com.vhn.doan.services.ReminderForegroundService;&#10;import com.vhn.doan.services.ReminderService;&#10;import com.vhn.doan.utils.NotificationDebugHelper;&#10;&#10;/**&#10; * BroadcastReceiver để xử lý khi thời gian nhắc nhở đã đến&#10; * - Hiển thị thông báo ngay lập tức khi nhận broadcast&#10; * - Khởi động lại ReminderForegroundService nếu cần&#10; * - Cập nhật trạng thái reminder&#10; */&#10;public class ReminderBroadcastReceiver extends BroadcastReceiver {&#10;&#10;    private static final String TAG = &quot;ReminderBroadcastReceiver&quot;;&#10;&#10;    @Override&#10;    public void onReceive(Context context, Intent intent) {&#10;        // Acquire wake lock để đảm bảo thiết bị không sleep trong quá trình xử lý&#10;        PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);&#10;        PowerManager.WakeLock wakeLock = powerManager.newWakeLock(&#10;            PowerManager.PARTIAL_WAKE_LOCK,&#10;            &quot;HealthTips:ReminderReceiver&quot;&#10;        );&#10;&#10;        try {&#10;            // Acquire wake lock với timeout 10 giây&#10;            wakeLock.acquire(10 * 1000);&#10;&#10;            Log.d(TAG, &quot;ReminderBroadcastReceiver triggered&quot;);&#10;&#10;            String action = intent.getAction();&#10;            if (action == null) {&#10;                Log.w(TAG, &quot;Action is null&quot;);&#10;                return;&#10;            }&#10;&#10;            switch (action) {&#10;                case ReminderService.ACTION_REMINDER_TRIGGER:&#10;                    handleReminderTrigger(context, intent);&#10;                    break;&#10;                case &quot;REMINDER_STATUS_CHANGED&quot;:&#10;                    handleReminderStatusChanged(context, intent);&#10;                    break;&#10;                case &quot;ACTION_RESTART_REMINDER_SERVICE&quot;:&#10;                    // Khởi động lại ReminderForegroundService khi có yêu cầu&#10;                    handleRestartReminderService(context);&#10;                    break;&#10;                case Intent.ACTION_BOOT_COMPLETED:&#10;                    // Khởi động lại service sau khi thiết bị khởi động&#10;                    handleBootCompleted(context);&#10;                    break;&#10;                default:&#10;                    Log.w(TAG, &quot;Unknown action: &quot; + action);&#10;                    break;&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error in onReceive&quot;, e);&#10;            // Fallback để đảm bảo reminder vẫn được hiển thị ngay cả khi có lỗi&#10;            if (intent != null &amp;&amp; ReminderService.ACTION_REMINDER_TRIGGER.equals(intent.getAction())) {&#10;                showReminderDirectly(context, intent);&#10;            }&#10;        } finally {&#10;            // Luôn release wake lock&#10;            if (wakeLock.isHeld()) {&#10;                wakeLock.release();&#10;            }&#10;        }&#10;    }&#10;&#10;    private void handleReminderTrigger(Context context, Intent intent) {&#10;        // Hiển thị thông báo ngay lập tức để đảm bảo người dùng thấy thông báo&#10;        showReminderDirectly(context, intent);&#10;        &#10;        // Sau đó xử lý cập nhật dữ liệu&#10;        String reminderId = intent.getStringExtra(&quot;reminder_id&quot;);&#10;        String title = intent.getStringExtra(&quot;title&quot;);&#10;        String message = intent.getStringExtra(&quot;message&quot;);&#10;&#10;        Log.d(TAG, &quot;Handling reminder trigger - ID: &quot; + reminderId + &quot;, Title: &quot; + title);&#10;&#10;        if (reminderId == null || title == null || message == null) {&#10;            Log.w(TAG, &quot;Missing reminder data&quot;);&#10;            return;&#10;        }&#10;&#10;        // Cập nhật trạng thái reminder&#10;        ReminderRepository reminderRepository = new ReminderRepositoryImpl();&#10;        reminderRepository.getReminderById(reminderId, new ReminderRepository.RepositoryCallback&lt;Reminder&gt;() {&#10;            @Override&#10;            public void onSuccess(Reminder reminder) {&#10;                if (reminder != null) {&#10;                    Log.d(TAG, &quot;Successfully retrieved reminder: &quot; + reminder.getTitle());&#10;&#10;                    // Cập nhật lần thông báo cuối&#10;                    reminder.setLastNotified(System.currentTimeMillis());&#10;&#10;                    // Nếu không phải reminder lặp lại, đánh dấu là đã hoàn thành&#10;                    if (!reminder.isRepeating()) {&#10;                        reminder.setCompleted(true);&#10;                        reminder.setActive(false);&#10;                    }&#10;&#10;                    reminderRepository.updateReminder(reminder, new ReminderRepository.RepositoryCallback&lt;Void&gt;() {&#10;                        @Override&#10;                        public void onSuccess(Void result) {&#10;                            Log.d(TAG, &quot;Reminder updated successfully&quot;);&#10;                        }&#10;&#10;                        @Override&#10;                        public void onError(String error) {&#10;                            Log.e(TAG, &quot;Failed to update reminder: &quot; + error);&#10;                        }&#10;                    });&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                Log.e(TAG, &quot;Failed to get reminder: &quot; + error);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void handleReminderStatusChanged(Context context, Intent intent) {&#10;        String reminderId = intent.getStringExtra(&quot;reminder_id&quot;);&#10;        boolean isActive = intent.getBooleanExtra(&quot;is_active&quot;, false);&#10;&#10;        Log.d(TAG, &quot;Reminder status changed - ID: &quot; + reminderId + &quot;, Active: &quot; + isActive);&#10;&#10;        // Xử lý thay đổi trạng thái reminder nếu cần&#10;        if (!isActive) {&#10;            // Hủy alarm nếu reminder bị tắt&#10;            ReminderService.cancelReminder(context, reminderId);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Xử lý khởi động lại ReminderForegroundService&#10;     */&#10;    private void handleRestartReminderService(Context context) {&#10;        Log.d(TAG, &quot;Handling restart reminder service&quot;);&#10;        try {&#10;            // Khởi động lại ReminderForegroundService&#10;            Intent serviceIntent = new Intent(context, ReminderForegroundService.class);&#10;            serviceIntent.setAction(&quot;RESTART_SERVICE&quot;);&#10;            &#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                context.startForegroundService(serviceIntent);&#10;            } else {&#10;                context.startService(serviceIntent);&#10;            }&#10;            Log.d(TAG, &quot;ReminderForegroundService restarted successfully&quot;);&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error restarting ReminderForegroundService&quot;, e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Xử lý khi thiết bị khởi động xong&#10;     */&#10;    private void handleBootCompleted(Context context) {&#10;        Log.d(TAG, &quot;Handling boot completed&quot;);&#10;        try {&#10;            // Khởi động ReminderForegroundService sau khi thiết bị khởi động&#10;            Intent serviceIntent = new Intent(context, ReminderForegroundService.class);&#10;            &#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                context.startForegroundService(serviceIntent);&#10;            } else {&#10;                context.startService(serviceIntent);&#10;            }&#10;            Log.d(TAG, &quot;ReminderForegroundService started after boot&quot;);&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error starting ReminderForegroundService after boot&quot;, e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Hiển thị thông báo ngay lập tức không đợi service&#10;     * Dùng làm fallback khi có lỗi hoặc để đảm bảo thông báo được hiển thị ngay&#10;     */&#10;    private void showReminderDirectly(Context context, Intent intent) {&#10;        try {&#10;            String reminderId = intent.getStringExtra(&quot;reminder_id&quot;);&#10;            String title = intent.getStringExtra(&quot;title&quot;);&#10;            String message = intent.getStringExtra(&quot;message&quot;);&#10;            &#10;            if (reminderId != null &amp;&amp; title != null &amp;&amp; message != null) {&#10;                // Kiểm tra quyền thông báo&#10;                boolean hasPermission = NotificationDebugHelper.checkNotificationPermission(context);&#10;                Log.d(TAG, &quot;Notification permission: &quot; + (hasPermission ? &quot;Granted&quot; : &quot;Denied&quot;));&#10;                &#10;                // Hiển thị thông báo trực tiếp&#10;                ReminderForegroundService.showReminder(context, reminderId, title, message);&#10;                Log.d(TAG, &quot;Reminder notification shown directly: &quot; + title);&#10;            } else {&#10;                Log.w(TAG, &quot;Cannot show reminder directly: Missing data&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error showing reminder directly&quot;, e);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/services/ReminderForegroundService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/services/ReminderForegroundService.java" />
              <option name="originalContent" value="package com.vhn.doan.services;&#10;&#10;import android.app.Notification;&#10;import android.app.NotificationChannel;&#10;import android.app.NotificationManager;&#10;import android.app.PendingIntent;&#10;import android.app.Service;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.os.Build;&#10;import android.os.IBinder;&#10;import android.os.PowerManager;&#10;import android.util.Log;&#10;&#10;import androidx.annotation.Nullable;&#10;import androidx.core.app.NotificationCompat;&#10;&#10;import com.vhn.doan.R;&#10;import com.vhn.doan.presentation.home.HomeActivity;&#10;&#10;/**&#10; * Foreground Service để đảm bảo thông báo nhắc nhở hoạt động mạnh mẽ&#10; * Service này sẽ chạy trong background và không bị kill bởi hệ thống&#10; */&#10;public class ReminderForegroundService extends Service {&#10;&#10;    private static final String TAG = &quot;ReminderForegroundService&quot;;&#10;    private static final int FOREGROUND_NOTIFICATION_ID = 9999;&#10;    private static final String CHANNEL_ID = &quot;reminder_foreground_channel&quot;;&#10;&#10;    private PowerManager.WakeLock wakeLock;&#10;    private NotificationManager notificationManager;&#10;&#10;    @Override&#10;    public void onCreate() {&#10;        super.onCreate();&#10;        Log.d(TAG, &quot;ReminderForegroundService created&quot;);&#10;&#10;        // Tạo notification channel&#10;        createNotificationChannel();&#10;&#10;        // Acquire wake lock&#10;        PowerManager powerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);&#10;        wakeLock = powerManager.newWakeLock(&#10;            PowerManager.PARTIAL_WAKE_LOCK,&#10;            &quot;HealthTips:ReminderForegroundService&quot;&#10;        );&#10;        wakeLock.acquire();&#10;&#10;        notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);&#10;    }&#10;&#10;    @Override&#10;    public int onStartCommand(Intent intent, int flags, int startId) {&#10;        Log.d(TAG, &quot;ReminderForegroundService started&quot;);&#10;&#10;        // Bắt đầu chạy foreground&#10;        startForeground(FOREGROUND_NOTIFICATION_ID, createForegroundNotification());&#10;&#10;        // Xử lý intent nếu có&#10;        if (intent != null) {&#10;            String action = intent.getAction();&#10;            if (&quot;SHOW_REMINDER&quot;.equals(action)) {&#10;                handleShowReminder(intent);&#10;            }&#10;        }&#10;&#10;        if (wakeLock != null &amp;&amp; wakeLock.isHeld()) {&#10;            wakeLock.release();&#10;        }&#10;    }&#10;&#10;    @Nullable&#10;    @Override&#10;    public IBinder onBind(Intent intent) {&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Tạo notification channel cho foreground service&#10;     */&#10;    private void createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            NotificationChannel channel = new NotificationChannel(&#10;                CHANNEL_ID,&#10;                &quot;Dịch vụ nhắc nhở sức khỏe&quot;,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            );&#10;            channel.setDescription(&quot;Dịch vụ chạy ngầm để đảm bảo nhắc nhở hoạt động&quot;);&#10;            channel.setShowBadge(false);&#10;&#10;            NotificationManager manager = getSystemService(NotificationManager.class);&#10;            manager.createNotificationChannel(channel);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Tạo notification cho foreground service&#10;     */&#10;    private Notification createForegroundNotification() {&#10;        Intent intent = new Intent(this, HomeActivity.class);&#10;        intent.putExtra(&quot;open_reminders&quot;, true);&#10;&#10;        PendingIntent pendingIntent = PendingIntent.getActivity(&#10;            this,&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#10;        );&#10;&#10;        return new NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(&quot;Dịch vụ nhắc nhở đang hoạt động&quot;)&#10;            .setContentText(&quot;Đảm bảo bạn nhận được thông báo đúng giờ&quot;)&#10;            .setSmallIcon(R.drawable.ic_notification_reminder)&#10;            .setContentIntent(pendingIntent)&#10;            .setOngoing(true)&#10;            .setPriority(NotificationCompat.PRIORITY_LOW)&#10;            .setVisibility(NotificationCompat.VISIBILITY_SECRET)&#10;            .build();&#10;    }&#10;&#10;    /**&#10;     * Xử lý hiển thị reminder&#10;     */&#10;    private void handleShowReminder(Intent intent) {&#10;        String reminderId = intent.getStringExtra(&quot;reminder_id&quot;);&#10;        String title = intent.getStringExtra(&quot;title&quot;);&#10;        String message = intent.getStringExtra(&quot;message&quot;);&#10;&#10;        Log.d(TAG, &quot;Handling show reminder: &quot; + title);&#10;&#10;        if (title != null &amp;&amp; message != null) {&#10;            // Hiển thị thông báo nhắc nhở&#10;            NotificationService.showReminderNotification(this, title, message, reminderId);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Static method để start service và hiển thị reminder&#10;     */&#10;    public static void showReminder(Context context, String reminderId, String title, String message) {&#10;        Intent serviceIntent = new Intent(context, ReminderForegroundService.class);&#10;        serviceIntent.setAction(&quot;SHOW_REMINDER&quot;);&#10;        serviceIntent.putExtra(&quot;reminder_id&quot;, reminderId);&#10;        serviceIntent.putExtra(&quot;title&quot;, title);&#10;        serviceIntent.putExtra(&quot;message&quot;, message);&#10;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            context.startForegroundService(serviceIntent);&#10;        } else {&#10;            context.startService(serviceIntent);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Static method để start service&#10;     */&#10;    public static void startService(Context context) {&#10;        Intent serviceIntent = new Intent(context, ReminderForegroundService.class);&#10;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            context.startForegroundService(serviceIntent);&#10;        } else {&#10;            context.startService(serviceIntent);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Static method để stop service&#10;     */&#10;    public static void stopService(Context context) {&#10;        Intent serviceIntent = new Intent(context, ReminderForegroundService.class);&#10;        context.stopService(serviceIntent);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.services;&#10;&#10;import android.app.AlarmManager;&#10;import android.app.Notification;&#10;import android.app.NotificationChannel;&#10;import android.app.NotificationManager;&#10;import android.app.PendingIntent;&#10;import android.app.Service;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.os.Build;&#10;import android.os.IBinder;&#10;import android.os.PowerManager;&#10;import android.os.SystemClock;&#10;import android.util.Log;&#10;&#10;import androidx.annotation.Nullable;&#10;import androidx.core.app.NotificationCompat;&#10;&#10;import com.vhn.doan.R;&#10;import com.vhn.doan.presentation.home.HomeActivity;&#10;import com.vhn.doan.receivers.ReminderBroadcastReceiver;&#10;&#10;/**&#10; * Foreground Service để đảm bảo thông báo nhắc nhở hoạt động mạnh mẽ&#10; * Service này sẽ chạy trong background và không bị kill bởi hệ thống&#10; */&#10;public class ReminderForegroundService extends Service {&#10;&#10;    private static final String TAG = &quot;ReminderForegroundService&quot;;&#10;    private static final int FOREGROUND_NOTIFICATION_ID = 9999;&#10;    private static final String CHANNEL_ID = &quot;reminder_foreground_channel&quot;;&#10;    // Thêm thời gian khởi động lại service nếu bị kill&#10;    private static final int RESTART_SERVICE_DELAY_MS = 5000; // 5 giây&#10;&#10;    private PowerManager.WakeLock wakeLock;&#10;    private NotificationManager notificationManager;&#10;    private boolean isServiceStarted = false;&#10;&#10;    @Override&#10;    public void onCreate() {&#10;        super.onCreate();&#10;        Log.d(TAG, &quot;ReminderForegroundService created&quot;);&#10;&#10;        // Tạo notification channel&#10;        createNotificationChannel();&#10;&#10;        try {&#10;            // Acquire wake lock để giữ CPU hoạt động ngay cả khi màn hình tắt&#10;            PowerManager powerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);&#10;            wakeLock = powerManager.newWakeLock(&#10;                PowerManager.PARTIAL_WAKE_LOCK,&#10;                &quot;HealthTips:ReminderForegroundService&quot;&#10;            );&#10;            // Timeout sau 1 giờ nếu không được release thủ công&#10;            wakeLock.acquire(60 * 60 * 1000L);&#10;            Log.d(TAG, &quot;Wake lock acquired&quot;);&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error acquiring wake lock&quot;, e);&#10;        }&#10;&#10;        notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);&#10;    }&#10;&#10;    @Override&#10;    public int onStartCommand(Intent intent, int flags, int startId) {&#10;        Log.d(TAG, &quot;ReminderForegroundService started&quot;);&#10;&#10;        try {&#10;            // Bắt đầu chạy foreground với delay nhỏ để tránh lỗi&#10;            Notification notification = createForegroundNotification();&#10;            startForeground(FOREGROUND_NOTIFICATION_ID, notification);&#10;            isServiceStarted = true;&#10;&#10;            // Xử lý intent nếu có&#10;            if (intent != null) {&#10;                String action = intent.getAction();&#10;                if (action != null) {&#10;                    switch (action) {&#10;                        case &quot;SHOW_REMINDER&quot;:&#10;                            handleShowReminder(intent);&#10;                            break;&#10;                        case &quot;RESTART_SERVICE&quot;:&#10;                            Log.d(TAG, &quot;Service được khởi động lại sau khi bị kill&quot;);&#10;                            break;&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Đặt lịch khởi động lại service nếu bị kill&#10;            scheduleServiceRestart();&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error starting foreground service&quot;, e);&#10;            // Nếu không thể start foreground, fallback về normal notification&#10;            handleFallbackNotification(intent);&#10;            stopSelf();&#10;            return START_NOT_STICKY;&#10;        }&#10;&#10;        // Return STICKY để service tự động restart nếu bị kill&#10;        return START_STICKY;&#10;    }&#10;&#10;    @Override&#10;    public void onDestroy() {&#10;        super.onDestroy();&#10;        Log.d(TAG, &quot;ReminderForegroundService destroyed&quot;);&#10;&#10;        // Release wake lock nếu đang giữ&#10;        if (wakeLock != null &amp;&amp; wakeLock.isHeld()) {&#10;            try {&#10;                wakeLock.release();&#10;                Log.d(TAG, &quot;Wake lock released&quot;);&#10;            } catch (Exception e) {&#10;                Log.e(TAG, &quot;Error releasing wake lock&quot;, e);&#10;            }&#10;        }&#10;&#10;        // Nếu service đang chạy bình thường (không phải do lỗi), thì khởi động lại nó&#10;        if (isServiceStarted) {&#10;            Log.d(TAG, &quot;Service bị destroy không mong muốn, sẽ khởi động lại&quot;);&#10;            Intent restartIntent = new Intent(getApplicationContext(), ReminderForegroundService.class);&#10;            restartIntent.setAction(&quot;RESTART_SERVICE&quot;);&#10;            &#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                startForegroundService(restartIntent);&#10;            } else {&#10;                startService(restartIntent);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Đặt lịch khởi động lại service nếu bị kill&#10;     */&#10;    private void scheduleServiceRestart() {&#10;        // Tạo intent cho AlarmManager để khởi động lại service&#10;        Intent restartServiceIntent = new Intent(getApplicationContext(), ReminderBroadcastReceiver.class);&#10;        restartServiceIntent.setAction(&quot;ACTION_RESTART_REMINDER_SERVICE&quot;);&#10;        &#10;        PendingIntent restartServicePendingIntent = PendingIntent.getBroadcast(&#10;            getApplicationContext(),&#10;            1,&#10;            restartServiceIntent,&#10;            PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_IMMUTABLE&#10;        );&#10;        &#10;        // Đặt AlarmManager để khởi động lại service sau một khoảng thời gian nếu bị kill&#10;        AlarmManager alarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);&#10;        if (alarmManager != null) {&#10;            alarmManager.set(&#10;                AlarmManager.ELAPSED_REALTIME,&#10;                SystemClock.elapsedRealtime() + RESTART_SERVICE_DELAY_MS,&#10;                restartServicePendingIntent&#10;            );&#10;            Log.d(TAG, &quot;Đã đặt lịch khởi động lại service nếu bị kill&quot;);&#10;        }&#10;    }&#10;&#10;    @Nullable&#10;    @Override&#10;    public IBinder onBind(Intent intent) {&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Tạo notification channel cho foreground service&#10;     */&#10;    private void createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            try {&#10;                NotificationChannel channel = new NotificationChannel(&#10;                    CHANNEL_ID,&#10;                    &quot;Dịch vụ nhắc nhở sức khỏe&quot;,&#10;                    NotificationManager.IMPORTANCE_LOW&#10;                );&#10;                channel.setDescription(&quot;Dịch vụ chạy ngầm để đảm bảo nhắc nhở hoạt động&quot;);&#10;                channel.setShowBadge(false);&#10;&#10;                NotificationManager manager = getSystemService(NotificationManager.class);&#10;                if (manager != null) {&#10;                    manager.createNotificationChannel(channel);&#10;                    Log.d(TAG, &quot;Notification channel created: &quot; + CHANNEL_ID);&#10;                }&#10;            } catch (Exception e) {&#10;                Log.e(TAG, &quot;Error creating notification channel&quot;, e);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Tạo notification cho foreground service&#10;     */&#10;    private Notification createForegroundNotification() {&#10;        Intent intent = new Intent(this, HomeActivity.class);&#10;        intent.putExtra(&quot;open_reminders&quot;, true);&#10;&#10;        PendingIntent pendingIntent = PendingIntent.getActivity(&#10;            this,&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#10;        );&#10;&#10;        return new NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(&quot;Dịch vụ nhắc nhở đang hoạt động&quot;)&#10;            .setContentText(&quot;Đảm bảo bạn nhận được thông báo đúng giờ&quot;)&#10;            .setSmallIcon(R.drawable.ic_notification_reminder)&#10;            .setContentIntent(pendingIntent)&#10;            .setOngoing(true)&#10;            .setPriority(NotificationCompat.PRIORITY_LOW)&#10;            .setVisibility(NotificationCompat.VISIBILITY_SECRET)&#10;            .build();&#10;    }&#10;&#10;    /**&#10;     * Xử lý hiển thị reminder&#10;     */&#10;    private void handleShowReminder(Intent intent) {&#10;        try {&#10;            String reminderId = intent.getStringExtra(&quot;reminder_id&quot;);&#10;            String title = intent.getStringExtra(&quot;title&quot;);&#10;            String message = intent.getStringExtra(&quot;message&quot;);&#10;&#10;            Log.d(TAG, &quot;Handling show reminder: &quot; + title);&#10;&#10;            if (title != null &amp;&amp; message != null) {&#10;                // Hiển thị thông báo nhắc nhở&#10;                NotificationService.showReminderNotification(this, title, message, reminderId);&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error handling show reminder&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Static method để start service và hiển thị reminder&#10;     */&#10;    public static void showReminder(Context context, String reminderId, String title, String message) {&#10;        try {&#10;            Intent serviceIntent = new Intent(context, ReminderForegroundService.class);&#10;            serviceIntent.setAction(&quot;SHOW_REMINDER&quot;);&#10;            serviceIntent.putExtra(&quot;reminder_id&quot;, reminderId);&#10;            serviceIntent.putExtra(&quot;title&quot;, title);&#10;            serviceIntent.putExtra(&quot;message&quot;, message);&#10;&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                context.startForegroundService(serviceIntent);&#10;            } else {&#10;                context.startService(serviceIntent);&#10;            }&#10;            Log.d(TAG, &quot;Show reminder request sent to service: &quot; + title);&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error showing reminder through service&quot;, e);&#10;            // Fallback trực tiếp nếu không thể start service&#10;            NotificationService.showReminderNotification(context, title, message, reminderId);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Static method để start service&#10;     */&#10;    public static void startService(Context context) {&#10;        try {&#10;            Intent serviceIntent = new Intent(context, ReminderForegroundService.class);&#10;&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                context.startForegroundService(serviceIntent);&#10;            } else {&#10;                context.startService(serviceIntent);&#10;            }&#10;            Log.d(TAG, &quot;Service start request sent&quot;);&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error starting service&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Static method để stop service&#10;     */&#10;    public static void stopService(Context context) {&#10;        try {&#10;            Intent serviceIntent = new Intent(context, ReminderForegroundService.class);&#10;            context.stopService(serviceIntent);&#10;            Log.d(TAG, &quot;Service stop request sent&quot;);&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error stopping service&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Fallback khi không thể start foreground service&#10;     */&#10;    private void handleFallbackNotification(Intent intent) {&#10;        try {&#10;            if (intent != null &amp;&amp; &quot;SHOW_REMINDER&quot;.equals(intent.getAction())) {&#10;                String reminderId = intent.getStringExtra(&quot;reminder_id&quot;);&#10;                String title = intent.getStringExtra(&quot;title&quot;);&#10;                String message = intent.getStringExtra(&quot;message&quot;);&#10;&#10;                if (title != null &amp;&amp; message != null) {&#10;                    // Hiển thị thông báo trực tiếp mà không cần foreground service&#10;                    NotificationService.showReminderNotification(this, title, message, reminderId);&#10;                    Log.d(TAG, &quot;Showed notification via fallback method&quot;);&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error in fallback notification&quot;, e);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/services/ReminderManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/services/ReminderManager.java" />
              <option name="originalContent" value="package com.vhn.doan.services;&#10;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.os.Build;&#10;import android.util.Log;&#10;&#10;import androidx.annotation.NonNull;&#10;&#10;import com.google.firebase.database.DataSnapshot;&#10;import com.google.firebase.database.DatabaseError;&#10;import com.google.firebase.database.DatabaseReference;&#10;import com.google.firebase.database.FirebaseDatabase;&#10;import com.google.firebase.database.Query;&#10;import com.google.firebase.database.ValueEventListener;&#10;import com.vhn.doan.data.Reminder;&#10;import com.vhn.doan.utils.Constants;&#10;import com.vhn.doan.utils.UserSessionManager;&#10;&#10;import java.util.Calendar;&#10;import java.util.Date;&#10;&#10;import javax.inject.Inject;&#10;import javax.inject.Singleton;&#10;&#10;/**&#10; * Class quản lý các reminder trong ứng dụng&#10; * - Khởi động ReminderForegroundService&#10; * - Khởi động lại reminders đang hoạt động&#10; * - Kiểm tra và hiển thị reminders bị miss&#10; */&#10;@Singleton&#10;public class ReminderManager {&#10;    private static final String TAG = &quot;ReminderManager&quot;;&#10;    private final UserSessionManager userSessionManager;&#10;&#10;    @Inject&#10;    public ReminderManager(UserSessionManager userSessionManager) {&#10;        this.userSessionManager = userSessionManager;&#10;    }&#10;&#10;    /**&#10;     * Khởi động ReminderForegroundService để đảm bảo reminders hoạt động&#10;     */&#10;    public void startReminderService(Context context) {&#10;        try {&#10;            Intent serviceIntent = new Intent(context, ReminderForegroundService.class);&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                context.startForegroundService(serviceIntent);&#10;            } else {&#10;                context.startService(serviceIntent);&#10;            }&#10;            Log.d(TAG, &quot;ReminderForegroundService đã được khởi động&quot;);&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Lỗi khi khởi động ReminderForegroundService: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Khởi động lại tất cả các reminder đang hoạt động&#10;     * Được gọi khi app mở hoặc resume để đảm bảo reminders luôn được kích hoạt&#10;     */&#10;    public void restartAllReminders(Context context) {&#10;        String userId = userSessionManager.getUserId();&#10;        if (userId == null || userId.isEmpty()) {&#10;            Log.e(TAG, &quot;Không thể khởi động lại reminders: User không đăng nhập&quot;);&#10;            return;&#10;        }&#10;&#10;        DatabaseReference remindersRef = FirebaseDatabase.getInstance()&#10;                .getReference(Constants.REMINDERS_NODE)&#10;                .child(userId);&#10;&#10;        remindersRef.orderByChild(&quot;isActive&quot;).equalTo(true)&#10;                .addListenerForSingleValueEvent(new ValueEventListener() {&#10;                    @Override&#10;                    public void onDataChange(@NonNull DataSnapshot dataSnapshot) {&#10;                        for (DataSnapshot reminderSnapshot : dataSnapshot.getChildren()) {&#10;                            Reminder reminder = reminderSnapshot.getValue(Reminder.class);&#10;                            if (reminder != null &amp;&amp; reminder.isActive()) {&#10;                                // Đặt lại reminder trong ReminderService&#10;                                Intent intent = new Intent(context, ReminderService.class);&#10;                                intent.setAction(Constants.ACTION_SET_REMINDER);&#10;                                intent.putExtra(Constants.EXTRA_REMINDER, reminder);&#10;                                context.startService(intent);&#10;&#10;                                Log.d(TAG, &quot;Khởi động lại reminder: &quot; + reminder.getTitle());&#10;                            }&#10;                        }&#10;                        Log.d(TAG, &quot;Đã khởi động lại tất cả reminders đang hoạt động&quot;);&#10;                    }&#10;&#10;                    @Override&#10;                    public void onCancelled(@NonNull DatabaseError databaseError) {&#10;                        Log.e(TAG, &quot;Lỗi khi khởi động lại reminders: &quot; + databaseError.getMessage());&#10;                    }&#10;                });&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra và hiển thị các reminders đã bị miss&#10;     * Được gọi khi app mở để thông báo cho người dùng về các reminders đã bỏ lỡ&#10;     */&#10;    public void checkAndShowMissedReminders(Context context) {&#10;        String userId = userSessionManager.getUserId();&#10;        if (userId == null || userId.isEmpty()) {&#10;            Log.e(TAG, &quot;Không thể kiểm tra reminders bị miss: User không đăng nhập&quot;);&#10;            return;&#10;        }&#10;&#10;        // Lấy thời gian hiện tại để so sánh với thời gian của reminder&#10;        final long currentTime = Calendar.getInstance().getTimeInMillis();&#10;        // Lấy thời gian từ 24 giờ trước để chỉ kiểm tra reminders gần đây&#10;        final long oneDayAgo = currentTime - (24 * 60 * 60 * 1000);&#10;&#10;        Query missedRemindersQuery = FirebaseDatabase.getInstance()&#10;                .getReference(Constants.REMINDERS_NODE)&#10;                .child(userId)&#10;                .orderByChild(&quot;nextTriggerTime&quot;)&#10;                .startAt(oneDayAgo)&#10;                .endAt(currentTime);&#10;&#10;        missedRemindersQuery.addListenerForSingleValueEvent(new ValueEventListener() {&#10;            @Override&#10;            public void onDataChange(@NonNull DataSnapshot dataSnapshot) {&#10;                for (DataSnapshot reminderSnapshot : dataSnapshot.getChildren()) {&#10;                    Reminder reminder = reminderSnapshot.getValue(Reminder.class);&#10;                    if (reminder != null &amp;&amp; reminder.isActive() &amp;&amp;&#10;                            reminder.getNextTriggerTime() &lt; currentTime &amp;&amp;&#10;                            reminder.getNextTriggerTime() &gt; oneDayAgo) {&#10;&#10;                        // Hiển thị thông báo cho reminder bị miss&#10;                        Intent intent = new Intent(context, ReminderService.class);&#10;                        intent.setAction(Constants.ACTION_SHOW_MISSED_REMINDER);&#10;                        intent.putExtra(Constants.EXTRA_REMINDER, reminder);&#10;                        context.startService(intent);&#10;&#10;                        Log.d(TAG, &quot;Phát hiện reminder bị miss: &quot; + reminder.getTitle());&#10;                    }&#10;                }&#10;                Log.d(TAG, &quot;Đã kiểm tra xong các reminders bị miss&quot;);&#10;            }&#10;&#10;            @Override&#10;            public void onCancelled(@NonNull DatabaseError databaseError) {&#10;                Log.e(TAG, &quot;Lỗi khi kiểm tra reminders bị miss: &quot; + databaseError.getMessage());&#10;            }&#10;        });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.services;&#10;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.os.Build;&#10;import android.util.Log;&#10;&#10;import androidx.annotation.NonNull;&#10;&#10;import com.google.firebase.database.DataSnapshot;&#10;import com.google.firebase.database.DatabaseError;&#10;import com.google.firebase.database.DatabaseReference;&#10;import com.google.firebase.database.FirebaseDatabase;&#10;import com.google.firebase.database.Query;&#10;import com.google.firebase.database.ValueEventListener;&#10;import com.vhn.doan.data.Reminder;&#10;import com.vhn.doan.utils.Constants;&#10;import com.vhn.doan.utils.UserSessionManager;&#10;&#10;import java.util.Calendar;&#10;&#10;import javax.inject.Inject;&#10;import javax.inject.Singleton;&#10;&#10;/**&#10; * Class quản lý các reminder trong ứng dụng&#10; * - Khởi động ReminderForegroundService&#10; * - Khởi động lại reminders đang hoạt động&#10; * - Kiểm tra và hiển thị reminders bị miss&#10; */&#10;@Singleton&#10;public class ReminderManager {&#10;    private static final String TAG = &quot;ReminderManager&quot;;&#10;    private final UserSessionManager userSessionManager;&#10;&#10;    @Inject&#10;    public ReminderManager(UserSessionManager userSessionManager) {&#10;        this.userSessionManager = userSessionManager;&#10;    }&#10;&#10;    /**&#10;     * Khởi động ReminderForegroundService để đảm bảo reminders hoạt động&#10;     */&#10;    public void startReminderService(Context context) {&#10;        try {&#10;            Intent serviceIntent = new Intent(context, ReminderForegroundService.class);&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                context.startForegroundService(serviceIntent);&#10;            } else {&#10;                context.startService(serviceIntent);&#10;            }&#10;            Log.d(TAG, &quot;ReminderForegroundService đã được khởi động&quot;);&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Lỗi khi khởi động ReminderForegroundService: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Khởi động lại tất cả các reminder đang hoạt động&#10;     * Được gọi khi app mở hoặc resume để đảm bảo reminders luôn được kích hoạt&#10;     */&#10;    public void restartAllReminders(Context context) {&#10;        String userId = userSessionManager.getCurrentUserId();&#10;        if (userId == null || userId.isEmpty()) {&#10;            Log.e(TAG, &quot;Không thể khởi động lại reminders: User không đăng nhập&quot;);&#10;            return;&#10;        }&#10;&#10;        DatabaseReference remindersRef = FirebaseDatabase.getInstance()&#10;                .getReference(Constants.REMINDERS_NODE)&#10;                .child(userId);&#10;&#10;        remindersRef.orderByChild(&quot;isActive&quot;).equalTo(true)&#10;                .addListenerForSingleValueEvent(new ValueEventListener() {&#10;                    @Override&#10;                    public void onDataChange(@NonNull DataSnapshot dataSnapshot) {&#10;                        for (DataSnapshot reminderSnapshot : dataSnapshot.getChildren()) {&#10;                            Reminder reminder = reminderSnapshot.getValue(Reminder.class);&#10;                            if (reminder != null &amp;&amp; reminder.isActive()) {&#10;                                // Đặt lại reminder trong ReminderService&#10;                                Intent intent = new Intent(context, ReminderService.class);&#10;                                intent.setAction(Constants.ACTION_SET_REMINDER);&#10;                                intent.putExtra(Constants.EXTRA_REMINDER, reminder);&#10;                                context.startService(intent);&#10;&#10;                                Log.d(TAG, &quot;Khởi động lại reminder: &quot; + reminder.getTitle());&#10;                            }&#10;                        }&#10;                        Log.d(TAG, &quot;Đã khởi động lại tất cả reminders đang hoạt động&quot;);&#10;                    }&#10;&#10;                    @Override&#10;                    public void onCancelled(@NonNull DatabaseError databaseError) {&#10;                        Log.e(TAG, &quot;Lỗi khi khởi động lại reminders: &quot; + databaseError.getMessage());&#10;                    }&#10;                });&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra và hiển thị các reminders đã bị miss&#10;     * Được gọi khi app mở để thông báo cho người dùng về các reminders đã bỏ lỡ&#10;     */&#10;    public void checkAndShowMissedReminders(Context context) {&#10;        String userId = userSessionManager.getCurrentUserId();&#10;        if (userId == null || userId.isEmpty()) {&#10;            Log.e(TAG, &quot;Không thể kiểm tra reminders bị miss: User không đăng nhập&quot;);&#10;            return;&#10;        }&#10;&#10;        // Lấy thời gian hiện tại để so sánh với thời gian của reminder&#10;        final long currentTime = Calendar.getInstance().getTimeInMillis();&#10;        // Lấy thời gian từ 24 giờ trước để chỉ kiểm tra reminders gần đây&#10;        final long oneDayAgo = currentTime - (24 * 60 * 60 * 1000);&#10;&#10;        Query missedRemindersQuery = FirebaseDatabase.getInstance()&#10;                .getReference(Constants.REMINDERS_NODE)&#10;                .child(userId)&#10;                .orderByChild(&quot;reminderTime&quot;)&#10;                .startAt(oneDayAgo)&#10;                .endAt(currentTime);&#10;&#10;        missedRemindersQuery.addListenerForSingleValueEvent(new ValueEventListener() {&#10;            @Override&#10;            public void onDataChange(@NonNull DataSnapshot dataSnapshot) {&#10;                for (DataSnapshot reminderSnapshot : dataSnapshot.getChildren()) {&#10;                    Reminder reminder = reminderSnapshot.getValue(Reminder.class);&#10;                    if (reminder != null &amp;&amp; reminder.isActive() &amp;&amp;&#10;                            reminder.getReminderTime() &lt; currentTime &amp;&amp;&#10;                            reminder.getReminderTime() &gt; oneDayAgo) {&#10;&#10;                        // Hiển thị thông báo cho reminder bị miss&#10;                        Intent intent = new Intent(context, ReminderService.class);&#10;                        intent.setAction(Constants.ACTION_SHOW_MISSED_REMINDER);&#10;                        intent.putExtra(Constants.EXTRA_REMINDER, reminder);&#10;                        context.startService(intent);&#10;&#10;                        Log.d(TAG, &quot;Phát hiện reminder bị miss: &quot; + reminder.getTitle());&#10;                    }&#10;                }&#10;                Log.d(TAG, &quot;Đã kiểm tra xong các reminders bị miss&quot;);&#10;            }&#10;&#10;            @Override&#10;            public void onCancelled(@NonNull DatabaseError databaseError) {&#10;                Log.e(TAG, &quot;Lỗi khi kiểm tra reminders bị miss: &quot; + databaseError.getMessage());&#10;            }&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/services/ReminderService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/services/ReminderService.java" />
              <option name="originalContent" value="package com.vhn.doan.services;&#10;&#10;import android.app.AlarmManager;&#10;import android.app.PendingIntent;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.os.Build;&#10;import android.os.PowerManager;&#10;import android.util.Log;&#10;&#10;import androidx.work.Data;&#10;import androidx.work.OneTimeWorkRequest;&#10;import androidx.work.WorkManager;&#10;&#10;import com.vhn.doan.data.Reminder;&#10;import com.vhn.doan.receivers.ReminderBroadcastReceiver;&#10;import com.vhn.doan.workers.ReminderWorker;&#10;&#10;import java.util.Calendar;&#10;import java.util.Date;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;/**&#10; * Service để quản lý và lên lịch thông báo nhắc nhở&#10; * Sử dụng cả AlarmManager và WorkManager để đảm bảo hoạt động trong mọi tình huống&#10; */&#10;public class ReminderService {&#10;&#10;    private static final String TAG = &quot;ReminderService&quot;;&#10;    public static final String ACTION_REMINDER_TRIGGER = &quot;com.vhn.doan.REMINDER_TRIGGER&quot;;&#10;&#10;    private Context context;&#10;    private AlarmManager alarmManager;&#10;    private PowerManager.WakeLock wakeLock;&#10;&#10;    public ReminderService(Context context) {&#10;        this.context = context;&#10;        this.alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);&#10;&#10;        // Tạo wake lock để đảm bảo thiết bị không sleep khi xử lý alarm&#10;        PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);&#10;        wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, &quot;HealthTips:ReminderWakeLock&quot;);&#10;    }&#10;&#10;    /**&#10;     * Lên lịch thông báo nhắc nhở với cả AlarmManager và WorkManager&#10;     */&#10;    public void scheduleReminder(Reminder reminder) {&#10;        Log.d(TAG, &quot;=== BẮT ĐẦU SCHEDULE REMINDER ===&quot;);&#10;        Log.d(TAG, &quot;Reminder ID: &quot; + reminder.getId());&#10;        Log.d(TAG, &quot;Title: &quot; + reminder.getTitle());&#10;        Log.d(TAG, &quot;Description: &quot; + reminder.getDescription());&#10;        Log.d(TAG, &quot;Is Active: &quot; + reminder.isActive());&#10;        Log.d(TAG, &quot;Repeat Type: &quot; + reminder.getRepeatType());&#10;&#10;        if (reminder == null || reminder.getReminderTime() == null || !reminder.isActive()) {&#10;            Log.w(TAG, &quot;Reminder không hợp lệ - bỏ qua scheduling&quot;);&#10;            return;&#10;        }&#10;&#10;        long reminderTimeMillis = reminder.getReminderTime(); // getReminderTime() đã trả về Long&#10;        long currentTime = System.currentTimeMillis();&#10;&#10;        Log.d(TAG, &quot;Current time: &quot; + new Date(currentTime));&#10;        Log.d(TAG, &quot;Reminder time: &quot; + new Date(reminderTimeMillis));&#10;&#10;        if (reminderTimeMillis &lt;= currentTime) {&#10;            Log.w(TAG, &quot;Thời gian nhắc nhở đã qua - bỏ qua scheduling&quot;);&#10;            return;&#10;        }&#10;&#10;        // Schedule với cả hai phương pháp để đảm bảo độ tin cậy&#10;        scheduleWithAlarmManager(reminder, reminderTimeMillis);&#10;        scheduleWithWorkManager(reminder, reminderTimeMillis - currentTime);&#10;&#10;        Log.d(TAG, &quot;=== KẾT THÚC SCHEDULE REMINDER ===&quot;);&#10;    }&#10;&#10;    /**&#10;     * Schedule với AlarmManager (cho instant delivery)&#10;     */&#10;    private void scheduleWithAlarmManager(Reminder reminder, long reminderTimeMillis) {&#10;        try {&#10;            Intent intent = new Intent(context, ReminderBroadcastReceiver.class);&#10;            intent.setAction(ACTION_REMINDER_TRIGGER);&#10;            intent.putExtra(&quot;reminder_id&quot;, reminder.getId());&#10;            intent.putExtra(&quot;title&quot;, reminder.getTitle());&#10;            intent.putExtra(&quot;message&quot;, reminder.getDescription());&#10;&#10;            PendingIntent pendingIntent = PendingIntent.getBroadcast(&#10;                context,&#10;                reminder.getId().hashCode(),&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#10;            );&#10;&#10;            // Sử dụng setExactAndAllowWhileIdle để hoạt động trong Doze mode&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;    }&#10;&#10;    /**&#10;     * Schedule với WorkManager (backup cho reliability)&#10;     */&#10;    private void scheduleWithWorkManager(Reminder reminder, long delayMillis) {&#10;        try {&#10;            Data inputData = new Data.Builder()&#10;                .putString(ReminderWorker.KEY_REMINDER_ID, reminder.getId())&#10;                .putString(ReminderWorker.KEY_TITLE, reminder.getTitle())&#10;                .putString(ReminderWorker.KEY_MESSAGE, reminder.getDescription())&#10;                .build();&#10;&#10;            OneTimeWorkRequest workRequest = new OneTimeWorkRequest.Builder(ReminderWorker.class)&#10;                .setInitialDelay(delayMillis, TimeUnit.MILLISECONDS)&#10;                .setInputData(inputData)&#10;                .addTag(&quot;reminder_&quot; + reminder.getId())&#10;                .build();&#10;&#10;            WorkManager.getInstance(context).enqueue(workRequest);&#10;            Log.d(TAG, &quot;WorkManager: Đã schedule work request với delay &quot; + delayMillis + &quot;ms&quot;);&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Lỗi khi schedule WorkManager&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Hủy thông báo nhắc nhở&#10;     */&#10;    public static void cancelReminder(Context context, String reminderId) {&#10;        Log.d(TAG, &quot;Hủy reminder: &quot; + reminderId);&#10;&#10;        try {&#10;            // Hủy AlarmManager&#10;            AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);&#10;            Intent intent = new Intent(context, ReminderBroadcastReceiver.class);&#10;            intent.setAction(ACTION_REMINDER_TRIGGER);&#10;&#10;            PendingIntent pendingIntent = PendingIntent.getBroadcast(&#10;                context,&#10;                reminderId.hashCode(),&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#10;            );&#10;&#10;            alarmManager.cancel(pendingIntent);&#10;            Log.d(TAG, &quot;Đã hủy AlarmManager cho reminder: &quot; + reminderId);&#10;&#10;            // Hủy WorkManager&#10;            WorkManager.getInstance(context).cancelAllWorkByTag(&quot;reminder_&quot; + reminderId);&#10;            Log.d(TAG, &quot;Đã hủy WorkManager cho reminder: &quot; + reminderId);&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Lỗi khi hủy reminder&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Test thông báo ngay lập tức&#10;     */&#10;    public void testNotification(Reminder reminder) {&#10;        Log.d(TAG, &quot;Test thông báo cho reminder: &quot; + reminder.getTitle());&#10;&#10;        // Hiển thị thông báo ngay&#10;        NotificationService.showReminderNotification(&#10;            context,&#10;            reminder.getTitle(),&#10;            reminder.getDescription(),&#10;            reminder.getId()&#10;        );&#10;&#10;        // Schedule một thông báo test sau 5 giây&#10;        scheduleTestNotification(reminder, 5000);&#10;    }&#10;&#10;    /**&#10;     * Schedule test notification sau một khoảng thời gian ngắn&#10;     */&#10;    private void scheduleTestNotification(Reminder reminder, long delayMillis) {&#10;        try {&#10;            long triggerTime = System.currentTimeMillis() + delayMillis;&#10;&#10;            // Test với AlarmManager&#10;            Intent intent = new Intent(context, ReminderBroadcastReceiver.class);&#10;            intent.setAction(ACTION_REMINDER_TRIGGER);&#10;            intent.putExtra(&quot;reminder_id&quot;, reminder.getId());&#10;            intent.putExtra(&quot;title&quot;, &quot;[TEST] &quot; + reminder.getTitle());&#10;            intent.putExtra(&quot;message&quot;, &quot;[TEST] &quot; + reminder.getDescription());&#10;&#10;            PendingIntent pendingIntent = PendingIntent.getBroadcast(&#10;                context,&#10;                (&quot;test_&quot; + reminder.getId()).hashCode(),&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#10;            );&#10;&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                alarmManager.setExactAndAllowWhileIdle(&#10;                    AlarmManager.RTC_WAKEUP,&#10;                    triggerTime,&#10;                    pendingIntent&#10;                );&#10;            } else {&#10;                alarmManager.setExact(&#10;                    AlarmManager.RTC_WAKEUP,&#10;                    triggerTime,&#10;                    pendingIntent&#10;                );&#10;            }&#10;&#10;            Log.d(TAG, &quot;Đã schedule test notification sau &quot; + delayMillis + &quot;ms&quot;);&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Lỗi khi schedule test notification&quot;, e);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.services;&#10;&#10;import android.app.AlarmManager;&#10;import android.app.PendingIntent;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.os.Build;&#10;import android.os.PowerManager;&#10;import android.util.Log;&#10;&#10;import androidx.work.Data;&#10;import androidx.work.OneTimeWorkRequest;&#10;import androidx.work.WorkManager;&#10;&#10;import com.vhn.doan.data.Reminder;&#10;import com.vhn.doan.receivers.ReminderBroadcastReceiver;&#10;import com.vhn.doan.workers.ReminderWorker;&#10;&#10;import java.util.Calendar;&#10;import java.util.Date;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;/**&#10; * Service để quản lý và lên lịch thông báo nhắc nhở&#10; * Sử dụng cả AlarmManager và WorkManager để đảm bảo hoạt động trong mọi tình huống&#10; */&#10;public class ReminderService {&#10;&#10;    private static final String TAG = &quot;ReminderService&quot;;&#10;    public static final String ACTION_REMINDER_TRIGGER = &quot;com.vhn.doan.REMINDER_TRIGGER&quot;;&#10;&#10;    private Context context;&#10;    private AlarmManager alarmManager;&#10;    private PowerManager.WakeLock wakeLock;&#10;&#10;    public ReminderService(Context context) {&#10;        this.context = context;&#10;        this.alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);&#10;&#10;        // Tạo wake lock để đảm bảo thiết bị không sleep khi xử lý alarm&#10;        PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);&#10;        wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, &quot;HealthTips:ReminderWakeLock&quot;);&#10;    }&#10;&#10;    /**&#10;     * Lên lịch thông báo nhắc nhở với cả AlarmManager và WorkManager&#10;     */&#10;    public void scheduleReminder(Reminder reminder) {&#10;        Log.d(TAG, &quot;=== BẮT ĐẦU SCHEDULE REMINDER ===&quot;);&#10;        Log.d(TAG, &quot;Reminder ID: &quot; + reminder.getId());&#10;        Log.d(TAG, &quot;Title: &quot; + reminder.getTitle());&#10;        Log.d(TAG, &quot;Description: &quot; + reminder.getDescription());&#10;        Log.d(TAG, &quot;Is Active: &quot; + reminder.isActive());&#10;        Log.d(TAG, &quot;Repeat Type: &quot; + reminder.getRepeatType());&#10;&#10;        if (reminder == null || reminder.getReminderTime() == null || !reminder.isActive()) {&#10;            Log.w(TAG, &quot;Reminder không hợp lệ - bỏ qua scheduling&quot;);&#10;            return;&#10;        }&#10;&#10;        long reminderTimeMillis = reminder.getReminderTime(); // getReminderTime() đã trả về Long&#10;        long currentTime = System.currentTimeMillis();&#10;&#10;        Log.d(TAG, &quot;Current time: &quot; + new Date(currentTime));&#10;        Log.d(TAG, &quot;Reminder time: &quot; + new Date(reminderTimeMillis));&#10;&#10;        if (reminderTimeMillis &lt;= currentTime) {&#10;            Log.w(TAG, &quot;Thời gian nhắc nhở đã qua - bỏ qua scheduling&quot;);&#10;            return;&#10;        }&#10;&#10;        // Schedule với cả hai phương pháp để đảm bảo độ tin cậy&#10;        scheduleWithAlarmManager(reminder, reminderTimeMillis);&#10;        scheduleWithWorkManager(reminder, reminderTimeMillis - currentTime);&#10;&#10;        Log.d(TAG, &quot;=== KẾT THÚC SCHEDULE REMINDER ===&quot;);&#10;    }&#10;&#10;    /**&#10;     * Schedule với AlarmManager (cho instant delivery)&#10;     */&#10;    private void scheduleWithAlarmManager(Reminder reminder, long reminderTimeMillis) {&#10;        try {&#10;            Intent intent = new Intent(context, ReminderBroadcastReceiver.class);&#10;            intent.setAction(ACTION_REMINDER_TRIGGER);&#10;            intent.putExtra(&quot;reminder_id&quot;, reminder.getId());&#10;            intent.putExtra(&quot;title&quot;, reminder.getTitle());&#10;            intent.putExtra(&quot;message&quot;, reminder.getDescription());&#10;&#10;            PendingIntent pendingIntent = PendingIntent.getBroadcast(&#10;                context,&#10;                reminder.getId().hashCode(),&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#10;            );&#10;&#10;            // Sử dụng setAlarmClock để có độ ưu tiên cao nhất (bỏ qua Doze mode hoàn toàn)&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {&#10;                // Tạo intent để mở app khi click notification từ alarm clock&#10;                Intent showIntent = new Intent(context, com.vhn.doan.presentation.home.HomeActivity.class);&#10;                showIntent.putExtra(&quot;open_reminders&quot;, true);&#10;                PendingIntent showPendingIntent = PendingIntent.getActivity(&#10;                    context, &#10;                    reminder.getId().hashCode() + 1000, &#10;                    showIntent, &#10;                    PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#10;                );&#10;&#10;                AlarmManager.AlarmClockInfo alarmClockInfo = new AlarmManager.AlarmClockInfo(&#10;                    reminderTimeMillis, &#10;                    showPendingIntent&#10;                );&#10;                &#10;                alarmManager.setAlarmClock(alarmClockInfo, pendingIntent);&#10;                Log.d(TAG, &quot;AlarmManager: Đã schedule với setAlarmClock (cao nhất priority)&quot;);&#10;            } else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                alarmManager.setExactAndAllowWhileIdle(&#10;                    AlarmManager.RTC_WAKEUP,&#10;                    reminderTimeMillis,&#10;                    pendingIntent&#10;                );&#10;                Log.d(TAG, &quot;AlarmManager: Đã schedule với setExactAndAllowWhileIdle&quot;);&#10;            } else {&#10;                alarmManager.setExact(&#10;                    AlarmManager.RTC_WAKEUP,&#10;                    reminderTimeMillis,&#10;                    pendingIntent&#10;                );&#10;                Log.d(TAG, &quot;AlarmManager: Đã schedule với setExact&quot;);&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Lỗi khi schedule AlarmManager&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Schedule với WorkManager (backup cho reliability)&#10;     */&#10;    private void scheduleWithWorkManager(Reminder reminder, long delayMillis) {&#10;        try {&#10;            Data inputData = new Data.Builder()&#10;                .putString(ReminderWorker.KEY_REMINDER_ID, reminder.getId())&#10;                .putString(ReminderWorker.KEY_TITLE, reminder.getTitle())&#10;                .putString(ReminderWorker.KEY_MESSAGE, reminder.getDescription())&#10;                .build();&#10;&#10;            OneTimeWorkRequest workRequest = new OneTimeWorkRequest.Builder(ReminderWorker.class)&#10;                .setInitialDelay(delayMillis, TimeUnit.MILLISECONDS)&#10;                .setInputData(inputData)&#10;                .addTag(&quot;reminder_&quot; + reminder.getId())&#10;                .build();&#10;&#10;            WorkManager.getInstance(context).enqueue(workRequest);&#10;            Log.d(TAG, &quot;WorkManager: Đã schedule work request với delay &quot; + delayMillis + &quot;ms&quot;);&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Lỗi khi schedule WorkManager&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Hủy thông báo nhắc nhở&#10;     */&#10;    public static void cancelReminder(Context context, String reminderId) {&#10;        Log.d(TAG, &quot;Hủy reminder: &quot; + reminderId);&#10;&#10;        try {&#10;            // Hủy AlarmManager&#10;            AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);&#10;            Intent intent = new Intent(context, ReminderBroadcastReceiver.class);&#10;            intent.setAction(ACTION_REMINDER_TRIGGER);&#10;&#10;            PendingIntent pendingIntent = PendingIntent.getBroadcast(&#10;                context,&#10;                reminderId.hashCode(),&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#10;            );&#10;&#10;            alarmManager.cancel(pendingIntent);&#10;            Log.d(TAG, &quot;Đã hủy AlarmManager cho reminder: &quot; + reminderId);&#10;&#10;            // Hủy WorkManager&#10;            WorkManager.getInstance(context).cancelAllWorkByTag(&quot;reminder_&quot; + reminderId);&#10;            Log.d(TAG, &quot;Đã hủy WorkManager cho reminder: &quot; + reminderId);&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Lỗi khi hủy reminder&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Test thông báo ngay lập tức&#10;     */&#10;    public void testNotification(Reminder reminder) {&#10;        Log.d(TAG, &quot;Test thông báo cho reminder: &quot; + reminder.getTitle());&#10;&#10;        // Hiển thị thông báo ngay&#10;        NotificationService.showReminderNotification(&#10;            context,&#10;            reminder.getTitle(),&#10;            reminder.getDescription(),&#10;            reminder.getId()&#10;        );&#10;&#10;        // Schedule một thông báo test sau 5 giây&#10;        scheduleTestNotification(reminder, 5000);&#10;    }&#10;&#10;    /**&#10;     * Schedule test notification sau một khoảng thời gian ngắn&#10;     */&#10;    private void scheduleTestNotification(Reminder reminder, long delayMillis) {&#10;        try {&#10;            long triggerTime = System.currentTimeMillis() + delayMillis;&#10;&#10;            // Test với AlarmManager&#10;            Intent intent = new Intent(context, ReminderBroadcastReceiver.class);&#10;            intent.setAction(ACTION_REMINDER_TRIGGER);&#10;            intent.putExtra(&quot;reminder_id&quot;, reminder.getId());&#10;            intent.putExtra(&quot;title&quot;, &quot;[TEST] &quot; + reminder.getTitle());&#10;            intent.putExtra(&quot;message&quot;, &quot;[TEST] &quot; + reminder.getDescription());&#10;&#10;            PendingIntent pendingIntent = PendingIntent.getBroadcast(&#10;                context,&#10;                (&quot;test_&quot; + reminder.getId()).hashCode(),&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#10;            );&#10;&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                alarmManager.setExactAndAllowWhileIdle(&#10;                    AlarmManager.RTC_WAKEUP,&#10;                    triggerTime,&#10;                    pendingIntent&#10;                );&#10;            } else {&#10;                alarmManager.setExact(&#10;                    AlarmManager.RTC_WAKEUP,&#10;                    triggerTime,&#10;                    pendingIntent&#10;                );&#10;            }&#10;&#10;            Log.d(TAG, &quot;Đã schedule test notification sau &quot; + delayMillis + &quot;ms&quot;);&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Lỗi khi schedule test notification&quot;, e);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/utils/Constants.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/utils/Constants.java" />
              <option name="originalContent" value="package com.vhn.doan.utils;&#10;&#10;/**&#10; * Class lưu trữ các hằng số dùng chung trong ứng dụng&#10; */&#10;public class Constants {&#10;&#10;    // Các key cho Firebase Authentication&#10;    public static final String FIREBASE_AUTH_KEY = &quot;AIzaSyA9TsK_lVXViYuZ_LjHj4MvM1LAPJxNJqQ&quot;; // Key mẫu, cần thay bằng key thật&#10;&#10;    // Đường dẫn tham chiếu Firebase Realtime Database&#10;    public static final String USERS_REF = &quot;users&quot;;&#10;    public static final String CATEGORIES_REF = &quot;categories&quot;;&#10;    public static final String HEALTH_TIPS_REF = &quot;health_tips&quot;;&#10;    public static final String FAVORITES_REF = &quot;favorites&quot;; // Thêm path cho favorites theo cấu trúc test data&#10;    public static final String USER_FAVORITES_REF = &quot;user_favorites&quot;;&#10;    public static final String USER_HISTORY_REF = &quot;user_history&quot;;&#10;&#10;    // Đường dẫn cho Firebase Firestore và Storage&#10;    public static final String USERS_PATH = &quot;users&quot;;&#10;    public static final String PROFILE_IMAGES_PATH = &quot;profile_images&quot;;&#10;    public static final String USERS_COLLECTION = &quot;users&quot;;&#10;&#10;    // Các key cho SharedPreferences&#10;    public static final String PREF_NAME = &quot;HealthTipsPrefs&quot;;&#10;    public static final String PREF_USER_ID = &quot;user_id&quot;;&#10;    public static final String PREF_USER_EMAIL = &quot;user_email&quot;;&#10;    public static final String PREF_IS_LOGGED_IN = &quot;is_logged_in&quot;;&#10;    public static final String PREF_THEME_MODE = &quot;theme_mode&quot;;&#10;&#10;    // Các key cho Intent&#10;    public static final String INTENT_CATEGORY_ID = &quot;category_id&quot;;&#10;    public static final String INTENT_HEALTH_TIP_ID = &quot;health_tip_id&quot;;&#10;    public static final String INTENT_SEARCH_QUERY = &quot;search_query&quot;;&#10;    public static final String CATEGORY_ID_KEY = &quot;category_id&quot;; // Key cho Bundle trong Fragment&#10;&#10;    // Số lượng hiển thị mặc định&#10;    public static final int DEFAULT_LIMIT = 10;&#10;&#10;    // Các tham số giao diện&#10;    public static final boolean DARK_MODE_DEFAULT = true;&#10;&#10;    // Các thông báo&#10;    public static final String ERROR_NETWORK = &quot;Không có kết nối internet&quot;;&#10;    public static final String ERROR_LOGIN_FAILED = &quot;Đăng nhập thất bại&quot;;&#10;    public static final String ERROR_REGISTRATION_FAILED = &quot;Đăng ký thất bại&quot;;&#10;    public static final String SUCCESS_LOGIN = &quot;Đăng nhập thành công&quot;;&#10;    public static final String SUCCESS_REGISTRATION = &quot;Đăng ký thành công&quot;;&#10;    public static final String SUCCESS_PASSWORD_RESET = &quot;Đã gửi email đặt lại mật khẩu&quot;;&#10;&#10;    // Các màu sắc gradient cho nút (được định nghĩa trong XML)&#10;    public static final String PRIMARY_BUTTON_GRADIENT = &quot;primary_button_gradient&quot;;&#10;    public static final String SECONDARY_BUTTON_GRADIENT = &quot;secondary_button_gradient&quot;;&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.utils;&#13;&#10;&#13;&#10;/**&#13;&#10; * Class lưu trữ các hằng số dùng chung trong ứng dụng&#13;&#10; */&#13;&#10;public class Constants {&#13;&#10;&#13;&#10;    // Các key cho Firebase Authentication&#13;&#10;    public static final String FIREBASE_AUTH_KEY = &quot;AIzaSyA9TsK_lVXViYuZ_LjHj4MvM1LAPJxNJqQ&quot;; // Key mẫu, cần thay bằng key thật&#13;&#10;&#13;&#10;    // Đường dẫn tham chiếu Firebase Realtime Database&#13;&#10;    public static final String USERS_REF = &quot;users&quot;;&#13;&#10;    public static final String CATEGORIES_REF = &quot;categories&quot;;&#13;&#10;    public static final String HEALTH_TIPS_REF = &quot;health_tips&quot;;&#13;&#10;    public static final String FAVORITES_REF = &quot;favorites&quot;; // Thêm path cho favorites theo cấu trúc test data&#13;&#10;    public static final String USER_FAVORITES_REF = &quot;user_favorites&quot;;&#13;&#10;    public static final String USER_HISTORY_REF = &quot;user_history&quot;;&#13;&#10;    public static final String REMINDERS_NODE = &quot;reminders&quot;; // Node lưu trữ các reminder&#13;&#10;&#13;&#10;    // Đường dẫn cho Firebase Firestore và Storage&#13;&#10;    public static final String USERS_PATH = &quot;users&quot;;&#13;&#10;    public static final String PROFILE_IMAGES_PATH = &quot;profile_images&quot;;&#13;&#10;    public static final String USERS_COLLECTION = &quot;users&quot;;&#13;&#10;&#13;&#10;    // Các key cho SharedPreferences&#13;&#10;    public static final String PREF_NAME = &quot;HealthTipsPrefs&quot;;&#13;&#10;    public static final String PREF_USER_ID = &quot;user_id&quot;;&#13;&#10;    public static final String PREF_USER_EMAIL = &quot;user_email&quot;;&#13;&#10;    public static final String PREF_IS_LOGGED_IN = &quot;is_logged_in&quot;;&#13;&#10;    public static final String PREF_THEME_MODE = &quot;theme_mode&quot;;&#13;&#10;&#13;&#10;    // Các key cho Intent&#13;&#10;    public static final String INTENT_CATEGORY_ID = &quot;category_id&quot;;&#13;&#10;    public static final String INTENT_HEALTH_TIP_ID = &quot;health_tip_id&quot;;&#13;&#10;    public static final String INTENT_SEARCH_QUERY = &quot;search_query&quot;;&#13;&#10;    public static final String CATEGORY_ID_KEY = &quot;category_id&quot;; // Key cho Bundle trong Fragment&#13;&#10;&#13;&#10;    // Số lượng hiển thị mặc định&#13;&#10;    public static final int DEFAULT_LIMIT = 10;&#13;&#10;&#13;&#10;    // Các tham số giao diện&#13;&#10;    public static final boolean DARK_MODE_DEFAULT = true;&#13;&#10;&#13;&#10;    // Các thông báo&#13;&#10;    public static final String ERROR_NETWORK = &quot;Không có kết nối internet&quot;;&#13;&#10;    public static final String ERROR_LOGIN_FAILED = &quot;Đăng nhập thất bại&quot;;&#13;&#10;    public static final String ERROR_REGISTRATION_FAILED = &quot;Đăng ký thất bại&quot;;&#13;&#10;    public static final String SUCCESS_LOGIN = &quot;Đăng nhập thành công&quot;;&#13;&#10;    public static final String SUCCESS_REGISTRATION = &quot;Đăng ký thành công&quot;;&#13;&#10;    public static final String SUCCESS_PASSWORD_RESET = &quot;Đã gửi email đặt lại mật khẩu&quot;;&#13;&#10;&#13;&#10;    // Các màu sắc gradient cho nút (được định nghĩa trong XML)&#13;&#10;    public static final String PRIMARY_BUTTON_GRADIENT = &quot;primary_button_gradient&quot;;&#13;&#10;    public static final String SECONDARY_BUTTON_GRADIENT = &quot;secondary_button_gradient&quot;;&#13;&#10;    &#13;&#10;    // Các action cho ReminderService&#13;&#10;    public static final String ACTION_SET_REMINDER = &quot;com.vhn.doan.action.SET_REMINDER&quot;;&#13;&#10;    public static final String ACTION_SHOW_MISSED_REMINDER = &quot;com.vhn.doan.action.SHOW_MISSED_REMINDER&quot;;&#13;&#10;    public static final String ACTION_CANCEL_REMINDER = &quot;com.vhn.doan.action.CANCEL_REMINDER&quot;;&#13;&#10;    public static final String ACTION_REMINDER_TRIGGER = &quot;com.vhn.doan.action.REMINDER_TRIGGER&quot;;&#13;&#10;    &#13;&#10;    // Các key cho Intent extras&#13;&#10;    public static final String EXTRA_REMINDER = &quot;com.vhn.doan.extra.REMINDER&quot;;&#13;&#10;    public static final String EXTRA_REMINDER_ID = &quot;com.vhn.doan.extra.REMINDER_ID&quot;;&#13;&#10;    public static final String EXTRA_REMINDER_TITLE = &quot;com.vhn.doan.extra.REMINDER_TITLE&quot;;&#13;&#10;    public static final String EXTRA_REMINDER_MESSAGE = &quot;com.vhn.doan.extra.REMINDER_MESSAGE&quot;;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/utils/NotificationDebugHelper.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/utils/NotificationDebugHelper.java" />
              <option name="updatedContent" value="package com.vhn.doan.utils;&#10;&#10;import android.app.NotificationChannel;&#10;import android.app.NotificationManager;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.os.Build;&#10;import android.provider.Settings;&#10;import android.util.Log;&#10;&#10;import androidx.core.app.NotificationCompat;&#10;import androidx.core.app.NotificationManagerCompat;&#10;&#10;import java.util.Random;&#10;&#10;/**&#10; * Helper class để debug và kiểm tra trạng thái thông báo&#10; * - Kiểm tra quyền thông báo&#10; * - Test thông báo ngay lập tức&#10; * - Kiểm tra thiết lập các kênh thông báo&#10; */&#10;public class NotificationDebugHelper {&#10;    private static final String TAG = &quot;NotificationDebugHelper&quot;;&#10;    private static final String DEBUG_CHANNEL_ID = &quot;debug_channel&quot;;&#10;    private static final String DEBUG_CHANNEL_NAME = &quot;Debug Notifications&quot;;&#10;&#10;    /**&#10;     * Kiểm tra xem ứng dụng có quyền hiển thị thông báo không&#10;     *&#10;     * @param context Context của ứng dụng&#10;     * @return true nếu có quyền, false nếu không&#10;     */&#10;    public static boolean checkNotificationPermission(Context context) {&#10;        if (context == null) return false;&#10;        &#10;        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);&#10;        boolean isEnabled = notificationManager.areNotificationsEnabled();&#10;        &#10;        Log.d(TAG, &quot;Quyền thông báo: &quot; + (isEnabled ? &quot;ĐÃ CẤP&quot; : &quot;CHƯA CẤP&quot;));&#10;        &#10;        return isEnabled;&#10;    }&#10;&#10;    /**&#10;     * Mở cài đặt thông báo của ứng dụng&#10;     *&#10;     * @param context Context của ứng dụng&#10;     */&#10;    public static void openNotificationSettings(Context context) {&#10;        if (context == null) return;&#10;        &#10;        try {&#10;            Intent intent = new Intent();&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                intent.setAction(Settings.ACTION_APP_NOTIFICATION_SETTINGS);&#10;                intent.putExtra(Settings.EXTRA_APP_PACKAGE, context.getPackageName());&#10;            } else {&#10;                intent.setAction(&quot;android.settings.APP_NOTIFICATION_SETTINGS&quot;);&#10;                intent.putExtra(&quot;app_package&quot;, context.getPackageName());&#10;                intent.putExtra(&quot;app_uid&quot;, context.getApplicationInfo().uid);&#10;            }&#10;            context.startActivity(intent);&#10;            Log.d(TAG, &quot;Mở cài đặt thông báo&quot;);&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Lỗi khi mở cài đặt thông báo: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra và tạo kênh thông báo debug nếu cần&#10;     *&#10;     * @param context Context của ứng dụng&#10;     */&#10;    private static void ensureDebugChannelExists(Context context) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            NotificationManager notificationManager = &#10;                    (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);&#10;            &#10;            NotificationChannel channel = notificationManager.getNotificationChannel(DEBUG_CHANNEL_ID);&#10;            if (channel == null) {&#10;                channel = new NotificationChannel(&#10;                        DEBUG_CHANNEL_ID,&#10;                        DEBUG_CHANNEL_NAME,&#10;                        NotificationManager.IMPORTANCE_HIGH&#10;                );&#10;                channel.setDescription(&quot;Kênh dùng để test thông báo&quot;);&#10;                notificationManager.createNotificationChannel(channel);&#10;                Log.d(TAG, &quot;Đã tạo kênh thông báo debug&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Test thông báo ngay lập tức&#10;     *&#10;     * @param context Context của ứng dụng&#10;     * @return true nếu thông báo được hiển thị thành công, false nếu không&#10;     */&#10;    public static boolean testNotification(Context context) {&#10;        if (context == null) return false;&#10;        &#10;        if (!checkNotificationPermission(context)) {&#10;            Log.e(TAG, &quot;Test notification thất bại: Không có quyền hiển thị thông báo&quot;);&#10;            return false;&#10;        }&#10;        &#10;        try {&#10;            ensureDebugChannelExists(context);&#10;            &#10;            int notificationId = new Random().nextInt(1000);&#10;            NotificationCompat.Builder builder = new NotificationCompat.Builder(context, DEBUG_CHANNEL_ID)&#10;                    .setSmallIcon(android.R.drawable.ic_dialog_info)&#10;                    .setContentTitle(&quot;Test Notification&quot;)&#10;                    .setContentText(&quot;Đây là thông báo test từ NotificationDebugHelper&quot;)&#10;                    .setPriority(NotificationCompat.PRIORITY_HIGH)&#10;                    .setAutoCancel(true);&#10;                    &#10;            NotificationManagerCompat notificationManager = NotificationManagerCompat.from(context);&#10;            notificationManager.notify(notificationId, builder.build());&#10;            &#10;            Log.d(TAG, &quot;Đã hiển thị thông báo test với ID: &quot; + notificationId);&#10;            return true;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Lỗi khi hiển thị thông báo test: &quot; + e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra các kênh thông báo hiện tại của ứng dụng&#10;     *&#10;     * @param context Context của ứng dụng&#10;     * @return Mảng các kênh thông báo hoặc null nếu không có hoặc SDK &lt; Oreo&#10;     */&#10;    public static String[] checkNotificationChannels(Context context) {&#10;        if (context == null) return null;&#10;        &#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            try {&#10;                NotificationManager notificationManager = &#10;                        (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);&#10;                &#10;                if (notificationManager.getNotificationChannels().size() == 0) {&#10;                    Log.d(TAG, &quot;Không có kênh thông báo nào được tạo&quot;);&#10;                    return new String[]{&quot;Không có kênh thông báo nào&quot;};&#10;                }&#10;                &#10;                String[] channelIds = new String[notificationManager.getNotificationChannels().size()];&#10;                for (int i = 0; i &lt; channelIds.length; i++) {&#10;                    NotificationChannel channel = notificationManager.getNotificationChannels().get(i);&#10;                    channelIds[i] = channel.getId() + &quot; (&quot; + channel.getName() + &quot;)&quot;;&#10;                    Log.d(TAG, &quot;Kênh thông báo: &quot; + channelIds[i]);&#10;                }&#10;                &#10;                return channelIds;&#10;            } catch (Exception e) {&#10;                Log.e(TAG, &quot;Lỗi khi kiểm tra kênh thông báo: &quot; + e.getMessage());&#10;                return null;&#10;            }&#10;        } else {&#10;            Log.d(TAG, &quot;Notification Channels không được hỗ trợ trên Android &quot; + Build.VERSION.SDK_INT);&#10;            return new String[]{&quot;Notification Channels chỉ được hỗ trợ từ Android 8.0 trở lên&quot;};&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/utils/PermissionHelper.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/utils/PermissionHelper.java" />
              <option name="originalContent" value="package com.vhn.doan.utils;&#10;&#10;import android.Manifest;&#10;import android.app.AlertDialog;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.content.pm.PackageManager;&#10;import android.os.Build;&#10;import android.os.PowerManager;&#10;import androidx.core.app.ActivityCompat;&#10;import androidx.core.content.ContextCompat;&#10;import androidx.fragment.app.Fragment;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Helper class để quản lý quyền ứng dụng&#10; */&#10;public class PermissionHelper {&#10;&#10;    // Mã yêu cầu quyền cho reminder&#10;    public static final int PERMISSION_REQUEST_REMINDER = 1001;&#10;&#10;    // Quyền cần thiết cho tính năng reminder - chỉ cần thông báo&#10;    private static final String[] REMINDER_PERMISSIONS = {&#10;            Manifest.permission.POST_NOTIFICATIONS&#10;    };&#10;&#10;    // Map để lưu trữ callback theo fragment hashCode&#10;    private static final Map&lt;Integer, PermissionCallback&gt; callbackMap = new HashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Interface callback cho việc xử lý kết quả quyền&#10;     */&#10;    public interface PermissionCallback {&#10;        void onPermissionsGranted();&#10;        void onPermissionsDenied(List&lt;String&gt; deniedPermissions);&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra xem tất cả quyền reminder đã được cấp chưa (bao gồm tối ưu hóa pin)&#10;     */&#10;    public static boolean hasReminderPermissions(Context context) {&#10;        // Kiểm tra quyền thông báo cơ bản&#10;        boolean hasNotificationPermission = hasBasicNotificationPermission(context);&#10;&#10;        // Kiểm tra tối ưu hóa pin&#10;        boolean isBatteryOptimizationIgnored = isBatteryOptimizationIgnored(context);&#10;&#10;        return hasNotificationPermission &amp;&amp; isBatteryOptimizationIgnored;&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra quyền thông báo cơ bản&#10;     */&#10;    public static boolean hasBasicNotificationPermission(Context context) {&#10;        // Đối với Android 13+ mới cần kiểm tra POST_NOTIFICATIONS&#10;        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.TIRAMISU) {&#10;            return true; // Không cần quyền thông báo cho Android &lt; 13&#10;        }&#10;&#10;        return ContextCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS)&#10;                == PackageManager.PERMISSION_GRANTED;&#10;    }&#10;&#10;    /**&#10;     * ✅ THÊM: Kiểm tra xem app có bị tối ưu hóa pin không&#10;     */&#10;    public static boolean isBatteryOptimizationIgnored(Context context) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;            PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);&#10;            return powerManager.isIgnoringBatteryOptimizations(context.getPackageName());&#10;        }&#10;        return true; // Android &lt; 6.0 không có Doze Mode&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách quyền chưa được cấp (bao gồm tối ưu hóa pin)&#10;     */&#10;    public static List&lt;String&gt; getMissingReminderPermissions(Context context) {&#10;        List&lt;String&gt; missingPermissions = new ArrayList&lt;&gt;();&#10;&#10;        // Kiểm tra quyền thông báo&#10;        if (!hasBasicNotificationPermission(context)) {&#10;            missingPermissions.add(Manifest.permission.POST_NOTIFICATIONS);&#10;        }&#10;&#10;        // Kiểm tra tối ưu hóa pin&#10;        if (!isBatteryOptimizationIgnored(context)) {&#10;            missingPermissions.add(&quot;BATTERY_OPTIMIZATION&quot;);&#10;        }&#10;&#10;        return missingPermissions;&#10;    }&#10;&#10;    /**&#10;     * Hiển thị dialog giải thích tại sao cần quyền và yêu cầu cấp quyền (cập nhật)&#10;     */&#10;    public static void showPermissionExplanationDialog(Fragment fragment,&#10;                                                      PermissionCallback callback) {&#10;        if (fragment.getContext() == null) {&#10;            return;&#10;        }&#10;&#10;        List&lt;String&gt; missingPermissions = getMissingReminderPermissions(fragment.getContext());&#10;        if (missingPermissions.isEmpty()) {&#10;            callback.onPermissionsGranted();&#10;            return;&#10;        }&#10;&#10;        String message = buildPermissionMessage(missingPermissions);&#10;&#10;        new AlertDialog.Builder(fragment.getContext())&#10;                .setTitle(&quot;Cần cấp quyền&quot;)&#10;                .setMessage(message)&#10;                .setPositiveButton(&quot;Cấp quyền&quot;, (dialog, which) -&gt; {&#10;                    dialog.dismiss();&#10;                    requestPermissions(fragment, missingPermissions, callback);&#10;                })&#10;                .setNegativeButton(&quot;Hủy&quot;, (dialog, which) -&gt; {&#10;                    dialog.dismiss();&#10;                    callback.onPermissionsDenied(missingPermissions);&#10;                })&#10;                .setCancelable(false)&#10;                .show();&#10;    }&#10;&#10;    /**&#10;     * Yêu cầu cấp quyền (cập nhật để xử lý tối ưu hóa pin)&#10;     */&#10;    private static void requestPermissions(Fragment fragment,&#10;                                         List&lt;String&gt; permissions,&#10;                                         PermissionCallback callback) {&#10;        // Lưu callback vào map với key là hashCode của fragment&#10;        int fragmentKey = fragment.hashCode();&#10;        callbackMap.put(fragmentKey, callback);&#10;&#10;        // Kiểm tra xem có cần yêu cầu tối ưu hóa pin không&#10;        boolean needsBatteryOptimization = permissions.contains(&quot;BATTERY_OPTIMIZATION&quot;);&#10;        boolean needsNotificationPermission = permissions.contains(Manifest.permission.POST_NOTIFICATIONS);&#10;&#10;        if (needsBatteryOptimization) {&#10;            // Ưu tiên xử lý tối ưu hóa pin trước&#10;            requestIgnoreBatteryOptimization(fragment, callback);&#10;        } else if (needsNotificationPermission) {&#10;            // Chỉ yêu cầu quyền thông báo&#10;            String[] permissionArray = {Manifest.permission.POST_NOTIFICATIONS};&#10;            fragment.requestPermissions(permissionArray, PERMISSION_REQUEST_REMINDER);&#10;        } else {&#10;            // Không có quyền nào cần yêu cầu&#10;            callback.onPermissionsGranted();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * ✅ THÊM: Yêu cầu tắt tối ưu hóa pin&#10;     */&#10;    private static void requestIgnoreBatteryOptimization(Fragment fragment, PermissionCallback callback) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;            try {&#10;                String packageName = fragment.requireContext().getPackageName();&#10;                Intent intent = new Intent(android.provider.Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);&#10;                intent.setData(android.net.Uri.parse(&quot;package:&quot; + packageName));&#10;                fragment.startActivity(intent);&#10;&#10;                // Hiển thị thông báo hướng dẫn&#10;                new AlertDialog.Builder(fragment.getContext())&#10;                    .setTitle(&quot;Tối ưu hóa pin&quot;)&#10;                    .setMessage(&quot;Vui lòng chọn \&quot;Cho phép\&quot; để đảm bảo nhắc nhở hoạt động khi app ở chế độ nền.\n\nSau khi cài đặt xong, vui lòng quay lại app.&quot;)&#10;                    .setPositiveButton(&quot;Đã hiểu&quot;, (dialog, which) -&gt; {&#10;                        // Kiểm tra lại sau khi người dùng quay lại&#10;                        checkPermissionsAfterBatteryOptimization(fragment, callback);&#10;                    })&#10;                    .setCancelable(false)&#10;                    .show();&#10;&#10;            } catch (Exception e) {&#10;                android.util.Log.e(&quot;PermissionHelper&quot;, &quot;Lỗi khi mở cài đặt tối ưu hóa pin&quot;, e);&#10;                callback.onPermissionsDenied(java.util.Arrays.asList(&quot;BATTERY_OPTIMIZATION&quot;));&#10;            }&#10;        } else {&#10;            callback.onPermissionsGranted();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * ✅ THÊM: Kiểm tra quyền sau khi cài đặt tối ưu hóa pin&#10;     */&#10;    private static void checkPermissionsAfterBatteryOptimization(Fragment fragment, PermissionCallback callback) {&#10;        if (fragment.getContext() == null) return;&#10;&#10;        // Kiểm tra lại tất cả quyền&#10;        List&lt;String&gt; stillMissingPermissions = getMissingReminderPermissions(fragment.getContext());&#10;&#10;        if (stillMissingPermissions.isEmpty()) {&#10;            callback.onPermissionsGranted();&#10;        } else if (stillMissingPermissions.contains(Manifest.permission.POST_NOTIFICATIONS)) {&#10;            // Vẫn cần quyền thông báo&#10;            String[] permissionArray = {Manifest.permission.POST_NOTIFICATIONS};&#10;            fragment.requestPermissions(permissionArray, PERMISSION_REQUEST_REMINDER);&#10;        } else {&#10;            callback.onPermissionsDenied(stillMissingPermissions);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Tạo thông điệp giải thích về quyền cần thiết (cập nhật)&#10;     */&#10;    private static String buildPermissionMessage(List&lt;String&gt; missingPermissions) {&#10;        StringBuilder message = new StringBuilder();&#10;        message.append(&quot;Ứng dụng cần các quyền sau để nhắc nhở hoạt động ổn định:\n\n&quot;);&#10;&#10;        for (String permission : missingPermissions) {&#10;            switch (permission) {&#10;                case Manifest.permission.POST_NOTIFICATIONS:&#10;                    message.append(&quot;• Thông báo: Để hiển thị nhắc nhở đúng thời gian\n&quot;);&#10;                    break;&#10;                case &quot;BATTERY_OPTIMIZATION&quot;:&#10;                    message.append(&quot;• Tắt tối ưu hóa pin: Để nhắc nhở hoạt động khi app ở chế độ nền\n&quot;);&#10;                    break;&#10;            }&#10;        }&#10;&#10;        message.append(&quot;\nBạn có muốn cấp quyền để sử dụng đầy đủ tính năng không?&quot;);&#10;        return message.toString();&#10;    }&#10;&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.utils;&#13;&#10;&#13;&#10;import android.Manifest;&#13;&#10;import android.app.AlertDialog;&#13;&#10;import android.content.Context;&#13;&#10;import android.content.Intent;&#13;&#10;import android.content.pm.PackageManager;&#13;&#10;import android.os.Build;&#13;&#10;import android.os.PowerManager;&#13;&#10;import androidx.core.app.ActivityCompat;&#13;&#10;import androidx.core.content.ContextCompat;&#13;&#10;import androidx.fragment.app.Fragment;&#13;&#10;import java.util.ArrayList;&#13;&#10;import java.util.List;&#13;&#10;import java.util.HashMap;&#13;&#10;import java.util.Map;&#13;&#10;&#13;&#10;/**&#13;&#10; * Helper class để quản lý quyền ứng dụng&#13;&#10; */&#13;&#10;public class PermissionHelper {&#13;&#10;&#13;&#10;    // Mã yêu cầu quyền cho reminder&#13;&#10;    public static final int PERMISSION_REQUEST_REMINDER = 1001;&#13;&#10;&#13;&#10;    // Quyền cần thiết cho tính năng reminder - chỉ cần thông báo&#13;&#10;    private static final String[] REMINDER_PERMISSIONS = {&#13;&#10;            Manifest.permission.POST_NOTIFICATIONS&#13;&#10;    };&#13;&#10;&#13;&#10;    // Map để lưu trữ callback theo fragment hashCode&#13;&#10;    private static final Map&lt;Integer, PermissionCallback&gt; callbackMap = new HashMap&lt;&gt;();&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Interface callback cho việc xử lý kết quả quyền&#13;&#10;     */&#13;&#10;    public interface PermissionCallback {&#13;&#10;        void onPermissionsGranted();&#13;&#10;        void onPermissionsDenied(List&lt;String&gt; deniedPermissions);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Kiểm tra xem tất cả quyền reminder đã được cấp chưa (bao gồm tối ưu hóa pin)&#13;&#10;     */&#13;&#10;    public static boolean hasReminderPermissions(Context context) {&#13;&#10;        // Kiểm tra quyền thông báo cơ bản&#13;&#10;        boolean hasNotificationPermission = hasBasicNotificationPermission(context);&#13;&#10;&#13;&#10;        // Kiểm tra tối ưu hóa pin&#13;&#10;        boolean isBatteryOptimizationIgnored = isBatteryOptimizationIgnored(context);&#13;&#10;&#13;&#10;        return hasNotificationPermission &amp;&amp; isBatteryOptimizationIgnored;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Kiểm tra quyền thông báo cơ bản&#13;&#10;     */&#13;&#10;    public static boolean hasBasicNotificationPermission(Context context) {&#13;&#10;        // Đối với Android 13+ mới cần kiểm tra POST_NOTIFICATIONS&#13;&#10;        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.TIRAMISU) {&#13;&#10;            return true; // Không cần quyền thông báo cho Android &lt; 13&#13;&#10;        }&#13;&#10;&#13;&#10;        return ContextCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS)&#13;&#10;                == PackageManager.PERMISSION_GRANTED;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * ✅ THÊM: Kiểm tra xem app có bị tối ưu hóa pin không&#13;&#10;     */&#13;&#10;    public static boolean isBatteryOptimizationIgnored(Context context) {&#13;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#13;&#10;            PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);&#13;&#10;            return powerManager.isIgnoringBatteryOptimizations(context.getPackageName());&#13;&#10;        }&#13;&#10;        return true; // Android &lt; 6.0 không có Doze Mode&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Lấy danh sách quyền chưa được cấp (bao gồm tối ưu hóa pin)&#13;&#10;     */&#13;&#10;    public static List&lt;String&gt; getMissingReminderPermissions(Context context) {&#13;&#10;        List&lt;String&gt; missingPermissions = new ArrayList&lt;&gt;();&#13;&#10;&#13;&#10;        // Kiểm tra quyền thông báo&#13;&#10;        if (!hasBasicNotificationPermission(context)) {&#13;&#10;            missingPermissions.add(Manifest.permission.POST_NOTIFICATIONS);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Kiểm tra tối ưu hóa pin&#13;&#10;        if (!isBatteryOptimizationIgnored(context)) {&#13;&#10;            missingPermissions.add(&quot;BATTERY_OPTIMIZATION&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        return missingPermissions;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Hiển thị dialog giải thích tại sao cần quyền và yêu cầu cấp quyền (cập nhật)&#13;&#10;     */&#13;&#10;    public static void showPermissionExplanationDialog(Fragment fragment,&#13;&#10;                                                      PermissionCallback callback) {&#13;&#10;        if (fragment.getContext() == null) {&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        List&lt;String&gt; missingPermissions = getMissingReminderPermissions(fragment.getContext());&#13;&#10;        if (missingPermissions.isEmpty()) {&#13;&#10;            callback.onPermissionsGranted();&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        String message = buildPermissionMessage(missingPermissions);&#13;&#10;&#13;&#10;        new AlertDialog.Builder(fragment.getContext())&#13;&#10;                .setTitle(&quot;Cần cấp quyền&quot;)&#13;&#10;                .setMessage(message)&#13;&#10;                .setPositiveButton(&quot;Cấp quyền&quot;, (dialog, which) -&gt; {&#13;&#10;                    dialog.dismiss();&#13;&#10;                    requestPermissions(fragment, missingPermissions, callback);&#13;&#10;                })&#13;&#10;                .setNegativeButton(&quot;Hủy&quot;, (dialog, which) -&gt; {&#13;&#10;                    dialog.dismiss();&#13;&#10;                    callback.onPermissionsDenied(missingPermissions);&#13;&#10;                })&#13;&#10;                .setCancelable(false)&#13;&#10;                .show();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Yêu cầu cấp quyền (cập nhật để xử lý tối ưu hóa pin)&#13;&#10;     */&#13;&#10;    private static void requestPermissions(Fragment fragment,&#13;&#10;                                         List&lt;String&gt; permissions,&#13;&#10;                                         PermissionCallback callback) {&#13;&#10;        // Lưu callback vào map với key là hashCode của fragment&#13;&#10;        int fragmentKey = fragment.hashCode();&#13;&#10;        callbackMap.put(fragmentKey, callback);&#13;&#10;&#13;&#10;        // Kiểm tra xem có cần yêu cầu tối ưu hóa pin không&#13;&#10;        boolean needsBatteryOptimization = permissions.contains(&quot;BATTERY_OPTIMIZATION&quot;);&#13;&#10;        boolean needsNotificationPermission = permissions.contains(Manifest.permission.POST_NOTIFICATIONS);&#13;&#10;&#13;&#10;        if (needsBatteryOptimization) {&#13;&#10;            // Ưu tiên xử lý tối ưu hóa pin trước&#13;&#10;            requestIgnoreBatteryOptimization(fragment, callback);&#13;&#10;        } else if (needsNotificationPermission) {&#13;&#10;            // Chỉ yêu cầu quyền thông báo&#13;&#10;            String[] permissionArray = {Manifest.permission.POST_NOTIFICATIONS};&#13;&#10;            fragment.requestPermissions(permissionArray, PERMISSION_REQUEST_REMINDER);&#13;&#10;        } else {&#13;&#10;            // Không có quyền nào cần yêu cầu&#13;&#10;            callback.onPermissionsGranted();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * ✅ THÊM: Yêu cầu tắt tối ưu hóa pin&#13;&#10;     */&#13;&#10;    private static void requestIgnoreBatteryOptimization(Fragment fragment, PermissionCallback callback) {&#13;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#13;&#10;            try {&#13;&#10;                String packageName = fragment.requireContext().getPackageName();&#13;&#10;                Intent intent = new Intent(android.provider.Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);&#13;&#10;                intent.setData(android.net.Uri.parse(&quot;package:&quot; + packageName));&#13;&#10;                fragment.startActivity(intent);&#13;&#10;&#13;&#10;                // Hiển thị thông báo hướng dẫn&#13;&#10;                new AlertDialog.Builder(fragment.getContext())&#13;&#10;                    .setTitle(&quot;Tối ưu hóa pin&quot;)&#13;&#10;                    .setMessage(&quot;Vui lòng chọn \&quot;Cho phép\&quot; để đảm bảo nhắc nhở hoạt động khi app ở chế độ nền.\n\nSau khi cài đặt xong, vui lòng quay lại app.&quot;)&#13;&#10;                    .setPositiveButton(&quot;Đã hiểu&quot;, (dialog, which) -&gt; {&#13;&#10;                        // Kiểm tra lại sau khi người dùng quay lại&#13;&#10;                        checkPermissionsAfterBatteryOptimization(fragment, callback);&#13;&#10;                    })&#13;&#10;                    .setCancelable(false)&#13;&#10;                    .show();&#13;&#10;&#13;&#10;            } catch (Exception e) {&#13;&#10;                android.util.Log.e(&quot;PermissionHelper&quot;, &quot;Lỗi khi mở cài đặt tối ưu hóa pin&quot;, e);&#13;&#10;                callback.onPermissionsDenied(java.util.Arrays.asList(&quot;BATTERY_OPTIMIZATION&quot;));&#13;&#10;            }&#13;&#10;        } else {&#13;&#10;            callback.onPermissionsGranted();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * ✅ THÊM: Kiểm tra quyền sau khi cài đặt tối ưu hóa pin&#13;&#10;     */&#13;&#10;    private static void checkPermissionsAfterBatteryOptimization(Fragment fragment, PermissionCallback callback) {&#13;&#10;        if (fragment.getContext() == null) return;&#13;&#10;&#13;&#10;        // Kiểm tra lại tất cả quyền&#13;&#10;        List&lt;String&gt; stillMissingPermissions = getMissingReminderPermissions(fragment.getContext());&#13;&#10;&#13;&#10;        if (stillMissingPermissions.isEmpty()) {&#13;&#10;            callback.onPermissionsGranted();&#13;&#10;        } else if (stillMissingPermissions.contains(Manifest.permission.POST_NOTIFICATIONS)) {&#13;&#10;            // Vẫn cần quyền thông báo&#13;&#10;            String[] permissionArray = {Manifest.permission.POST_NOTIFICATIONS};&#13;&#10;            fragment.requestPermissions(permissionArray, PERMISSION_REQUEST_REMINDER);&#13;&#10;        } else {&#13;&#10;            callback.onPermissionsDenied(stillMissingPermissions);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Tạo thông điệp giải thích về quyền cần thiết (cập nhật)&#13;&#10;     */&#13;&#10;    private static String buildPermissionMessage(List&lt;String&gt; missingPermissions) {&#13;&#10;        StringBuilder message = new StringBuilder();&#13;&#10;        message.append(&quot;Ứng dụng cần các quyền sau để nhắc nhở hoạt động ổn định:\n\n&quot;);&#13;&#10;&#13;&#10;        for (String permission : missingPermissions) {&#13;&#10;            switch (permission) {&#13;&#10;                case Manifest.permission.POST_NOTIFICATIONS:&#13;&#10;                    message.append(&quot;• Thông báo: Để hiển thị nhắc nhở đúng thời gian\n&quot;);&#13;&#10;                    break;&#13;&#10;                case &quot;BATTERY_OPTIMIZATION&quot;:&#13;&#10;                    message.append(&quot;• Tắt tối ưu hóa pin: Để nhắc nhở hoạt động khi app ở chế độ nền\n&quot;);&#13;&#10;                    break;&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        message.append(&quot;\nBạn có muốn cấp quyền để sử dụng đầy đủ tính năng không?&quot;);&#13;&#10;        return message.toString();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Xử lý kết quả yêu cầu quyền&#13;&#10;     */&#13;&#10;    public static void handlePermissionResult(Fragment fragment,&#13;&#10;                                            int requestCode,&#13;&#10;                                            String[] permissions,&#13;&#10;                                            int[] grantResults) {&#13;&#10;        if (requestCode != PERMISSION_REQUEST_REMINDER) {&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        // Lấy callback từ map&#13;&#10;        int fragmentKey = fragment.hashCode();&#13;&#10;        PermissionCallback callback = callbackMap.get(fragmentKey);&#13;&#10;        if (callback == null) {&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        List&lt;String&gt; deniedPermissions = new ArrayList&lt;&gt;();&#13;&#10;        for (int i = 0; i &lt; permissions.length; i++) {&#13;&#10;            if (grantResults[i] != PackageManager.PERMISSION_GRANTED) {&#13;&#10;                deniedPermissions.add(permissions[i]);&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        if (deniedPermissions.isEmpty()) {&#13;&#10;            callback.onPermissionsGranted();&#13;&#10;        } else {&#13;&#10;            callback.onPermissionsDenied(deniedPermissions);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Xóa callback khỏi map&#13;&#10;        callbackMap.remove(fragmentKey);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Kiểm tra xem có nên hiển thị giải thích quyền hay không&#13;&#10;     */&#13;&#10;    public static boolean shouldShowRequestPermissionRationale(Fragment fragment, String permission) {&#13;&#10;        return fragment.shouldShowRequestPermissionRationale(permission);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Kiểm tra xem có quyền thông báo hay không&#13;&#10;     */&#13;&#10;    public static boolean hasNotificationPermission(Context context) {&#13;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#13;&#10;            return ContextCompat.checkSelfPermission(context,&#13;&#10;                Manifest.permission.POST_NOTIFICATIONS) == PackageManager.PERMISSION_GRANTED;&#13;&#10;        }&#13;&#10;        return true; // Android &lt; 13 không cần quyền thông báo runtime&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Yêu cầu quyền thông báo&#13;&#10;     */&#13;&#10;    public static void requestNotificationPermission(Fragment fragment, NotificationPermissionCallback callback) {&#13;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#13;&#10;            // Lưu callback&#13;&#10;            int fragmentKey = fragment.hashCode();&#13;&#10;            notificationCallbackMap.put(fragmentKey, callback);&#13;&#10;&#13;&#10;            // Yêu cầu quyền&#13;&#10;            fragment.requestPermissions(&#13;&#10;                new String[]{Manifest.permission.POST_NOTIFICATIONS},&#13;&#10;                PERMISSION_REQUEST_REMINDER&#13;&#10;            );&#13;&#10;        } else {&#13;&#10;            // Android &lt; 13 tự động có quyền&#13;&#10;            callback.onResult(true);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Interface callback cho quyền thông báo&#13;&#10;     */&#13;&#10;    public interface NotificationPermissionCallback {&#13;&#10;        void onResult(boolean granted);&#13;&#10;    }&#13;&#10;&#13;&#10;    // Map để lưu notification permission callbacks&#13;&#10;    private static final Map&lt;Integer, NotificationPermissionCallback&gt; notificationCallbackMap = new HashMap&lt;&gt;();&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/utils/ReminderPermissionHelper.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/utils/ReminderPermissionHelper.java" />
              <option name="updatedContent" value="package com.vhn.doan.utils;&#10;&#10;import android.app.AlertDialog;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.net.Uri;&#10;import android.os.Build;&#10;import android.os.PowerManager;&#10;import android.provider.Settings;&#10;import android.util.Log;&#10;&#10;import androidx.fragment.app.Fragment;&#10;&#10;/**&#10; * Helper class để quản lý các quyền đặc biệt cần thiết cho hệ thống nhắc nhở&#10; */&#10;public class ReminderPermissionHelper {&#10;    &#10;    private static final String TAG = &quot;ReminderPermissionHelper&quot;;&#10;&#10;    /**&#10;     * Kiểm tra và yêu cầu tất cả quyền cần thiết cho reminder&#10;     */&#10;    public static void checkAndRequestAllPermissions(Fragment fragment, ReminderPermissionCallback callback) {&#10;        Context context = fragment.getContext();&#10;        if (context == null) {&#10;            callback.onError(&quot;Context is null&quot;);&#10;            return;&#10;        }&#10;&#10;        // Kiểm tra quyền thông báo&#10;        if (!PermissionHelper.hasNotificationPermission(context)) {&#10;            showPermissionDialog(fragment, &quot;Quyền thông báo&quot;, &#10;                &quot;Ứng dụng cần quyền hiển thị thông báo để nhắc nhở bạn về sức khỏe.&quot;,&#10;                () -&gt; PermissionHelper.requestNotificationPermission(fragment, callback::onNotificationPermissionResult));&#10;            return;&#10;        }&#10;&#10;        // Kiểm tra quyền exact alarm&#10;        if (!hasExactAlarmPermission(context)) {&#10;            showPermissionDialog(fragment, &quot;Quyền báo thức chính xác&quot;, &#10;                &quot;Ứng dụng cần quyền đặt báo thức chính xác để thông báo đúng giờ.&quot;,&#10;                () -&gt; requestExactAlarmPermission(fragment));&#10;            return;&#10;        }&#10;&#10;        // Kiểm tra tối ưu hóa pin&#10;        if (!isBatteryOptimizationDisabled(context)) {&#10;            showBatteryOptimizationDialog(fragment, callback);&#10;            return;&#10;        }&#10;&#10;        // Tất cả quyền đã được cấp&#10;        callback.onAllPermissionsGranted();&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra quyền exact alarm&#10;     */&#10;    public static boolean hasExactAlarmPermission(Context context) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;            android.app.AlarmManager alarmManager = (android.app.AlarmManager) context.getSystemService(Context.ALARM_SERVICE);&#10;            return alarmManager.canScheduleExactAlarms();&#10;        }&#10;        return true;&#10;    }&#10;&#10;    /**&#10;     * Yêu cầu quyền exact alarm&#10;     */&#10;    public static void requestExactAlarmPermission(Fragment fragment) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;            Intent intent = new Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM);&#10;            intent.setData(Uri.parse(&quot;package:&quot; + fragment.requireContext().getPackageName()));&#10;            fragment.startActivity(intent);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra xem battery optimization có bị tắt không&#10;     */&#10;    public static boolean isBatteryOptimizationDisabled(Context context) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;            PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);&#10;            return powerManager.isIgnoringBatteryOptimizations(context.getPackageName());&#10;        }&#10;        return true;&#10;    }&#10;&#10;    /**&#10;     * Hiển thị dialog yêu cầu tắt battery optimization&#10;     */&#10;    private static void showBatteryOptimizationDialog(Fragment fragment, ReminderPermissionCallback callback) {&#10;        new AlertDialog.Builder(fragment.requireContext())&#10;            .setTitle(&quot;Tối ưu hóa pin&quot;)&#10;            .setMessage(&quot;Để đảm bảo nhắc nhở hoạt động ngay cả khi app bị tắt, vui lòng tắt tối ưu hóa pin cho ứng dụng này.\n\n&quot; +&#10;                       &quot;Điều này sẽ không ảnh hưởng đáng kể đến thời lượng pin của bạn.&quot;)&#10;            .setPositiveButton(&quot;Cài đặt&quot;, (dialog, which) -&gt; {&#10;                requestBatteryOptimizationDisable(fragment);&#10;                dialog.dismiss();&#10;            })&#10;            .setNegativeButton(&quot;Bỏ qua&quot;, (dialog, which) -&gt; {&#10;                dialog.dismiss();&#10;                callback.onBatteryOptimizationDenied();&#10;            })&#10;            .setCancelable(false)&#10;            .show();&#10;    }&#10;&#10;    /**&#10;     * Yêu cầu tắt battery optimization&#10;     */&#10;    public static void requestBatteryOptimizationDisable(Fragment fragment) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;            try {&#10;                Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);&#10;                intent.setData(Uri.parse(&quot;package:&quot; + fragment.requireContext().getPackageName()));&#10;                fragment.startActivity(intent);&#10;            } catch (Exception e) {&#10;                Log.e(TAG, &quot;Failed to open battery optimization settings&quot;, e);&#10;                // Fallback to general battery optimization settings&#10;                Intent intent = new Intent(Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS);&#10;                fragment.startActivity(intent);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Hiển thị dialog thông báo quyền&#10;     */&#10;    private static void showPermissionDialog(Fragment fragment, String title, String message, Runnable onAccept) {&#10;        new AlertDialog.Builder(fragment.requireContext())&#10;            .setTitle(title)&#10;            .setMessage(message)&#10;            .setPositiveButton(&quot;Cấp quyền&quot;, (dialog, which) -&gt; {&#10;                dialog.dismiss();&#10;                onAccept.run();&#10;            })&#10;            .setNegativeButton(&quot;Hủy&quot;, (dialog, which) -&gt; dialog.dismiss())&#10;            .setCancelable(false)&#10;            .show();&#10;    }&#10;&#10;    /**&#10;     * Khởi động foreground service để duy trì hoạt động&#10;     */&#10;    public static void startReminderService(Context context) {&#10;        try {&#10;            com.vhn.doan.services.ReminderForegroundService.startService(context);&#10;            Log.d(TAG, &quot;Reminder foreground service started&quot;);&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Failed to start reminder service&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Interface callback cho permission results&#10;     */&#10;    public interface ReminderPermissionCallback {&#10;        void onAllPermissionsGranted();&#10;        void onNotificationPermissionResult(boolean granted);&#10;        void onBatteryOptimizationDenied();&#10;        void onError(String error);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/workers/ReminderWorker.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/workers/ReminderWorker.java" />
              <option name="originalContent" value="package com.vhn.doan.workers;&#10;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.os.PowerManager;&#10;import android.util.Log;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.work.Worker;&#10;import androidx.work.WorkerParameters;&#10;&#10;import com.vhn.doan.data.Reminder;&#10;import com.vhn.doan.data.repository.ReminderRepository;&#10;import com.vhn.doan.data.repository.ReminderRepositoryImpl;&#10;import com.vhn.doan.data.repository.RepositoryCallback;&#10;import com.vhn.doan.data.repository.RepositoryCallback;&#10;import com.vhn.doan.services.NotificationService;&#10;&#10;/**&#10; * WorkManager Worker để xử lý thông báo nhắc nhở&#10; * Hoạt động mạnh mẽ hơn AlarmManager trong việc xử lý Doze mode&#10; */&#10;public class ReminderWorker extends Worker {&#10;&#10;    private static final String TAG = &quot;ReminderWorker&quot;;&#10;&#10;    // Input data keys&#10;    public static final String KEY_REMINDER_ID = &quot;reminder_id&quot;;&#10;    public static final String KEY_TITLE = &quot;title&quot;;&#10;    public static final String KEY_MESSAGE = &quot;message&quot;;&#10;&#10;    public ReminderWorker(@NonNull Context context, @NonNull WorkerParameters workerParams) {&#10;        super(context, workerParams);&#10;    }&#10;&#10;    @NonNull&#10;    @Override&#10;    public Result doWork() {&#10;        Log.d(TAG, &quot;ReminderWorker started&quot;);&#10;&#10;        // Acquire wake lock để đảm bảo thiết bị không sleep&#10;        PowerManager powerManager = (PowerManager) getApplicationContext().getSystemService(Context.POWER_SERVICE);&#10;        PowerManager.WakeLock wakeLock = powerManager.newWakeLock(&#10;            PowerManager.PARTIAL_WAKE_LOCK,&#10;            &quot;HealthTips:ReminderWorker&quot;&#10;        );&#10;&#10;        try {&#10;            wakeLock.acquire(30 * 1000); // 30 giây timeout&#10;&#10;            String reminderId = getInputData().getString(KEY_REMINDER_ID);&#10;            String title = getInputData().getString(KEY_TITLE);&#10;            String message = getInputData().getString(KEY_MESSAGE);&#10;&#10;            Log.d(TAG, &quot;Processing reminder - ID: &quot; + reminderId + &quot;, Title: &quot; + title);&#10;&#10;            if (reminderId == null || title == null || message == null) {&#10;                Log.w(TAG, &quot;Missing reminder data&quot;);&#10;                return Result.failure();&#10;            }&#10;&#10;            // Hiển thị thông báo ngay lập tức&#10;            NotificationService.showReminderNotification(getApplicationContext(), title, message, reminderId);&#10;            Log.d(TAG, &quot;Notification shown successfully&quot;);&#10;&#10;            // Cập nhật trạng thái reminder&#10;            updateReminderStatus(reminderId);&#10;&#10;            return Result.success();&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error in ReminderWorker&quot;, e);&#10;            return Result.failure();&#10;        } finally {&#10;            if (wakeLock.isHeld()) {&#10;                wakeLock.release();&#10;            }&#10;        }&#10;    }&#10;&#10;    private void updateReminderStatus(String reminderId) {&#10;        reminderRepository.getReminderById(reminderId, new RepositoryCallback&lt;Reminder&gt;() {&#10;        reminderRepository.getReminderById(reminderId, new RepositoryCallback&lt;Reminder&gt;() {&#10;            @Override&#10;            public void onSuccess(Reminder reminder) {&#10;                if (reminder != null) {&#10;                    Log.d(TAG, &quot;Successfully retrieved reminder for update: &quot; + reminder.getTitle());&#10;&#10;                    // Cập nhật lần thông báo cuối&#10;                    reminder.setLastNotified(System.currentTimeMillis());&#10;&#10;                    // Nếu không phải reminder lặp lại, đánh dấu là đã hoàn thành&#10;                    if (!reminder.isRepeating()) {&#10;                        reminder.setCompleted(true);&#10;                        reminder.setActive(false);&#10;                    }&#10;                    reminderRepository.updateReminder(reminder, new RepositoryCallback&lt;Void&gt;() {&#10;                    reminderRepository.updateReminder(reminder, new RepositoryCallback&lt;Void&gt;() {&#10;                        @Override&#10;                        public void onSuccess(Void result) {&#10;                            Log.d(TAG, &quot;Reminder status updated successfully&quot;);&#10;                        }&#10;&#10;                        @Override&#10;                        public void onError(String error) {&#10;                            Log.e(TAG, &quot;Failed to update reminder status: &quot; + error);&#10;                        }&#10;                    });&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                Log.e(TAG, &quot;Failed to retrieve reminder for update: &quot; + error);&#10;            }&#10;        });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.workers;&#10;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.os.PowerManager;&#10;import android.util.Log;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.work.Worker;&#10;import androidx.work.WorkerParameters;&#10;&#10;import com.vhn.doan.data.Reminder;&#10;import com.vhn.doan.data.repository.ReminderRepository;&#10;import com.vhn.doan.data.repository.ReminderRepositoryImpl;&#10;import com.vhn.doan.services.NotificationService;&#10;&#10;/**&#10; * WorkManager Worker để xử lý thông báo nhắc nhở&#10; * Hoạt động mạnh mẽ hơn AlarmManager trong việc xử lý Doze mode&#10; */&#10;public class ReminderWorker extends Worker {&#10;&#10;    private static final String TAG = &quot;ReminderWorker&quot;;&#10;&#10;    // Input data keys&#10;    public static final String KEY_REMINDER_ID = &quot;reminder_id&quot;;&#10;    public static final String KEY_TITLE = &quot;title&quot;;&#10;    public static final String KEY_MESSAGE = &quot;message&quot;;&#10;&#10;    public ReminderWorker(@NonNull Context context, @NonNull WorkerParameters workerParams) {&#10;        super(context, workerParams);&#10;    }&#10;&#10;    @NonNull&#10;    @Override&#10;    public Result doWork() {&#10;        Log.d(TAG, &quot;ReminderWorker started&quot;);&#10;&#10;        // Acquire wake lock để đảm bảo thiết bị không sleep&#10;        PowerManager powerManager = (PowerManager) getApplicationContext().getSystemService(Context.POWER_SERVICE);&#10;        PowerManager.WakeLock wakeLock = powerManager.newWakeLock(&#10;            PowerManager.PARTIAL_WAKE_LOCK,&#10;            &quot;HealthTips:ReminderWorker&quot;&#10;        );&#10;&#10;        try {&#10;            wakeLock.acquire(30 * 1000); // 30 giây timeout&#10;&#10;            String reminderId = getInputData().getString(KEY_REMINDER_ID);&#10;            String title = getInputData().getString(KEY_TITLE);&#10;            String message = getInputData().getString(KEY_MESSAGE);&#10;&#10;            Log.d(TAG, &quot;Processing reminder - ID: &quot; + reminderId + &quot;, Title: &quot; + title);&#10;&#10;            if (reminderId == null || title == null || message == null) {&#10;                Log.w(TAG, &quot;Missing reminder data&quot;);&#10;                return Result.failure();&#10;            }&#10;&#10;            // Hiển thị thông báo ngay lập tức&#10;            NotificationService.showReminderNotification(getApplicationContext(), title, message, reminderId);&#10;            Log.d(TAG, &quot;Notification shown successfully&quot;);&#10;&#10;            // Cập nhật trạng thái reminder&#10;            updateReminderStatus(reminderId);&#10;&#10;            return Result.success();&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error in ReminderWorker&quot;, e);&#10;            return Result.failure();&#10;        } finally {&#10;            if (wakeLock.isHeld()) {&#10;                wakeLock.release();&#10;            }&#10;        }&#10;    }&#10;&#10;    private void updateReminderStatus(String reminderId) {&#10;        ReminderRepository reminderRepository = new ReminderRepositoryImpl();&#10;        reminderRepository.getReminderById(reminderId, new ReminderRepository.RepositoryCallback&lt;Reminder&gt;() {&#10;            @Override&#10;            public void onSuccess(Reminder reminder) {&#10;                if (reminder != null) {&#10;                    Log.d(TAG, &quot;Successfully retrieved reminder for update: &quot; + reminder.getTitle());&#10;&#10;                    // Cập nhật lần thông báo cuối&#10;                    reminder.setLastNotified(System.currentTimeMillis());&#10;&#10;                    // Nếu không phải reminder lặp lại, đánh dấu là đã hoàn thành&#10;                    if (!reminder.isRepeating()) {&#10;                        reminder.setCompleted(true);&#10;                        reminder.setActive(false);&#10;                    }&#10;&#10;                    reminderRepository.updateReminder(reminder, new ReminderRepository.RepositoryCallback&lt;Void&gt;() {&#10;                        @Override&#10;                        public void onSuccess(Void result) {&#10;                            Log.d(TAG, &quot;Reminder status updated successfully&quot;);&#10;                        }&#10;&#10;                        @Override&#10;                        public void onError(String error) {&#10;                            Log.e(TAG, &quot;Failed to update reminder status: &quot; + error);&#10;                        }&#10;                    });&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                Log.e(TAG, &quot;Failed to retrieve reminder for update: &quot; + error);&#10;            }&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/bg_reminder_due.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/bg_reminder_due.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:shape=&quot;rectangle&quot;&gt;&#10;    &#10;    &lt;!-- Màu nền nhấn mạnh cho nhắc nhở đã đến giờ --&gt;&#10;    &lt;solid android:color=&quot;#1AFF5722&quot; /&gt;&#10;    &#10;    &lt;!-- Bo góc --&gt;&#10;    &lt;corners android:radius=&quot;8dp&quot; /&gt;&#10;    &#10;    &lt;!-- Đường viền đỏ cam để làm nổi bật --&gt;&#10;    &lt;stroke&#10;        android:width=&quot;2dp&quot;&#10;        android:color=&quot;@color/status_due&quot; /&gt;&#10;        &#10;&lt;/shape&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/bg_reminder_normal.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/bg_reminder_normal.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:shape=&quot;rectangle&quot;&gt;&#10;    &#10;    &lt;!-- Màu nền bình thường --&gt;&#10;    &lt;solid android:color=&quot;@android:color/transparent&quot; /&gt;&#10;    &#10;    &lt;!-- Bo góc --&gt;&#10;    &lt;corners android:radius=&quot;8dp&quot; /&gt;&#10;    &#10;    &lt;!-- Đường viền nhẹ --&gt;&#10;    &lt;stroke&#10;        android:width=&quot;1dp&quot;&#10;        android:color=&quot;@color/divider_color&quot; /&gt;&#10;        &#10;&lt;/shape&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/bg_repeat_type.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/bg_repeat_type.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:shape=&quot;rectangle&quot;&gt;&#10;    &#10;    &lt;!-- Màu nền trong suốt với tông màu chính --&gt;&#10;    &lt;solid android:color=&quot;#1A4CAF50&quot; /&gt;&#10;    &#10;    &lt;!-- Bo góc tròn --&gt;&#10;    &lt;corners android:radius=&quot;12dp&quot; /&gt;&#10;    &#10;    &lt;!-- Đường viền màu chính --&gt;&#10;    &lt;stroke&#10;        android:width=&quot;1dp&quot;&#10;        android:color=&quot;@color/primary_color&quot; /&gt;&#10;        &#10;&lt;/shape&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_add.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_add.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&#10;    android:tint=&quot;?attr/colorOnSurface&quot;&gt;&#10;  &lt;path&#10;      android:fillColor=&quot;@android:color/white&quot;&#10;      android:pathData=&quot;M19,13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_check.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_check.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&#10;    android:tint=&quot;?attr/colorOnPrimary&quot;&gt;&#10;  &lt;path&#10;      android:fillColor=&quot;@android:color/white&quot;&#10;      android:pathData=&quot;M9,16.17L4.83,12l-1.42,1.41L9,19 21,7l-1.41,-1.41z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_delete.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_delete.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&#10;    android:tint=&quot;?attr/colorOnSurface&quot;&gt;&#10;  &lt;path&#10;      android:fillColor=&quot;@android:color/white&quot;&#10;      android:pathData=&quot;M6,19c0,1.1 0.9,2 2,2h8c1.1,0 2,-0.9 2,-2V7H6v12zM19,4h-3.5l-1,-1h-5l-1,1H5v2h14V4z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_filter_list.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_filter_list.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&#10;    android:tint=&quot;?attr/colorOnSurface&quot;&gt;&#10;  &lt;path&#10;      android:fillColor=&quot;@android:color/white&quot;&#10;      android:pathData=&quot;M10,18h4v-2h-4v2zM3,6v2h18L21,6L3,6zM6,13h12v-2L6,11v2z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_filter_list_off.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_filter_list_off.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&#10;    android:tint=&quot;?attr/colorOnSurface&quot;&gt;&#10;  &lt;path&#10;      android:fillColor=&quot;@android:color/white&quot;&#10;      android:pathData=&quot;M10.83,8H21V6H8.83l2,2zM12.83,12H21v-2H10.83l2,2zM14.83,16H21v-2h-4.17l2,2zM2.81,2.81L1.39,4.22l4.44,4.44H3v2h4.83l2,2H6v2h5.83l2,2H10v2h5.83l1.95,1.95l1.41-1.41L2.81,2.81z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>