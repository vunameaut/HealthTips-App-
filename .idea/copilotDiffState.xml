<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Quyền truy cập Internet --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;&#10;    &lt;!-- Quyền cho thông báo và alarm --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.SCHEDULE_EXACT_ALARM&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.USE_EXACT_ALARM&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;&#10;&#10;    &lt;!-- Quyền tắt tối ưu hóa pin để hoạt động trong Doze mode --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS&quot; /&gt;&#10;&#10;    &lt;!-- Quyền foreground service cho WorkManager --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_logo&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_logo_foreground&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.Doan&quot;&#10;        android:name=&quot;androidx.multidex.MultiDexApplication&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;&#10;        &lt;!-- Activities --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.auth.LoginActivity&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.auth.ForgotPasswordActivity&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.auth.RegisterActivity&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.home.HomeActivity&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.category.detail.CategoryDetailListActivity&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.healthtip.detail.HealthTipDetailActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.HealthTipDetail&quot; /&gt;&#10;&#10;        &lt;!-- Debug Activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.debug.ReminderTestActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;Debug Thông Báo&quot; /&gt;&#10;&#10;        &lt;!-- Broadcast Receivers cho Reminder --&gt;&#10;        &lt;receiver&#10;            android:name=&quot;.receivers.ReminderBroadcastReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;receiver&#10;            android:name=&quot;.receivers.ReminderActionReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;!-- Receiver để khởi động lại reminder sau khi boot --&gt;&#10;        &lt;receiver&#10;            android:name=&quot;.receivers.BootReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter android:priority=&quot;1000&quot;&gt;&#10;                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MY_PACKAGE_REPLACED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.PACKAGE_REPLACED&quot; /&gt;&#10;                &lt;data android:scheme=&quot;package&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;&#10;        &lt;!-- Services --&gt;&#10;        &lt;service&#10;            android:name=&quot;.services.ReminderForegroundService&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:foregroundServiceType=&quot;specialUse&quot; /&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Quyền truy cập Internet --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;&#10;    &lt;!-- Quyền cho thông báo và alarm --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.SCHEDULE_EXACT_ALARM&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.USE_EXACT_ALARM&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;&#10;&#10;    &lt;!-- Quyền tắt tối ưu hóa pin để hoạt động trong Doze mode --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS&quot; /&gt;&#10;&#10;    &lt;!-- Quyền foreground service cho WorkManager --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#10;    &lt;!-- Quyền foreground service đặc biệt cho Android 14+ (API 34+) --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_SPECIAL_USE&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_logo&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_logo_foreground&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.Doan&quot;&#10;        android:name=&quot;androidx.multidex.MultiDexApplication&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;&#10;        &lt;!-- Activities --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.auth.LoginActivity&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.auth.ForgotPasswordActivity&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.auth.RegisterActivity&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.home.HomeActivity&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.category.detail.CategoryDetailListActivity&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.healthtip.detail.HealthTipDetailActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.HealthTipDetail&quot; /&gt;&#10;&#10;        &lt;!-- Debug Activity --&gt;&#10;        &lt;activity&#10;            android:name=&quot;.presentation.debug.ReminderTestActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;Debug Thông Báo&quot; /&gt;&#10;&#10;        &lt;!-- Broadcast Receivers cho Reminder --&gt;&#10;        &lt;receiver&#10;            android:name=&quot;.receivers.ReminderBroadcastReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;receiver&#10;            android:name=&quot;.receivers.ReminderActionReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;&#10;        &lt;!-- Receiver để khởi động lại reminder sau khi boot --&gt;&#10;        &lt;receiver&#10;            android:name=&quot;.receivers.BootReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter android:priority=&quot;1000&quot;&gt;&#10;                &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MY_PACKAGE_REPLACED&quot; /&gt;&#10;                &lt;action android:name=&quot;android.intent.action.PACKAGE_REPLACED&quot; /&gt;&#10;                &lt;data android:scheme=&quot;package&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;&#10;        &lt;!-- Services --&gt;&#10;        &lt;service&#10;            android:name=&quot;.services.ReminderForegroundService&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:foregroundServiceType=&quot;specialUse&quot;&gt;&#10;            &lt;!-- Thêm property cho specialUse theo yêu cầu Android 14+ --&gt;&#10;            &lt;property &#10;                android:name=&quot;android.app.PROPERTY_SPECIAL_USE_FGS_SUBTYPE&quot;&#10;                android:value=&quot;explanation_needed&quot; /&gt;&#10;        &lt;/service&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/data/Reminder.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/data/Reminder.java" />
              <option name="originalContent" value="package com.vhn.doan.data;&#10;&#10;import com.google.firebase.database.PropertyName;&#10;import com.google.firebase.database.ServerValue;&#10;import com.google.firebase.database.Exclude;&#10;import java.util.Calendar;&#10;import java.util.Date;&#10;import java.util.Map;&#10;&#10;/**&#10; * Model class đại diện cho một nhắc nhở sức khỏe&#10; * Được tối ưu hóa để tương thích với Firebase Realtime Database&#10; */&#10;public class Reminder {&#10;    private String id;&#10;    private String userId;&#10;    private String title;&#10;    private String description;&#10;    private Long reminderTime; // Sử dụng Long thay vì Date để tương thích Firebase&#10;    private int repeatType; // 0: Không lặp, 1: Hàng ngày, 2: Hàng tuần, 3: Hàng tháng&#10;    private boolean isActive;&#10;    private Long createdAt; // Sử dụng Long thay vì Date&#10;    private Long updatedAt; // Sử dụng Long thay vì Date&#10;    private String healthTipId; // ID của mẹo sức khỏe liên quan (nếu có)&#10;&#10;    /**&#10;     * Các method bổ sung cho Reminder&#10;     */&#10;&#10;    // Field bổ sung cho lastNotified và completed&#10;    private Long lastNotified;&#10;    private boolean completed = false;&#10;&#10;    // Enum cho loại lặp lại&#10;    public static class RepeatType {&#10;        public static final int NO_REPEAT = 0;&#10;        public static final int DAILY = 1;&#10;        public static final int WEEKLY = 2;&#10;        public static final int MONTHLY = 3;&#10;    }&#10;&#10;    // Constructor mặc định (cần thiết cho Firebase)&#10;    public Reminder() {&#10;        long currentTime = System.currentTimeMillis();&#10;        this.createdAt = currentTime;&#10;        this.updatedAt = currentTime;&#10;        this.isActive = true;&#10;        this.repeatType = RepeatType.NO_REPEAT;&#10;    }&#10;&#10;    // Constructor đầy đủ&#10;    public Reminder(String id, String userId, String title, String description,&#10;                   Date reminderTime, int repeatType, boolean isActive, String healthTipId) {&#10;        this.id = id;&#10;        this.userId = userId;&#10;        this.title = title;&#10;        this.description = description;&#10;        this.reminderTime = reminderTime != null ? reminderTime.getTime() : null;&#10;        this.repeatType = repeatType;&#10;        this.isActive = isActive;&#10;        this.healthTipId = healthTipId;&#10;        long currentTime = System.currentTimeMillis();&#10;        this.createdAt = currentTime;&#10;        this.updatedAt = currentTime;&#10;    }&#10;&#10;    // Getters với Firebase annotations&#10;    public String getId() {&#10;        return id;&#10;    }&#10;&#10;    public String getUserId() {&#10;        return userId;&#10;    }&#10;&#10;    public String getTitle() {&#10;        return title;&#10;    }&#10;&#10;    public String getDescription() {&#10;        return description;&#10;    }&#10;&#10;    // Firebase getter - trả về Long&#10;    public Long getReminderTime() {&#10;        return reminderTime;&#10;    }&#10;&#10;    // UI helper method - trả về Date&#10;    @Exclude&#10;    public Date getReminderTimeAsDate() {&#10;        return reminderTime != null ? new Date(reminderTime) : null;&#10;    }&#10;&#10;    public int getRepeatType() {&#10;        return repeatType;&#10;    }&#10;&#10;    @PropertyName(&quot;isActive&quot;)&#10;    public boolean isActive() {&#10;        return isActive;&#10;    }&#10;&#10;    // Firebase getter - trả về Long&#10;    public Long getCreatedAt() {&#10;        return createdAt;&#10;    }&#10;&#10;    // UI helper method - trả về Date&#10;    @Exclude&#10;    public Date getCreatedAtAsDate() {&#10;        return createdAt != null ? new Date(createdAt) : null;&#10;    }&#10;&#10;    // Firebase getter - trả về Long&#10;    public Long getUpdatedAt() {&#10;        return updatedAt;&#10;    }&#10;&#10;    // UI helper method - trả về Date&#10;    @Exclude&#10;    public Date getUpdatedAtAsDate() {&#10;        return updatedAt != null ? new Date(updatedAt) : null;&#10;    }&#10;&#10;    public String getHealthTipId() {&#10;        return healthTipId;&#10;    }&#10;&#10;    // Field bổ sung cho lastNotified và completed&#10;    public Long getLastNotified() {&#10;        return lastNotified;&#10;    }&#10;&#10;    public boolean isCompleted() {&#10;        return completed;&#10;    }&#10;&#10;    // Setters&#10;    public void setId(String id) {&#10;        this.id = id;&#10;    }&#10;&#10;    public void setUserId(String userId) {&#10;        this.userId = userId;&#10;    }&#10;&#10;    public void setTitle(String title) {&#10;        this.title = title;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    public void setDescription(String description) {&#10;        this.description = description;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    // Firebase setter - nhận Long&#10;    public void setReminderTime(Long reminderTime) {&#10;        this.reminderTime = reminderTime;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    // UI helper method - nhận Date&#10;    @Exclude&#10;    public void setReminderTimeFromDate(Date reminderTime) {&#10;        this.reminderTime = reminderTime != null ? reminderTime.getTime() : null;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    public void setRepeatType(int repeatType) {&#10;        this.repeatType = repeatType;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    @PropertyName(&quot;isActive&quot;)&#10;    public void setActive(boolean active) {&#10;        isActive = active;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    // Firebase setter - nhận Long&#10;    public void setCreatedAt(Long createdAt) {&#10;        this.createdAt = createdAt;&#10;    }&#10;&#10;    // UI helper method - nhận Date&#10;    @Exclude&#10;    public void setCreatedAtFromDate(Date createdAt) {&#10;        this.createdAt = createdAt != null ? createdAt.getTime() : null;&#10;    }&#10;&#10;    // Firebase setter - nhận Long&#10;    public void setUpdatedAt(Long updatedAt) {&#10;        this.updatedAt = updatedAt;&#10;    }&#10;&#10;    // UI helper method - nhận Date&#10;    @Exclude&#10;    public void setUpdatedAtFromDate(Date updatedAt) {&#10;        this.updatedAt = updatedAt != null ? updatedAt.getTime() : null;&#10;    }&#10;&#10;    public void setHealthTipId(String healthTipId) {&#10;        this.healthTipId = healthTipId;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    public void setLastNotified(Long lastNotified) {&#10;        this.lastNotified = lastNotified;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    public void setCompleted(boolean completed) {&#10;        this.completed = completed;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    /**&#10;     * Tính toán thời gian nhắc nhở tiếp theo dựa trên loại lặp lại&#10;     */&#10;    @Exclude&#10;    public Date getNextReminderTime() {&#10;        if (reminderTime == null || repeatType == RepeatType.NO_REPEAT) {&#10;            return getReminderTimeAsDate();&#10;        }&#10;&#10;        Calendar calendar = Calendar.getInstance();&#10;        calendar.setTime(getReminderTimeAsDate());&#10;&#10;        switch (repeatType) {&#10;            case RepeatType.DAILY:&#10;                calendar.add(Calendar.DAY_OF_MONTH, 1);&#10;                break;&#10;            case RepeatType.WEEKLY:&#10;                calendar.add(Calendar.WEEK_OF_YEAR, 1);&#10;                break;&#10;            case RepeatType.MONTHLY:&#10;                calendar.add(Calendar.MONTH, 1);&#10;                break;&#10;            default:&#10;                return getReminderTimeAsDate();&#10;        }&#10;&#10;        return calendar.getTime();&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra xem nhắc nhở có đã đến giờ hay chưa&#10;     */&#10;    @Exclude&#10;    public boolean isDue() {&#10;        if (reminderTime == null || !isActive) {&#10;            return false;&#10;        }&#10;        return System.currentTimeMillis() &gt;= reminderTime;&#10;    }&#10;&#10;    /**&#10;     * Lấy tên hiển thị cho loại lặp lại&#10;     */&#10;    @Exclude&#10;    public String getRepeatTypeDisplayName() {&#10;        switch (repeatType) {&#10;            case RepeatType.NO_REPEAT:&#10;                return &quot;Không lặp lại&quot;;&#10;            case RepeatType.DAILY:&#10;                return &quot;Hàng ngày&quot;;&#10;            case RepeatType.WEEKLY:&#10;                return &quot;Hàng tuần&quot;;&#10;            case RepeatType.MONTHLY:&#10;                return &quot;Hàng tháng&quot;;&#10;            default:&#10;                return &quot;Không xác định&quot;;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lấy Map để ghi vào Firebase với ServerValue.TIMESTAMP&#10;     */&#10;    @Exclude&#10;    public Map&lt;String, Object&gt; toFirebaseMap() {&#10;        Map&lt;String, Object&gt; map = new java.util.HashMap&lt;&gt;();&#10;        map.put(&quot;id&quot;, id);&#10;        map.put(&quot;userId&quot;, userId);&#10;        map.put(&quot;title&quot;, title);&#10;        map.put(&quot;description&quot;, description);&#10;        map.put(&quot;reminderTime&quot;, reminderTime);&#10;        map.put(&quot;repeatType&quot;, repeatType);&#10;        map.put(&quot;isActive&quot;, isActive);&#10;        map.put(&quot;healthTipId&quot;, healthTipId);&#10;        map.put(&quot;createdAt&quot;, createdAt != null ? createdAt : ServerValue.TIMESTAMP);&#10;        map.put(&quot;updatedAt&quot;, ServerValue.TIMESTAMP);&#10;        return map;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;Reminder{&quot; +&#10;                &quot;id='&quot; + id + '\'' +&#10;                &quot;, title='&quot; + title + '\'' +&#10;                &quot;, reminderTime=&quot; + getReminderTimeAsDate() +&#10;                &quot;, isActive=&quot; + isActive +&#10;                '}';&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.data;&#10;&#10;import com.google.firebase.database.PropertyName;&#10;import com.google.firebase.database.ServerValue;&#10;import com.google.firebase.database.Exclude;&#10;import java.util.Calendar;&#10;import java.util.Date;&#10;import java.util.Map;&#10;&#10;/**&#10; * Model class đại diện cho một nhắc nhở sức khỏe&#10; * Được tối ưu hóa để tương thích với Firebase Realtime Database&#10; */&#10;public class Reminder {&#10;    private String id;&#10;    private String userId;&#10;    private String title;&#10;    private String description;&#10;    private Long reminderTime; // Sử dụng Long thay vì Date để tương thích Firebase&#10;    private int repeatType; // 0: Không lặp, 1: Hàng ngày, 2: Hàng tuần, 3: Hàng tháng&#10;    private boolean isActive;&#10;    private Long createdAt; // Sử dụng Long thay vì Date&#10;    private Long updatedAt; // Sử dụng Long thay vì Date&#10;    private String healthTipId; // ID của mẹo sức khỏe liên quan (nếu có)&#10;&#10;    /**&#10;     * Các method bổ sung cho Reminder&#10;     */&#10;&#10;    // Field bổ sung cho lastNotified và completed&#10;    private Long lastNotified;&#10;    private boolean completed = false;&#10;&#10;    // Enum cho loại lặp lại&#10;    public static class RepeatType {&#10;        public static final int NO_REPEAT = 0;&#10;        public static final int DAILY = 1;&#10;        public static final int WEEKLY = 2;&#10;        public static final int MONTHLY = 3;&#10;    }&#10;&#10;    // Constructor mặc định (cần thiết cho Firebase)&#10;    public Reminder() {&#10;        long currentTime = System.currentTimeMillis();&#10;        this.createdAt = currentTime;&#10;        this.updatedAt = currentTime;&#10;        this.isActive = true;&#10;        this.repeatType = RepeatType.NO_REPEAT;&#10;    }&#10;&#10;    // Constructor đầy đủ&#10;    public Reminder(String id, String userId, String title, String description,&#10;                   Date reminderTime, int repeatType, boolean isActive, String healthTipId) {&#10;        this.id = id;&#10;        this.userId = userId;&#10;        this.title = title;&#10;        this.description = description;&#10;        this.reminderTime = reminderTime != null ? reminderTime.getTime() : null;&#10;        this.repeatType = repeatType;&#10;        this.isActive = isActive;&#10;        this.healthTipId = healthTipId;&#10;        long currentTime = System.currentTimeMillis();&#10;        this.createdAt = currentTime;&#10;        this.updatedAt = currentTime;&#10;    }&#10;&#10;    // Getters với Firebase annotations&#10;    public String getId() {&#10;        return id;&#10;    }&#10;&#10;    public String getUserId() {&#10;        return userId;&#10;    }&#10;&#10;    public String getTitle() {&#10;        return title;&#10;    }&#10;&#10;    public String getDescription() {&#10;        return description;&#10;    }&#10;&#10;    // Firebase getter - trả về Long&#10;    public Long getReminderTime() {&#10;        return reminderTime;&#10;    }&#10;&#10;    // UI helper method - trả về Date&#10;    @Exclude&#10;    public Date getReminderTimeAsDate() {&#10;        return reminderTime != null ? new Date(reminderTime) : null;&#10;    }&#10;&#10;    public int getRepeatType() {&#10;        return repeatType;&#10;    }&#10;&#10;    @PropertyName(&quot;isActive&quot;)&#10;    public boolean isActive() {&#10;        return isActive;&#10;    }&#10;&#10;    // Firebase getter - trả về Long&#10;    public Long getCreatedAt() {&#10;        return createdAt;&#10;    }&#10;&#10;    // UI helper method - trả về Date&#10;    @Exclude&#10;    public Date getCreatedAtAsDate() {&#10;        return createdAt != null ? new Date(createdAt) : null;&#10;    }&#10;&#10;    // Firebase getter - trả về Long&#10;    public Long getUpdatedAt() {&#10;        return updatedAt;&#10;    }&#10;&#10;    // UI helper method - trả về Date&#10;    @Exclude&#10;    public Date getUpdatedAtAsDate() {&#10;        return updatedAt != null ? new Date(updatedAt) : null;&#10;    }&#10;&#10;    public String getHealthTipId() {&#10;        return healthTipId;&#10;    }&#10;&#10;    // Field bổ sung cho lastNotified và completed&#10;    public Long getLastNotified() {&#10;        return lastNotified;&#10;    }&#10;&#10;    public boolean isCompleted() {&#10;        return completed;&#10;    }&#10;&#10;    // Setters&#10;    public void setId(String id) {&#10;        this.id = id;&#10;    }&#10;&#10;    public void setUserId(String userId) {&#10;        this.userId = userId;&#10;    }&#10;&#10;    public void setTitle(String title) {&#10;        this.title = title;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    public void setDescription(String description) {&#10;        this.description = description;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    // Firebase setter - nhận Long&#10;    public void setReminderTime(Long reminderTime) {&#10;        this.reminderTime = reminderTime;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    // UI helper method - nhận Date&#10;    @Exclude&#10;    public void setReminderTimeFromDate(Date reminderTime) {&#10;        this.reminderTime = reminderTime != null ? reminderTime.getTime() : null;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    public void setRepeatType(int repeatType) {&#10;        this.repeatType = repeatType;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    @PropertyName(&quot;isActive&quot;)&#10;    public void setActive(boolean active) {&#10;        isActive = active;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    // Firebase setter - nhận Long&#10;    public void setCreatedAt(Long createdAt) {&#10;        this.createdAt = createdAt;&#10;    }&#10;&#10;    // UI helper method - nhận Date&#10;    @Exclude&#10;    public void setCreatedAtFromDate(Date createdAt) {&#10;        this.createdAt = createdAt != null ? createdAt.getTime() : null;&#10;    }&#10;&#10;    // Firebase setter - nhận Long&#10;    public void setUpdatedAt(Long updatedAt) {&#10;        this.updatedAt = updatedAt;&#10;    }&#10;&#10;    // UI helper method - nhận Date&#10;    @Exclude&#10;    public void setUpdatedAtFromDate(Date updatedAt) {&#10;        this.updatedAt = updatedAt != null ? updatedAt.getTime() : null;&#10;    }&#10;&#10;    public void setHealthTipId(String healthTipId) {&#10;        this.healthTipId = healthTipId;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    public void setLastNotified(Long lastNotified) {&#10;        this.lastNotified = lastNotified;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    public void setCompleted(boolean completed) {&#10;        this.completed = completed;&#10;        this.updatedAt = System.currentTimeMillis();&#10;    }&#10;&#10;    /**&#10;     * Tính toán thời gian nhắc nhở tiếp theo dựa trên loại lặp lại&#10;     */&#10;    @Exclude&#10;    public Date getNextReminderTime() {&#10;        if (reminderTime == null || repeatType == RepeatType.NO_REPEAT) {&#10;            return getReminderTimeAsDate();&#10;        }&#10;&#10;        Calendar calendar = Calendar.getInstance();&#10;        calendar.setTime(getReminderTimeAsDate());&#10;&#10;        switch (repeatType) {&#10;            case RepeatType.DAILY:&#10;                calendar.add(Calendar.DAY_OF_MONTH, 1);&#10;                break;&#10;            case RepeatType.WEEKLY:&#10;                calendar.add(Calendar.WEEK_OF_YEAR, 1);&#10;                break;&#10;            case RepeatType.MONTHLY:&#10;                calendar.add(Calendar.MONTH, 1);&#10;                break;&#10;            default:&#10;                return getReminderTimeAsDate();&#10;        }&#10;&#10;        return calendar.getTime();&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra xem nhắc nhở có đã đến giờ hay chưa&#10;     */&#10;    @Exclude&#10;    public boolean isDue() {&#10;        if (reminderTime == null || !isActive) {&#10;            return false;&#10;        }&#10;        return System.currentTimeMillis() &gt;= reminderTime;&#10;    }&#10;&#10;    /**&#10;     * Lấy tên hiển thị cho loại lặp lại&#10;     */&#10;    @Exclude&#10;    public String getRepeatTypeDisplayName() {&#10;        switch (repeatType) {&#10;            case RepeatType.NO_REPEAT:&#10;                return &quot;Không lặp lại&quot;;&#10;            case RepeatType.DAILY:&#10;                return &quot;Hàng ngày&quot;;&#10;            case RepeatType.WEEKLY:&#10;                return &quot;Hàng tuần&quot;;&#10;            case RepeatType.MONTHLY:&#10;                return &quot;Hàng tháng&quot;;&#10;            default:&#10;                return &quot;Không xác định&quot;;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lấy Map để ghi vào Firebase với ServerValue.TIMESTAMP&#10;     */&#10;    @Exclude&#10;    public Map&lt;String, Object&gt; toFirebaseMap() {&#10;        Map&lt;String, Object&gt; map = new java.util.HashMap&lt;&gt;();&#10;        map.put(&quot;id&quot;, id);&#10;        map.put(&quot;userId&quot;, userId);&#10;        map.put(&quot;title&quot;, title);&#10;        map.put(&quot;description&quot;, description);&#10;        map.put(&quot;reminderTime&quot;, reminderTime);&#10;        map.put(&quot;repeatType&quot;, repeatType);&#10;        map.put(&quot;isActive&quot;, isActive);&#10;        map.put(&quot;healthTipId&quot;, healthTipId);&#10;        map.put(&quot;createdAt&quot;, createdAt != null ? createdAt : ServerValue.TIMESTAMP);&#10;        map.put(&quot;updatedAt&quot;, ServerValue.TIMESTAMP);&#10;        return map;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;Reminder{&quot; +&#10;                &quot;id='&quot; + id + '\'' +&#10;                &quot;, title='&quot; + title + '\'' +&#10;                &quot;, reminderTime=&quot; + getReminderTimeAsDate() +&#10;                &quot;, isActive=&quot; + isActive +&#10;                '}';&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra xem reminder có lặp lại hay không&#10;     */&#10;    @Exclude&#10;    public boolean isRepeating() {&#10;        return repeatType != RepeatType.NO_REPEAT;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/data/repository/RepositoryCallback.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/data/repository/RepositoryCallback.java" />
              <option name="updatedContent" value="package com.vhn.doan.data.repository;&#10;&#10;/**&#10; * Generic callback interface cho các thao tác repository&#10; * @param &lt;T&gt; Kiểu dữ liệu trả về&#10; */&#10;public interface RepositoryCallback&lt;T&gt; {&#10;    &#10;    /**&#10;     * Được gọi khi thao tác thành công&#10;     * @param result Kết quả trả về&#10;     */&#10;    void onSuccess(T result);&#10;    &#10;    /**&#10;     * Được gọi khi thao tác thất bại&#10;     * @param error Thông tin lỗi&#10;     */&#10;    void onError(String error);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/presentation/reminder/ReminderFragment.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/presentation/reminder/ReminderFragment.java" />
              <option name="originalContent" value="package com.vhn.doan.presentation.reminder;&#10;&#10;import android.app.AlertDialog;&#10;import android.content.BroadcastReceiver;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.content.IntentFilter;&#10;import android.os.Bundle;&#10;import android.view.LayoutInflater;&#10;import android.view.Menu;&#10;import android.view.MenuInflater;&#10;import android.view.MenuItem;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.Button;&#10;import android.widget.Toast;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.annotation.Nullable;&#10;import androidx.appcompat.widget.SearchView;&#10;import androidx.fragment.app.Fragment;&#10;import androidx.recyclerview.widget.LinearLayoutManager;&#10;import androidx.recyclerview.widget.RecyclerView;&#10;import androidx.swiperefreshlayout.widget.SwipeRefreshLayout;&#10;&#10;import com.google.android.material.floatingactionbutton.FloatingActionButton;&#10;import com.vhn.doan.R;&#10;import com.vhn.doan.data.Reminder;&#10;import com.vhn.doan.data.repository.ReminderRepository;&#10;import com.vhn.doan.data.repository.ReminderRepositoryImpl;&#10;import com.vhn.doan.utils.UserSessionManager;&#10;import com.vhn.doan.utils.PermissionHelper;&#10;import com.vhn.doan.presentation.base.BaseFragment;&#10;import com.vhn.doan.services.NotificationService;&#10;import com.vhn.doan.services.ReminderService;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;import javax.inject.Inject;&#10;&#10;/**&#10; * Fragment hiển thị danh sách nhắc nhở theo kiến trúc MVP&#10; */&#10;public class ReminderFragment extends BaseFragment implements ReminderContract.View {&#10;&#10;    private ReminderPresenter presenter;&#10;&#10;    // UI Components&#10;    private RecyclerView recyclerView;&#10;    private SwipeRefreshLayout swipeRefresh;&#10;    private FloatingActionButton fabAdd;&#10;    private View emptyStateView;&#10;    private View loadingView;&#10;&#10;    // Adapter&#10;    private ReminderAdapter adapter;&#10;&#10;    // Search&#10;    private SearchView searchView;&#10;    private boolean showActiveOnly = false;&#10;&#10;    // Permission handling&#10;    private boolean isPermissionChecked = false;&#10;&#10;    // Broadcast receiver cho reminder status changes&#10;    private BroadcastReceiver reminderStatusReceiver;&#10;&#10;    public static ReminderFragment newInstance() {&#10;        return new ReminderFragment();&#10;    }&#10;&#10;    @Override&#10;    public void onCreate(@Nullable Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        setHasOptionsMenu(true);&#10;&#10;        // Khởi tạo presenter thủ công thay vì dùng @Inject&#10;        initPresenter();&#10;    }&#10;&#10;    /**&#10;     * Khởi tạo presenter với các dependencies cần thiết&#10;     */&#10;    private void initPresenter() {&#10;        ReminderRepository reminderRepository = new ReminderRepositoryImpl();&#10;        UserSessionManager userSessionManager = new UserSessionManager(requireContext());&#10;        presenter = new ReminderPresenter(reminderRepository, userSessionManager);&#10;    }&#10;&#10;    @Nullable&#10;    @Override&#10;    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,&#10;                           @Nullable Bundle savedInstanceState) {&#10;        return inflater.inflate(R.layout.fragment_reminder, container, false);&#10;    }&#10;&#10;    @Override&#10;    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {&#10;        super.onViewCreated(view, savedInstanceState);&#10;&#10;        initViews(view);&#10;        setupRecyclerView();&#10;        setupSwipeRefresh();&#10;        setupFloatingActionButton();&#10;&#10;        // Attach presenter và start&#10;        presenter.attachView(this);&#10;        presenter.start();&#10;&#10;        // Kiểm tra và yêu cầu quyền cần thiết cho reminder&#10;        checkReminderPermissions();&#10;&#10;        // Đăng ký receiver để lắng nghe thay đổi trạng thái reminder&#10;        registerReminderStatusReceiver();&#10;    }&#10;&#10;    @Override&#10;    public void onDestroyView() {&#10;        super.onDestroyView();&#10;&#10;        // Hủy đăng ký broadcast receiver&#10;        unregisterReminderStatusReceiver();&#10;&#10;        if (presenter != null) {&#10;            presenter.detachView();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Đăng ký BroadcastReceiver để lắng nghe thay đổi trạng thái reminder&#10;     */&#10;    private void registerReminderStatusReceiver() {&#10;        if (getContext() == null) return;&#10;&#10;        reminderStatusReceiver = new BroadcastReceiver() {&#10;            @Override&#10;            public void onReceive(Context context, Intent intent) {&#10;                if (&quot;REMINDER_STATUS_CHANGED&quot;.equals(intent.getAction())) {&#10;                    handleReminderStatusChanged(intent);&#10;                }&#10;            }&#10;        };&#10;&#10;        IntentFilter filter = new IntentFilter(&quot;REMINDER_STATUS_CHANGED&quot;);&#10;&#10;        // Sửa lỗi SecurityException cho Android 13+&#10;        if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.TIRAMISU) {&#10;            // Android 13+ yêu cầu chỉ định RECEIVER_EXPORTED hoặc RECEIVER_NOT_EXPORTED&#10;            // Sử dụng RECEIVER_NOT_EXPORTED vì đây là broadcast nội bộ app&#10;            getContext().registerReceiver(reminderStatusReceiver, filter, Context.RECEIVER_NOT_EXPORTED);&#10;        } else {&#10;            // Android cũ hơn sử dụng cách đăng ký truyền thống&#10;            getContext().registerReceiver(reminderStatusReceiver, filter);&#10;        }&#10;&#10;        android.util.Log.d(&quot;ReminderFragment&quot;, &quot; Đã đăng ký lắng nghe broadcast reminder status&quot;);&#10;    }&#10;&#10;    /**&#10;     * Hủy đăng ký BroadcastReceiver&#10;     */&#10;    private void unregisterReminderStatusReceiver() {&#10;        if (getContext() != null &amp;&amp; reminderStatusReceiver != null) {&#10;            try {&#10;                getContext().unregisterReceiver(reminderStatusReceiver);&#10;                android.util.Log.d(&quot;ReminderFragment&quot;, &quot; Đã hủy đăng ký broadcast receiver&quot;);&#10;            } catch (IllegalArgumentException e) {&#10;                // Receiver đã được hủy đăng ký trước đó&#10;                android.util.Log.w(&quot;ReminderFragment&quot;, &quot;Receiver đã được hủy đăng ký: &quot; + e.getMessage());&#10;            }&#10;        }&#10;        reminderStatusReceiver = null;&#10;    }&#10;&#10;    /**&#10;     * Xử lý khi nhận được broadcast thay đổi trạng thái reminder&#10;     */&#10;    private void handleReminderStatusChanged(Intent intent) {&#10;        try {&#10;            String reminderId = intent.getStringExtra(&quot;reminder_id&quot;);&#10;            String reminderTitle = intent.getStringExtra(&quot;reminder_title&quot;);&#10;            boolean isActive = intent.getBooleanExtra(&quot;is_active&quot;, true);&#10;            String reason = intent.getStringExtra(&quot;reason&quot;);&#10;&#10;            android.util.Log.d(&quot;ReminderFragment&quot;, &quot; Nhận broadcast: &quot; + reminderId + &quot; - Active: &quot; + isActive + &quot; - Reason: &quot; + reason);&#10;&#10;            if (&quot;auto_disabled_after_notification&quot;.equals(reason)) {&#10;                // Hiển thị thông báo cho người dùng biết reminder đã tự động tắt&#10;                showSuccess(&quot;Nhắc nhở \&quot;&quot; + reminderTitle + &quot;\&quot; đã hoàn thành và tự động tắt&quot;);&#10;            }&#10;&#10;            // Refresh danh sách để cập nhật UI&#10;            if (presenter != null) {&#10;                presenter.refreshReminders();&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            android.util.Log.e(&quot;ReminderFragment&quot;, &quot;❌ Lỗi khi xử lý broadcast: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra quyền và bắt đầu load dữ liệu&#10;     */&#10;    private void checkPermissionsAndStart() {&#10;        if (isPermissionChecked) {&#10;            // Đã kiểm tra quyền rồi, chỉ start presenter&#10;            presenter.start();&#10;            return;&#10;        }&#10;&#10;        if (PermissionHelper.hasReminderPermissions(requireContext())) {&#10;            // Đã có đủ quyền&#10;            isPermissionChecked = true;&#10;            presenter.start();&#10;        } else {&#10;            // Chưa có đủ quyền, hiển thị dialog yêu cầu&#10;            showPermissionDialog();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Hiển thị dialog yêu cầu cấp quyền&#10;     */&#10;    private void showPermissionDialog() {&#10;        PermissionHelper.showPermissionExplanationDialog(this, new PermissionHelper.PermissionCallback() {&#10;            @Override&#10;            public void onPermissionsGranted() {&#10;                isPermissionChecked = true;&#10;                showSuccess(&quot;Đã cấp quyền thành công!&quot;);&#10;                presenter.start();&#10;            }&#10;&#10;            @Override&#10;            public void onPermissionsDenied(List&lt;String&gt; deniedPermissions) {&#10;                isPermissionChecked = true;&#10;                showWarningAboutMissingPermissions(deniedPermissions);&#10;                // Vẫn cho phép sử dụng app nhưng cảnh báo tính năng sẽ bị hạn chế&#10;                presenter.start();&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Hiển thị cảnh báo về quyền bị thiếu&#10;     */&#10;    private void showWarningAboutMissingPermissions(List&lt;String&gt; deniedPermissions) {&#10;        if (getContext() == null) return;&#10;&#10;        String message = &quot;Quyền thông báo chưa được cấp. Tính năng nhắc nhở có thể không hoạt động đúng:\n\n&quot; +&#10;                &quot;• Không thể hiển thị thông báo nhắc nhở\n\n&quot; +&#10;                &quot;Bạn có thể cấp quyền sau bằng cách vào Cài đặt &gt; Ứng dụng &gt; HealthTips &gt; Quyền&quot;;&#10;&#10;        new AlertDialog.Builder(getContext())&#10;                .setTitle(&quot;Cảnh báo quyền&quot;)&#10;                .setMessage(message)&#10;                .setPositiveButton(&quot;Đã hiểu&quot;, null)&#10;                .setNeutralButton(&quot;Thử lại&quot;, (dialog, which) -&gt; {&#10;                    isPermissionChecked = false;&#10;                    checkPermissionsAndStart();&#10;                })&#10;                .show();&#10;    }&#10;&#10;    @Override&#10;    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {&#10;        super.onRequestPermissionsResult(requestCode, permissions, grantResults);&#10;        PermissionHelper.handlePermissionResult(this, requestCode, permissions, grantResults);&#10;    }&#10;&#10;&#10;    @Override&#10;    public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {&#10;        inflater.inflate(R.menu.menu_reminder, menu);&#10;&#10;        MenuItem searchItem = menu.findItem(R.id.action_search);&#10;        searchView = (SearchView) searchItem.getActionView();&#10;&#10;        setupSearchView();&#10;        super.onCreateOptionsMenu(menu, inflater);&#10;    }&#10;&#10;    @Override&#10;    public boolean onOptionsItemSelected(@NonNull MenuItem item) {&#10;        int itemId = item.getItemId();&#10;&#10;        if (itemId == R.id.action_filter_active) {&#10;            showActiveOnly = !showActiveOnly;&#10;            updateFilterMenuItem(item);&#10;            presenter.filterReminders(showActiveOnly);&#10;            return true;&#10;        } else if (itemId == R.id.action_refresh) {&#10;            presenter.refreshReminders();&#10;            return true;&#10;        } else if (itemId == R.id.action_debug_notifications) {&#10;            openDebugActivity();&#10;            return true;&#10;        }&#10;&#10;        return super.onOptionsItemSelected(item);&#10;    }&#10;&#10;    @Override&#10;    protected void initViews(View view) {&#10;        recyclerView = view.findViewById(R.id.recycler_view_reminders);&#10;        swipeRefresh = view.findViewById(R.id.swipe_refresh_reminders);&#10;        fabAdd = view.findViewById(R.id.fab_add_reminder);&#10;        emptyStateView = view.findViewById(R.id.layout_empty_state);&#10;        loadingView = view.findViewById(R.id.layout_loading);&#10;&#10;        // Setup button trong Empty State&#10;        Button btnCreateFirstReminder = view.findViewById(R.id.btn_create_first_reminder);&#10;        if (btnCreateFirstReminder != null) {&#10;            btnCreateFirstReminder.setOnClickListener(v -&gt; presenter.createReminder());&#10;        }&#10;&#10;        // Setup Debug Button&#10;        com.google.android.material.button.MaterialButton btnDebug = view.findViewById(R.id.btn_debug_notifications);&#10;        if (btnDebug != null) {&#10;            btnDebug.setOnClickListener(v -&gt; openDebugActivity());&#10;        }&#10;    }&#10;&#10;    private void setupRecyclerView() {&#10;        adapter = new ReminderAdapter(new ArrayList&lt;&gt;(), new ReminderAdapter.OnReminderItemClickListener() {&#10;            @Override&#10;            public void onReminderClick(Reminder reminder) {&#10;                presenter.editReminder(reminder);&#10;            }&#10;&#10;            @Override&#10;            public void onToggleClick(Reminder reminder) {&#10;                presenter.toggleReminder(reminder);&#10;            }&#10;&#10;            @Override&#10;            public void onDeleteClick(Reminder reminder) {&#10;                presenter.deleteReminder(reminder);&#10;            }&#10;        });&#10;&#10;        recyclerView.setLayoutManager(new LinearLayoutManager(getContext()));&#10;        recyclerView.setAdapter(adapter);&#10;    }&#10;&#10;    private void setupSwipeRefresh() {&#10;        swipeRefresh.setOnRefreshListener(() -&gt; presenter.refreshReminders());&#10;        swipeRefresh.setColorSchemeResources(&#10;            R.color.primary_color,&#10;            R.color.primary_dark,&#10;            R.color.accent_color&#10;        );&#10;    }&#10;&#10;    private void setupFloatingActionButton() {&#10;        fabAdd.setOnClickListener(v -&gt; presenter.createReminder());&#10;    }&#10;&#10;    private void setupSearchView() {&#10;        if (searchView != null) {&#10;            searchView.setQueryHint(&quot;Tìm kiếm nhắc nhở...&quot;);&#10;            searchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() {&#10;                @Override&#10;                public boolean onQueryTextSubmit(String query) {&#10;                    presenter.searchReminders(query);&#10;                    return true;&#10;                }&#10;&#10;                @Override&#10;                public boolean onQueryTextChange(String newText) {&#10;                    presenter.searchReminders(newText);&#10;                    return true;&#10;                }&#10;            });&#10;        }&#10;    }&#10;&#10;    private void updateFilterMenuItem(MenuItem item) {&#10;        if (showActiveOnly) {&#10;            item.setTitle(&quot;Hiển thị tất cả&quot;);&#10;            item.setIcon(R.drawable.ic_filter_list);&#10;        } else {&#10;            item.setTitle(&quot;Chỉ hiển thị đang hoạt động&quot;);&#10;            item.setIcon(R.drawable.ic_filter_list_off);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Mở ReminderTestActivity để debug hệ thống thông báo&#10;     */&#10;    private void openDebugActivity() {&#10;        if (getContext() != null) {&#10;            android.content.Intent intent = new android.content.Intent(getContext(),&#10;                com.vhn.doan.presentation.debug.ReminderTestActivity.class);&#10;            startActivity(intent);&#10;        }&#10;    }&#10;&#10;    // Implement ReminderContract.View methods&#10;&#10;    @Override&#10;    public void showReminders(List&lt;Reminder&gt; reminders) {&#10;        if (adapter != null) {&#10;            adapter.updateReminders(reminders);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void showLoading() {&#10;        if (loadingView != null) {&#10;            loadingView.setVisibility(View.VISIBLE);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void hideLoading() {&#10;        if (loadingView != null) {&#10;            loadingView.setVisibility(View.GONE);&#10;        }&#10;&#10;        if (swipeRefresh != null &amp;&amp; swipeRefresh.isRefreshing()) {&#10;            swipeRefresh.setRefreshing(false);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void showError(String message) {&#10;        if (getContext() != null) {&#10;            Toast.makeText(getContext(), message, Toast.LENGTH_LONG).show();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void showSuccess(String message) {&#10;        if (getContext() != null) {&#10;            Toast.makeText(getContext(), message, Toast.LENGTH_SHORT).show();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void showReminderDialog(Reminder reminder) {&#10;        ReminderDialog dialog = new ReminderDialog(getContext(), reminder, new ReminderDialog.OnReminderDialogListener() {&#10;            @Override&#10;            public void onReminderSaved(Reminder savedReminder) {&#10;                presenter.saveReminder(savedReminder);&#10;            }&#10;&#10;            @Override&#10;            public void onReminderCanceled() {&#10;                // Không làm gì&#10;            }&#10;        });&#10;        dialog.show();&#10;    }&#10;&#10;    @Override&#10;    public void showDeleteConfirmDialog(Reminder reminder) {&#10;        if (getContext() == null) return;&#10;&#10;        new AlertDialog.Builder(getContext())&#10;            .setTitle(&quot;Xác nhận xóa&quot;)&#10;            .setMessage(&quot;Bạn có chắc chắn muốn xóa nhắc nhở \&quot;&quot; + reminder.getTitle() + &quot;\&quot;?&quot;)&#10;            .setPositiveButton(&quot;Xóa&quot;, (dialog, which) -&gt; {&#10;                if (presenter != null) {&#10;                    ((ReminderPresenter) presenter).confirmDeleteReminder(reminder);&#10;                }&#10;            })&#10;            .setNegativeButton(&quot;Hủy&quot;, null)&#10;            .show();&#10;    }&#10;&#10;    @Override&#10;    public void updateReminderItem(Reminder reminder) {&#10;        if (adapter != null) {&#10;            adapter.updateReminder(reminder);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void removeReminderItem(Reminder reminder) {&#10;        if (adapter != null) {&#10;            adapter.removeReminder(reminder);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void addReminderItem(Reminder reminder) {&#10;        if (adapter != null) {&#10;            adapter.addReminder(reminder);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void showEmptyState() {&#10;        if (emptyStateView != null) {&#10;            emptyStateView.setVisibility(View.VISIBLE);&#10;        }&#10;        if (recyclerView != null) {&#10;            recyclerView.setVisibility(View.GONE);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void hideEmptyState() {&#10;        if (emptyStateView != null) {&#10;            emptyStateView.setVisibility(View.GONE);&#10;        }&#10;        if (recyclerView != null) {&#10;            recyclerView.setVisibility(View.VISIBLE);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Method public để Activity có thể gọi khi click button từ XML&#10;     * Sửa lỗi: IllegalStateException khi click nút tạo reminder&#10;     */&#10;    public void onCreateReminderClick() {&#10;        if (presenter != null) {&#10;            presenter.createReminder();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * ✅ THÊM: Khôi phục lại tất cả nhắc nhở khi mở app&#10;     */&#10;    private void restoreRemindersIfNeeded() {&#10;        try {&#10;            android.util.Log.d(&quot;ReminderFragment&quot;, &quot; Khôi phục nhắc nhở khi mở fragment...&quot;);&#10;&#10;            // Sử dụng BootReceiver để khôi phục lại tất cả nhắc nhở&#10;            if (getContext() != null) {&#10;                com.vhn.doan.receivers.BootReceiver.rescheduleAllReminders(getContext());&#10;                android.util.Log.d(&quot;ReminderFragment&quot;, &quot;✅ Đã yêu cầu khôi phục nhắc nhở&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            android.util.Log.e(&quot;ReminderFragment&quot;, &quot;❌ Lỗi khi khôi phục nhắc nhở&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra và yêu cầu tất cả quyền cần thiết cho reminder&#10;     */&#10;    private void checkReminderPermissions() {&#10;        com.vhn.doan.utils.ReminderPermissionHelper.checkAndRequestAllPermissions(this,&#10;            new com.vhn.doan.utils.ReminderPermissionHelper.ReminderPermissionCallback() {&#10;                @Override&#10;                public void onAllPermissionsGranted() {&#10;                    android.util.Log.d(&quot;ReminderFragment&quot;, &quot;✅ Tất cả quyền đã được cấp&quot;);&#10;                    // Khởi động foreground service để duy trì hoạt động&#10;                    com.vhn.doan.utils.ReminderPermissionHelper.startReminderService(requireContext());&#10;                    showSuccess(&quot;Hệ thống nhắc nhở đã sẵn sàng!&quot;);&#10;                }&#10;&#10;                @Override&#10;                public void onNotificationPermissionResult(boolean granted) {&#10;                    if (granted) {&#10;                        android.util.Log.d(&quot;ReminderFragment&quot;, &quot;✅ Quyền thông báo đã được cấp&quot;);&#10;                        // Tiếp tục kiểm tra quyền khác&#10;                        checkReminderPermissions();&#10;                    } else {&#10;                        android.util.Log.w(&quot;ReminderFragment&quot;, &quot;❌ Quyền thông báo bị từ chối&quot;);&#10;                        showError(&quot;Cần cấp quyền thông báo để nhắc nhở hoạt động&quot;);&#10;                    }&#10;                }&#10;&#10;                @Override&#10;                public void onBatteryOptimizationDenied() {&#10;                    android.util.Log.w(&quot;ReminderFragment&quot;, &quot;⚠️ Battery optimization không được tắt&quot;);&#10;                    showError(&quot;Nhắc nhở có thể không hoạt động khi app bị tắt hoàn toàn&quot;);&#10;                    // Vẫn khởi động service&#10;                    com.vhn.doan.utils.ReminderPermissionHelper.startReminderService(requireContext());&#10;                }&#10;&#10;                @Override&#10;                public void onError(String error) {&#10;                    android.util.Log.e(&quot;ReminderFragment&quot;, &quot;❌ Lỗi khi kiểm tra quyền: &quot; + error);&#10;                    showError(&quot;Lỗi khi thiết lập quyền: &quot; + error);&#10;                }&#10;            });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.presentation.reminder;&#10;&#10;import android.app.AlertDialog;&#10;import android.content.BroadcastReceiver;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.content.IntentFilter;&#10;import android.os.Bundle;&#10;import android.view.LayoutInflater;&#10;import android.view.Menu;&#10;import android.view.MenuInflater;&#10;import android.view.MenuItem;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.Button;&#10;import android.widget.Toast;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.annotation.Nullable;&#10;import androidx.appcompat.widget.SearchView;&#10;import androidx.fragment.app.Fragment;&#10;import androidx.recyclerview.widget.LinearLayoutManager;&#10;import androidx.recyclerview.widget.RecyclerView;&#10;import androidx.swiperefreshlayout.widget.SwipeRefreshLayout;&#10;&#10;import com.google.android.material.floatingactionbutton.FloatingActionButton;&#10;import com.vhn.doan.R;&#10;import com.vhn.doan.data.Reminder;&#10;import com.vhn.doan.data.repository.ReminderRepository;&#10;import com.vhn.doan.data.repository.ReminderRepositoryImpl;&#10;import com.vhn.doan.utils.UserSessionManager;&#10;import com.vhn.doan.utils.PermissionHelper;&#10;import com.vhn.doan.presentation.base.BaseFragment;&#10;import com.vhn.doan.services.NotificationService;&#10;import com.vhn.doan.services.ReminderService;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;import javax.inject.Inject;&#10;&#10;/**&#10; * Fragment hiển thị danh sách nhắc nhở theo kiến trúc MVP&#10; */&#10;public class ReminderFragment extends BaseFragment implements ReminderContract.View {&#10;&#10;    private ReminderPresenter presenter;&#10;&#10;    // UI Components&#10;    private RecyclerView recyclerView;&#10;    private SwipeRefreshLayout swipeRefresh;&#10;    private FloatingActionButton fabAdd;&#10;    private View emptyStateView;&#10;    private View loadingView;&#10;&#10;    // Adapter&#10;    private ReminderAdapter adapter;&#10;&#10;    // Search&#10;    private SearchView searchView;&#10;    private boolean showActiveOnly = false;&#10;&#10;    // Permission handling&#10;    private boolean isPermissionChecked = false;&#10;&#10;    // Broadcast receiver cho reminder status changes&#10;    private BroadcastReceiver reminderStatusReceiver;&#10;&#10;    public static ReminderFragment newInstance() {&#10;        return new ReminderFragment();&#10;    }&#10;&#10;    @Override&#10;    public void onCreate(@Nullable Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;        setHasOptionsMenu(true);&#10;&#10;        // Khởi tạo presenter thủ công thay vì dùng @Inject&#10;        initPresenter();&#10;    }&#10;&#10;    /**&#10;     * Khởi tạo presenter với các dependencies cần thiết&#10;     */&#10;    private void initPresenter() {&#10;        ReminderRepository reminderRepository = new ReminderRepositoryImpl();&#10;        UserSessionManager userSessionManager = new UserSessionManager(requireContext());&#10;        presenter = new ReminderPresenter(reminderRepository, userSessionManager);&#10;    }&#10;&#10;    @Nullable&#10;    @Override&#10;    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,&#10;                           @Nullable Bundle savedInstanceState) {&#10;        return inflater.inflate(R.layout.fragment_reminder, container, false);&#10;    }&#10;&#10;    @Override&#10;    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {&#10;        super.onViewCreated(view, savedInstanceState);&#10;&#10;        initViews(view);&#10;        setupRecyclerView();&#10;        setupSwipeRefresh();&#10;        setupFloatingActionButton();&#10;&#10;        // Attach presenter và start&#10;        presenter.attachView(this);&#10;        presenter.start();&#10;&#10;        // Kiểm tra và yêu cầu quyền cần thiết cho reminder&#10;        checkReminderPermissions();&#10;&#10;        // Đăng ký receiver để lắng nghe thay đổi trạng thái reminder&#10;        registerReminderStatusReceiver();&#10;    }&#10;&#10;    @Override&#10;    public void onDestroyView() {&#10;        super.onDestroyView();&#10;&#10;        // Hủy đăng ký broadcast receiver&#10;        unregisterReminderStatusReceiver();&#10;&#10;        if (presenter != null) {&#10;            presenter.detachView();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Đăng ký BroadcastReceiver để lắng nghe thay đổi trạng thái reminder&#10;     */&#10;    private void registerReminderStatusReceiver() {&#10;        if (getContext() == null) return;&#10;&#10;        reminderStatusReceiver = new BroadcastReceiver() {&#10;            @Override&#10;            public void onReceive(Context context, Intent intent) {&#10;                if (&quot;REMINDER_STATUS_CHANGED&quot;.equals(intent.getAction())) {&#10;                    handleReminderStatusChanged(intent);&#10;                }&#10;            }&#10;        };&#10;&#10;        IntentFilter filter = new IntentFilter(&quot;REMINDER_STATUS_CHANGED&quot;);&#10;&#10;        // Sửa lỗi SecurityException cho Android 13+&#10;        if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.TIRAMISU) {&#10;            // Android 13+ yêu cầu chỉ định RECEIVER_EXPORTED hoặc RECEIVER_NOT_EXPORTED&#10;            // Sử dụng RECEIVER_NOT_EXPORTED vì đây là broadcast nội bộ app&#10;            getContext().registerReceiver(reminderStatusReceiver, filter, Context.RECEIVER_NOT_EXPORTED);&#10;        } else {&#10;            // Android cũ hơn sử dụng cách đăng ký truyền thống&#10;            getContext().registerReceiver(reminderStatusReceiver, filter);&#10;        }&#10;&#10;        android.util.Log.d(&quot;ReminderFragment&quot;, &quot; Đã đăng ký lắng nghe broadcast reminder status&quot;);&#10;    }&#10;&#10;    /**&#10;     * Hủy đăng ký BroadcastReceiver&#10;     */&#10;    private void unregisterReminderStatusReceiver() {&#10;        if (getContext() != null &amp;&amp; reminderStatusReceiver != null) {&#10;            try {&#10;                getContext().unregisterReceiver(reminderStatusReceiver);&#10;                android.util.Log.d(&quot;ReminderFragment&quot;, &quot; Đã hủy đăng ký broadcast receiver&quot;);&#10;            } catch (IllegalArgumentException e) {&#10;                // Receiver đã được hủy đăng ký trước đó&#10;                android.util.Log.w(&quot;ReminderFragment&quot;, &quot;Receiver đã được hủy đăng ký: &quot; + e.getMessage());&#10;            }&#10;        }&#10;        reminderStatusReceiver = null;&#10;    }&#10;&#10;    /**&#10;     * Xử lý khi nhận được broadcast thay đổi trạng thái reminder&#10;     */&#10;    private void handleReminderStatusChanged(Intent intent) {&#10;        try {&#10;            String reminderId = intent.getStringExtra(&quot;reminder_id&quot;);&#10;            String reminderTitle = intent.getStringExtra(&quot;reminder_title&quot;);&#10;            boolean isActive = intent.getBooleanExtra(&quot;is_active&quot;, true);&#10;            String reason = intent.getStringExtra(&quot;reason&quot;);&#10;&#10;            android.util.Log.d(&quot;ReminderFragment&quot;, &quot; Nhận broadcast: &quot; + reminderId + &quot; - Active: &quot; + isActive + &quot; - Reason: &quot; + reason);&#10;&#10;            if (&quot;auto_disabled_after_notification&quot;.equals(reason)) {&#10;                // Hiển thị thông báo cho người dùng biết reminder đã tự động tắt&#10;                showSuccess(&quot;Nhắc nhở \&quot;&quot; + reminderTitle + &quot;\&quot; đã hoàn thành và tự động tắt&quot;);&#10;            }&#10;&#10;            // Refresh danh sách để cập nhật UI&#10;            if (presenter != null) {&#10;                presenter.refreshReminders();&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            android.util.Log.e(&quot;ReminderFragment&quot;, &quot;❌ Lỗi khi xử lý broadcast: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra quyền và bắt đầu load dữ liệu&#10;     */&#10;    private void checkPermissionsAndStart() {&#10;        if (isPermissionChecked) {&#10;            // Đã kiểm tra quyền rồi, chỉ start presenter&#10;            presenter.start();&#10;            return;&#10;        }&#10;&#10;        if (PermissionHelper.hasReminderPermissions(requireContext())) {&#10;            // Đã có đủ quyền&#10;            isPermissionChecked = true;&#10;            presenter.start();&#10;        } else {&#10;            // Chưa có đủ quyền, hiển thị dialog yêu cầu&#10;            showPermissionDialog();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Hiển thị dialog yêu cầu cấp quyền&#10;     */&#10;    private void showPermissionDialog() {&#10;        PermissionHelper.showPermissionExplanationDialog(this, new PermissionHelper.PermissionCallback() {&#10;            @Override&#10;            public void onPermissionsGranted() {&#10;                isPermissionChecked = true;&#10;                showSuccess(&quot;Đã cấp quyền thành công!&quot;);&#10;                presenter.start();&#10;            }&#10;&#10;            @Override&#10;            public void onPermissionsDenied(List&lt;String&gt; deniedPermissions) {&#10;                isPermissionChecked = true;&#10;                showWarningAboutMissingPermissions(deniedPermissions);&#10;                // Vẫn cho phép sử dụng app nhưng cảnh báo tính năng sẽ bị hạn chế&#10;                presenter.start();&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Hiển thị cảnh báo về quyền bị thiếu&#10;     */&#10;    private void showWarningAboutMissingPermissions(List&lt;String&gt; deniedPermissions) {&#10;        if (getContext() == null) return;&#10;&#10;        String message = &quot;Quyền thông báo chưa được cấp. Tính năng nhắc nhở có thể không hoạt động đúng:\n\n&quot; +&#10;                &quot;• Không thể hiển thị thông báo nhắc nhở\n\n&quot; +&#10;                &quot;Bạn có thể cấp quyền sau bằng cách vào Cài đặt &gt; Ứng dụng &gt; HealthTips &gt; Quyền&quot;;&#10;&#10;        new AlertDialog.Builder(getContext())&#10;                .setTitle(&quot;Cảnh báo quyền&quot;)&#10;                .setMessage(message)&#10;                .setPositiveButton(&quot;Đã hiểu&quot;, null)&#10;                .setNeutralButton(&quot;Thử lại&quot;, (dialog, which) -&gt; {&#10;                    isPermissionChecked = false;&#10;                    checkPermissionsAndStart();&#10;                })&#10;                .show();&#10;    }&#10;&#10;    @Override&#10;    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {&#10;        super.onRequestPermissionsResult(requestCode, permissions, grantResults);&#10;        PermissionHelper.handlePermissionResult(this, requestCode, permissions, grantResults);&#10;    }&#10;&#10;&#10;    @Override&#10;    public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {&#10;        inflater.inflate(R.menu.menu_reminder, menu);&#10;&#10;        MenuItem searchItem = menu.findItem(R.id.action_search);&#10;        searchView = (SearchView) searchItem.getActionView();&#10;&#10;        setupSearchView();&#10;        super.onCreateOptionsMenu(menu, inflater);&#10;    }&#10;&#10;    @Override&#10;    public boolean onOptionsItemSelected(@NonNull MenuItem item) {&#10;        int itemId = item.getItemId();&#10;&#10;        if (itemId == R.id.action_filter_active) {&#10;            showActiveOnly = !showActiveOnly;&#10;            updateFilterMenuItem(item);&#10;            presenter.filterReminders(showActiveOnly);&#10;            return true;&#10;        } else if (itemId == R.id.action_refresh) {&#10;            presenter.refreshReminders();&#10;            return true;&#10;        } else if (itemId == R.id.action_debug_notifications) {&#10;            openDebugActivity();&#10;            return true;&#10;        }&#10;&#10;        return super.onOptionsItemSelected(item);&#10;    }&#10;&#10;    @Override&#10;    protected void initViews(View view) {&#10;        recyclerView = view.findViewById(R.id.recycler_view_reminders);&#10;        swipeRefresh = view.findViewById(R.id.swipe_refresh_reminders);&#10;        fabAdd = view.findViewById(R.id.fab_add_reminder);&#10;        emptyStateView = view.findViewById(R.id.layout_empty_state);&#10;        loadingView = view.findViewById(R.id.layout_loading);&#10;&#10;        // Setup button trong Empty State&#10;        Button btnCreateFirstReminder = view.findViewById(R.id.btn_create_first_reminder);&#10;        if (btnCreateFirstReminder != null) {&#10;            btnCreateFirstReminder.setOnClickListener(v -&gt; presenter.createReminder());&#10;        }&#10;&#10;        // Setup Debug Button&#10;        com.google.android.material.button.MaterialButton btnDebug = view.findViewById(R.id.btn_debug_notifications);&#10;        if (btnDebug != null) {&#10;            btnDebug.setOnClickListener(v -&gt; openDebugActivity());&#10;        }&#10;    }&#10;&#10;    private void setupRecyclerView() {&#10;        adapter = new ReminderAdapter(new ArrayList&lt;&gt;(), new ReminderAdapter.OnReminderItemClickListener() {&#10;            @Override&#10;            public void onReminderClick(Reminder reminder) {&#10;                presenter.editReminder(reminder);&#10;            }&#10;&#10;            @Override&#10;            public void onToggleClick(Reminder reminder) {&#10;                presenter.toggleReminder(reminder);&#10;            }&#10;&#10;            @Override&#10;            public void onDeleteClick(Reminder reminder) {&#10;                presenter.deleteReminder(reminder);&#10;            }&#10;        });&#10;&#10;        recyclerView.setLayoutManager(new LinearLayoutManager(getContext()));&#10;        recyclerView.setAdapter(adapter);&#10;    }&#10;&#10;    private void setupSwipeRefresh() {&#10;        swipeRefresh.setOnRefreshListener(() -&gt; presenter.refreshReminders());&#10;        swipeRefresh.setColorSchemeResources(&#10;            R.color.primary_color,&#10;            R.color.primary_dark,&#10;            R.color.accent_color&#10;        );&#10;    }&#10;&#10;    private void setupFloatingActionButton() {&#10;        fabAdd.setOnClickListener(v -&gt; presenter.createReminder());&#10;    }&#10;&#10;    private void setupSearchView() {&#10;        if (searchView != null) {&#10;            searchView.setQueryHint(&quot;Tìm kiếm nhắc nhở...&quot;);&#10;            searchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() {&#10;                @Override&#10;                public boolean onQueryTextSubmit(String query) {&#10;                    presenter.searchReminders(query);&#10;                    return true;&#10;                }&#10;&#10;                @Override&#10;                public boolean onQueryTextChange(String newText) {&#10;                    presenter.searchReminders(newText);&#10;                    return true;&#10;                }&#10;            });&#10;        }&#10;    }&#10;&#10;    private void updateFilterMenuItem(MenuItem item) {&#10;        if (showActiveOnly) {&#10;            item.setTitle(&quot;Hiển thị tất cả&quot;);&#10;            item.setIcon(R.drawable.ic_filter_list);&#10;        } else {&#10;            item.setTitle(&quot;Chỉ hiển thị đang hoạt động&quot;);&#10;            item.setIcon(R.drawable.ic_filter_list_off);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Mở ReminderTestActivity để debug hệ thống thông báo&#10;     */&#10;    private void openDebugActivity() {&#10;        if (getContext() != null) {&#10;            android.content.Intent intent = new android.content.Intent(getContext(),&#10;                com.vhn.doan.presentation.debug.ReminderTestActivity.class);&#10;            startActivity(intent);&#10;        }&#10;    }&#10;&#10;    // Implement ReminderContract.View methods&#10;&#10;    @Override&#10;    public void showReminders(List&lt;Reminder&gt; reminders) {&#10;        if (adapter != null) {&#10;            adapter.updateReminders(reminders);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void showLoading() {&#10;        if (loadingView != null) {&#10;            loadingView.setVisibility(View.VISIBLE);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void hideLoading() {&#10;        if (loadingView != null) {&#10;            loadingView.setVisibility(View.GONE);&#10;        }&#10;&#10;        if (swipeRefresh != null &amp;&amp; swipeRefresh.isRefreshing()) {&#10;            swipeRefresh.setRefreshing(false);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void showError(String message) {&#10;        if (getContext() != null) {&#10;            Toast.makeText(getContext(), message, Toast.LENGTH_LONG).show();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void showSuccess(String message) {&#10;        if (getContext() != null) {&#10;            Toast.makeText(getContext(), message, Toast.LENGTH_SHORT).show();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void showReminderDialog(Reminder reminder) {&#10;        ReminderDialog dialog = new ReminderDialog(getContext(), reminder, new ReminderDialog.OnReminderDialogListener() {&#10;            @Override&#10;            public void onReminderSaved(Reminder savedReminder) {&#10;                presenter.saveReminder(savedReminder);&#10;            }&#10;&#10;            @Override&#10;            public void onReminderCanceled() {&#10;                // Không làm gì&#10;            }&#10;        });&#10;        dialog.show();&#10;    }&#10;&#10;    @Override&#10;    public void showDeleteConfirmDialog(Reminder reminder) {&#10;        if (getContext() == null) return;&#10;&#10;        new AlertDialog.Builder(getContext())&#10;            .setTitle(&quot;Xác nhận xóa&quot;)&#10;            .setMessage(&quot;Bạn có chắc chắn muốn xóa nhắc nhở \&quot;&quot; + reminder.getTitle() + &quot;\&quot;?&quot;)&#10;            .setPositiveButton(&quot;Xóa&quot;, (dialog, which) -&gt; {&#10;                if (presenter != null) {&#10;                    ((ReminderPresenter) presenter).confirmDeleteReminder(reminder);&#10;                }&#10;            })&#10;            .setNegativeButton(&quot;Hủy&quot;, null)&#10;            .show();&#10;    }&#10;&#10;    @Override&#10;    public void updateReminderItem(Reminder reminder) {&#10;        if (adapter != null) {&#10;            adapter.updateReminder(reminder);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void removeReminderItem(Reminder reminder) {&#10;        if (adapter != null) {&#10;            adapter.removeReminder(reminder);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void addReminderItem(Reminder reminder) {&#10;        if (adapter != null) {&#10;            adapter.addReminder(reminder);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void showEmptyState() {&#10;        if (emptyStateView != null) {&#10;            emptyStateView.setVisibility(View.VISIBLE);&#10;        }&#10;        if (recyclerView != null) {&#10;            recyclerView.setVisibility(View.GONE);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void hideEmptyState() {&#10;        if (emptyStateView != null) {&#10;            emptyStateView.setVisibility(View.GONE);&#10;        }&#10;        if (recyclerView != null) {&#10;            recyclerView.setVisibility(View.VISIBLE);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Method public để Activity có thể gọi khi click button từ XML&#10;     * Sửa lỗi: IllegalStateException khi click nút tạo reminder&#10;     */&#10;    public void onCreateReminderClick() {&#10;        if (presenter != null) {&#10;            presenter.createReminder();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * ✅ THÊM: Khôi phục lại tất cả nhắc nhở khi mở app&#10;     */&#10;    private void restoreRemindersIfNeeded() {&#10;        try {&#10;            android.util.Log.d(&quot;ReminderFragment&quot;, &quot; Khôi phục nhắc nhở khi mở fragment...&quot;);&#10;&#10;            // Sử dụng BootReceiver để khôi phục lại tất cả nhắc nhở&#10;            if (getContext() != null) {&#10;                com.vhn.doan.receivers.BootReceiver.rescheduleAllReminders(getContext());&#10;                android.util.Log.d(&quot;ReminderFragment&quot;, &quot;✅ Đã yêu cầu khôi phục nhắc nhở&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            android.util.Log.e(&quot;ReminderFragment&quot;, &quot;❌ Lỗi khi khôi phục nhắc nhở&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra và yêu cầu tất cả quyền cần thiết cho reminder&#10;     */&#10;    private void checkReminderPermissions() {&#10;        com.vhn.doan.utils.ReminderPermissionHelper.checkAndRequestAllPermissions(this,&#10;            new com.vhn.doan.utils.ReminderPermissionHelper.ReminderPermissionCallback() {&#10;                @Override&#10;                public void onAllPermissionsGranted() {&#10;                    android.util.Log.d(&quot;ReminderFragment&quot;, &quot;✅ Tất cả quyền đã được cấp&quot;);&#10;                    // Khởi động foreground service để duy trì hoạt động&#10;                    com.vhn.doan.utils.ReminderPermissionHelper.startReminderService(requireContext());&#10;                    showSuccess(&quot;Hệ thống nhắc nhở đã sẵn sàng!&quot;);&#10;                }&#10;&#10;                @Override&#10;                public void onNotificationPermissionResult(boolean granted) {&#10;                    if (granted) {&#10;                        android.util.Log.d(&quot;ReminderFragment&quot;, &quot;✅ Quyền thông báo đã được cấp&quot;);&#10;                        // Tiếp tục kiểm tra quyền khác&#10;                        checkReminderPermissions();&#10;                    } else {&#10;                        android.util.Log.w(&quot;ReminderFragment&quot;, &quot;❌ Quyền thông báo bị từ chối&quot;);&#10;                        showError(&quot;Cần cấp quyền thông báo để nhắc nhở hoạt động&quot;);&#10;                    }&#10;                }&#10;&#10;                @Override&#10;                public void onBatteryOptimizationDenied() {&#10;                    android.util.Log.w(&quot;ReminderFragment&quot;, &quot;⚠️ Battery optimization không được tắt&quot;);&#10;                    showError(&quot;Nhắc nhở có thể không hoạt động khi app bị tắt hoàn toàn&quot;);&#10;                    // Vẫn khởi động service&#10;                    com.vhn.doan.utils.ReminderPermissionHelper.startReminderService(requireContext());&#10;                }&#10;&#10;                @Override&#10;                public void onError(String error) {&#10;                    android.util.Log.e(&quot;ReminderFragment&quot;, &quot;❌ Lỗi khi kiểm tra quyền: &quot; + error);&#10;                    showError(&quot;Lỗi khi thiết lập quyền: &quot; + error);&#10;                }&#10;            });&#10;    }&#10;&#10;    @Override&#10;    protected void setupListeners() {&#10;        // Setup listeners cho các UI components&#10;        setupSwipeRefresh();&#10;        setupFloatingActionButton();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/presentation/reminder/ReminderPresenter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/presentation/reminder/ReminderPresenter.java" />
              <option name="originalContent" value="package com.vhn.doan.presentation.reminder;&#10;&#10;import com.vhn.doan.data.Reminder;&#10;import com.vhn.doan.data.repository.ReminderRepository;&#10;import com.vhn.doan.presentation.base.BasePresenter;&#10;import com.vhn.doan.utils.UserSessionManager;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;import javax.inject.Inject;&#10;&#10;/**&#10; * Presenter cho chức năng Reminder theo kiến trúc MVP&#10; */&#10;public class ReminderPresenter extends BasePresenter&lt;ReminderContract.View&gt; implements ReminderContract.Presenter {&#10;&#10;    private ReminderRepository reminderRepository;&#10;    private UserSessionManager userSessionManager;&#10;&#10;    private List&lt;Reminder&gt; allReminders;&#10;    private List&lt;Reminder&gt; filteredReminders;&#10;    private boolean isLoading = false;&#10;    private String currentSearchQuery = &quot;&quot;;&#10;    private boolean showActiveOnly = false;&#10;&#10;    @Inject&#10;    public ReminderPresenter(ReminderRepository reminderRepository, UserSessionManager userSessionManager) {&#10;        this.reminderRepository = reminderRepository;&#10;        this.userSessionManager = userSessionManager;&#10;        this.allReminders = new ArrayList&lt;&gt;();&#10;        this.filteredReminders = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public void attachView(ReminderContract.View view) {&#10;        super.attachView(view);&#10;    }&#10;&#10;    @Override&#10;    public void start() {&#10;        loadReminders();&#10;    }&#10;&#10;    @Override&#10;    public void loadReminders() {&#10;        if (isLoading) {&#10;            return;&#10;        }&#10;&#10;        if (!isViewAttached()) {&#10;            return;&#10;        }&#10;&#10;        String userId = userSessionManager.getCurrentUserId();&#10;        if (userId == null || userId.isEmpty()) {&#10;            view.showError(&quot;Vui lòng đăng nhập để xem nhắc nhở&quot;);&#10;            return;&#10;        }&#10;&#10;        isLoading = true;&#10;        view.showLoading();&#10;&#10;        reminderRepository.getUserReminders(userId, new ReminderRepository.RepositoryCallback&lt;List&lt;Reminder&gt;&gt;() {&#10;            @Override&#10;            public void onSuccess(List&lt;Reminder&gt; reminders) {&#10;                isLoading = false;&#10;                if (isViewAttached()) {&#10;                    view.hideLoading();&#10;                    allReminders.clear();&#10;                    allReminders.addAll(reminders);&#10;&#10;                    applyFiltersAndSearch();&#10;&#10;                    if (filteredReminders.isEmpty()) {&#10;                        view.showEmptyState();&#10;                    } else {&#10;                        view.hideEmptyState();&#10;                        view.showReminders(filteredReminders);&#10;                    }&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                isLoading = false;&#10;                if (isViewAttached()) {&#10;                    view.hideLoading();&#10;                    view.showError(&quot;Lỗi khi tải nhắc nhở: &quot; + error);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void createReminder() {&#10;        if (isViewAttached()) {&#10;            view.showReminderDialog(null);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void editReminder(Reminder reminder) {&#10;        if (isViewAttached() &amp;&amp; reminder != null) {&#10;            view.showReminderDialog(reminder);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void deleteReminder(Reminder reminder) {&#10;        if (isViewAttached() &amp;&amp; reminder != null) {&#10;            view.showDeleteConfirmDialog(reminder);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void saveReminder(Reminder reminder) {&#10;        if (!isViewAttached() || reminder == null) {&#10;            return;&#10;        }&#10;&#10;        String userId = userSessionManager.getCurrentUserId();&#10;        if (userId == null || userId.isEmpty()) {&#10;            view.showError(&quot;Vui lòng đăng nhập để lưu nhắc nhở&quot;);&#10;            return;&#10;        }&#10;&#10;        reminder.setUserId(userId);&#10;        view.showLoading();&#10;&#10;        if (reminder.getId() == null || reminder.getId().isEmpty()) {&#10;            // Tạo mới&#10;            reminderRepository.addReminder(reminder, new ReminderRepository.RepositoryCallback&lt;String&gt;() {&#10;                @Override&#10;                public void onSuccess(String reminderId) {&#10;                    if (isViewAttached()) {&#10;                        view.hideLoading();&#10;                        view.showSuccess(&quot;Tạo nhắc nhở thành công&quot;);&#10;                        reminder.setId(reminderId);&#10;                        addReminderToList(reminder);&#10;&#10;                        // ✅ THÊM: Lên lịch thông báo cho nhắc nhở mới&#10;                        scheduleReminderNotification(reminder);&#10;                    }&#10;                }&#10;&#10;                @Override&#10;                public void onError(String error) {&#10;                    if (isViewAttached()) {&#10;                        view.hideLoading();&#10;                        view.showError(&quot;Lỗi khi tạo nhắc nhở: &quot; + error);&#10;                    }&#10;                }&#10;            });&#10;        } else {&#10;            // Cập nhật&#10;            reminderRepository.updateReminder(reminder, new ReminderRepository.RepositoryCallback&lt;Void&gt;() {&#10;                @Override&#10;                public void onSuccess(Void result) {&#10;                    if (isViewAttached()) {&#10;                        view.hideLoading();&#10;                        view.showSuccess(&quot;Cập nhật nhắc nhở thành công&quot;);&#10;                        updateReminderInList(reminder);&#10;&#10;                        // ✅ THÊM: Cập nhật lịch thông báo cho nhắc nhở đã chỉnh sửa&#10;                        scheduleReminderNotification(reminder);&#10;                    }&#10;                }&#10;&#10;                @Override&#10;                public void onError(String error) {&#10;                    if (isViewAttached()) {&#10;                        view.hideLoading();&#10;                        view.showError(&quot;Lỗi khi cập nhật nhắc nhở: &quot; + error);&#10;                    }&#10;                }&#10;            });&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void toggleReminder(Reminder reminder) {&#10;        if (!isViewAttached() || reminder == null) {&#10;            return;&#10;        }&#10;&#10;        boolean newStatus = !reminder.isActive();&#10;&#10;        reminderRepository.toggleReminder(reminder.getId(), newStatus, new ReminderRepository.RepositoryCallback&lt;Void&gt;() {&#10;            @Override&#10;            public void onSuccess(Void result) {&#10;                if (isViewAttached()) {&#10;                    reminder.setActive(newStatus);&#10;                    updateReminderInList(reminder);&#10;&#10;                    String message = newStatus ? &quot;Đã bật nhắc nhở&quot; : &quot;Đã tắt nhắc nhở&quot;;&#10;                    view.showSuccess(message);&#10;&#10;                    // ✅ THÊM: Cập nhật lịch thông báo khi bật/tắt&#10;                    scheduleReminderNotification(reminder);&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                if (isViewAttached()) {&#10;                    view.showError(&quot;Lỗi khi thay đổi trạng thái nhắc nhở: &quot; + error);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * ✅ THÊM: Method để lên lịch thông báo cho nhắc nhở&#10;     */&#10;    private void scheduleReminderNotification(Reminder reminder) {&#10;        if (!isViewAttached() || reminder == null) {&#10;            return;&#10;        }&#10;&#10;        // Lấy context từ view để tạo ReminderService&#10;        android.content.Context context = getContextFromView();&#10;        if (context == null) {&#10;            android.util.Log.w(&quot;ReminderPresenter&quot;, &quot;Không thể lấy context để schedule reminder&quot;);&#10;            return;&#10;        }&#10;&#10;        try {&#10;            com.vhn.doan.services.ReminderService reminderService = new com.vhn.doan.services.ReminderService(context);&#10;&#10;            if (reminder.isActive()) {&#10;                // Lên lịch thông báo nếu reminder đang bật&#10;                reminderService.scheduleReminder(reminder);&#10;                android.util.Log.d(&quot;ReminderPresenter&quot;, &quot;✅ Đã lên lịch thông báo cho reminder: &quot; + reminder.getTitle());&#10;            } else {&#10;                // Hủy thông báo nếu reminder bị tắt - cần thêm context&#10;                ReminderService.cancelReminder(getContextFromView(), reminder.getId());&#10;                android.util.Log.d(&quot;ReminderPresenter&quot;, &quot;❌ Đã hủy thông báo cho reminder: &quot; + reminder.getTitle());&#10;            }&#10;        } catch (Exception e) {&#10;            android.util.Log.e(&quot;ReminderPresenter&quot;, &quot;Lỗi khi schedule reminder: &quot; + e.getMessage());&#10;            if (isViewAttached()) {&#10;                view.showError(&quot;Lỗi khi thiết lập thông báo: &quot; + e.getMessage());&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * ✅ THÊM: Lấy context từ view (giả sử view là Fragment hoặc Activity)&#10;     */&#10;    private android.content.Context getContextFromView() {&#10;        if (!isViewAttached()) {&#10;            return null;&#10;        }&#10;&#10;        // Thử cast view thành các loại có thể có context&#10;        if (view instanceof androidx.fragment.app.Fragment) {&#10;            return ((androidx.fragment.app.Fragment) view).getContext();&#10;        } else if (view instanceof android.app.Activity) {&#10;            return (android.app.Activity) view;&#10;        } else if (view instanceof ReminderFragment) {&#10;            return ((ReminderFragment) view).getContext();&#10;        }&#10;&#10;        // Nếu không thể lấy context trực tiếp, thử cách khác&#10;        return null;&#10;    }&#10;&#10;    @Override&#10;    public void refreshReminders() {&#10;        loadReminders();&#10;    }&#10;&#10;    @Override&#10;    public void searchReminders(String query) {&#10;        currentSearchQuery = query != null ? query.trim() : &quot;&quot;;&#10;        applyFiltersAndSearch();&#10;&#10;        if (isViewAttached()) {&#10;            if (filteredReminders.isEmpty() &amp;&amp; !allReminders.isEmpty()) {&#10;                view.showEmptyState();&#10;            } else {&#10;                view.hideEmptyState();&#10;                view.showReminders(filteredReminders);&#10;            }&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void filterReminders(boolean activeOnly) {&#10;        showActiveOnly = activeOnly;&#10;        applyFiltersAndSearch();&#10;&#10;        if (isViewAttached()) {&#10;            if (filteredReminders.isEmpty() &amp;&amp; !allReminders.isEmpty()) {&#10;                view.showEmptyState();&#10;            } else {&#10;                view.hideEmptyState();&#10;                view.showReminders(filteredReminders);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Xóa nhắc nhở sau khi xác nhận&#10;     */&#10;    public void confirmDeleteReminder(Reminder reminder) {&#10;        if (!isViewAttached() || reminder == null) {&#10;            return;&#10;        }&#10;&#10;        view.showLoading();&#10;&#10;        reminderRepository.deleteReminder(reminder.getId(), new ReminderRepository.RepositoryCallback&lt;Void&gt;() {&#10;            @Override&#10;            public void onSuccess(Void result) {&#10;                if (isViewAttached()) {&#10;                    view.hideLoading();&#10;                    view.showSuccess(&quot;Xóa nhắc nhở thành công&quot;);&#10;                    removeReminderFromList(reminder);&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                if (isViewAttached()) {&#10;                    view.hideLoading();&#10;                    view.showError(&quot;Lỗi khi xóa nhắc nhở: &quot; + error);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Áp dụng bộ lọc và tìm kiếm&#10;     */&#10;    private void applyFiltersAndSearch() {&#10;        filteredReminders.clear();&#10;&#10;        for (Reminder reminder : allReminders) {&#10;            boolean matchesSearch = true;&#10;            boolean matchesFilter = true;&#10;&#10;            // Kiểm tra tìm kiếm&#10;            if (!currentSearchQuery.isEmpty()) {&#10;                String title = reminder.getTitle() != null ? reminder.getTitle().toLowerCase() : &quot;&quot;;&#10;                String description = reminder.getDescription() != null ? reminder.getDescription().toLowerCase() : &quot;&quot;;&#10;                String query = currentSearchQuery.toLowerCase();&#10;&#10;                matchesSearch = title.contains(query) || description.contains(query);&#10;            }&#10;&#10;            // Kiểm tra bộ lọc&#10;            if (showActiveOnly) {&#10;                matchesFilter = reminder.isActive();&#10;            }&#10;&#10;            if (matchesSearch &amp;&amp; matchesFilter) {&#10;                filteredReminders.add(reminder);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Thêm reminder mới vào danh sách&#10;     */&#10;    private void addReminderToList(Reminder reminder) {&#10;        allReminders.add(0, reminder); // Thêm vào đầu danh sách&#10;        applyFiltersAndSearch();&#10;&#10;        if (isViewAttached()) {&#10;            if (filteredReminders.isEmpty()) {&#10;                view.showEmptyState();&#10;            } else {&#10;                view.hideEmptyState();&#10;                view.addReminderItem(reminder);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Cập nhật reminder trong danh sách&#10;     */&#10;    private void updateReminderInList(Reminder updatedReminder) {&#10;        for (int i = 0; i &lt; allReminders.size(); i++) {&#10;            if (allReminders.get(i).getId().equals(updatedReminder.getId())) {&#10;                allReminders.set(i, updatedReminder);&#10;                break;&#10;            }&#10;        }&#10;&#10;        applyFiltersAndSearch();&#10;&#10;        if (isViewAttached()) {&#10;            view.updateReminderItem(updatedReminder);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Xóa reminder khỏi danh sách&#10;     */&#10;    private void removeReminderFromList(Reminder reminder) {&#10;        allReminders.removeIf(r -&gt; r.getId().equals(reminder.getId()));&#10;        filteredReminders.removeIf(r -&gt; r.getId().equals(reminder.getId()));&#10;&#10;        if (isViewAttached()) {&#10;            view.removeReminderItem(reminder);&#10;&#10;            if (filteredReminders.isEmpty()) {&#10;                view.showEmptyState();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lấy số lượng nhắc nhở đang hoạt động&#10;     */&#10;    public int getActiveReminderCount() {&#10;        int count = 0;&#10;        for (Reminder reminder : allReminders) {&#10;            if (reminder.isActive()) {&#10;                count++;&#10;            }&#10;        }&#10;        return count;&#10;    }&#10;&#10;    /**&#10;     * Lấy số lượng nhắc nhở tổng cộng&#10;     */&#10;    public int getTotalReminderCount() {&#10;        return allReminders.size();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.presentation.reminder;&#10;&#10;import com.vhn.doan.data.Reminder;&#10;import com.vhn.doan.data.repository.ReminderRepository;&#10;import com.vhn.doan.presentation.base.BasePresenter;&#10;import com.vhn.doan.services.ReminderService;&#10;import com.vhn.doan.utils.UserSessionManager;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;import javax.inject.Inject;&#10;&#10;/**&#10; * Presenter cho chức năng Reminder theo kiến trúc MVP&#10; */&#10;public class ReminderPresenter extends BasePresenter&lt;ReminderContract.View&gt; implements ReminderContract.Presenter {&#10;&#10;    private ReminderRepository reminderRepository;&#10;    private UserSessionManager userSessionManager;&#10;&#10;    private List&lt;Reminder&gt; allReminders;&#10;    private List&lt;Reminder&gt; filteredReminders;&#10;    private boolean isLoading = false;&#10;    private String currentSearchQuery = &quot;&quot;;&#10;    private boolean showActiveOnly = false;&#10;&#10;    @Inject&#10;    public ReminderPresenter(ReminderRepository reminderRepository, UserSessionManager userSessionManager) {&#10;        this.reminderRepository = reminderRepository;&#10;        this.userSessionManager = userSessionManager;&#10;        this.allReminders = new ArrayList&lt;&gt;();&#10;        this.filteredReminders = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    @Override&#10;    public void attachView(ReminderContract.View view) {&#10;        super.attachView(view);&#10;    }&#10;&#10;    @Override&#10;    public void start() {&#10;        loadReminders();&#10;    }&#10;&#10;    @Override&#10;    public void loadReminders() {&#10;        if (isLoading) {&#10;            return;&#10;        }&#10;&#10;        if (!isViewAttached()) {&#10;            return;&#10;        }&#10;&#10;        String userId = userSessionManager.getCurrentUserId();&#10;        if (userId == null || userId.isEmpty()) {&#10;            view.showError(&quot;Vui lòng đăng nhập để xem nhắc nhở&quot;);&#10;            return;&#10;        }&#10;&#10;        isLoading = true;&#10;        view.showLoading();&#10;&#10;        reminderRepository.getUserReminders(userId, new ReminderRepository.RepositoryCallback&lt;List&lt;Reminder&gt;&gt;() {&#10;            @Override&#10;            public void onSuccess(List&lt;Reminder&gt; reminders) {&#10;                isLoading = false;&#10;                if (isViewAttached()) {&#10;                    view.hideLoading();&#10;                    allReminders.clear();&#10;                    allReminders.addAll(reminders);&#10;&#10;                    applyFiltersAndSearch();&#10;&#10;                    if (filteredReminders.isEmpty()) {&#10;                        view.showEmptyState();&#10;                    } else {&#10;                        view.hideEmptyState();&#10;                        view.showReminders(filteredReminders);&#10;                    }&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                isLoading = false;&#10;                if (isViewAttached()) {&#10;                    view.hideLoading();&#10;                    view.showError(&quot;Lỗi khi tải nhắc nhở: &quot; + error);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void createReminder() {&#10;        if (isViewAttached()) {&#10;            view.showReminderDialog(null);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void editReminder(Reminder reminder) {&#10;        if (isViewAttached() &amp;&amp; reminder != null) {&#10;            view.showReminderDialog(reminder);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void deleteReminder(Reminder reminder) {&#10;        if (isViewAttached() &amp;&amp; reminder != null) {&#10;            view.showDeleteConfirmDialog(reminder);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void saveReminder(Reminder reminder) {&#10;        if (!isViewAttached() || reminder == null) {&#10;            return;&#10;        }&#10;&#10;        String userId = userSessionManager.getCurrentUserId();&#10;        if (userId == null || userId.isEmpty()) {&#10;            view.showError(&quot;Vui lòng đăng nhập để lưu nhắc nhở&quot;);&#10;            return;&#10;        }&#10;&#10;        reminder.setUserId(userId);&#10;        view.showLoading();&#10;&#10;        if (reminder.getId() == null || reminder.getId().isEmpty()) {&#10;            // Tạo mới&#10;            reminderRepository.addReminder(reminder, new ReminderRepository.RepositoryCallback&lt;String&gt;() {&#10;                @Override&#10;                public void onSuccess(String reminderId) {&#10;                    if (isViewAttached()) {&#10;                        view.hideLoading();&#10;                        view.showSuccess(&quot;Tạo nhắc nhở thành công&quot;);&#10;                        reminder.setId(reminderId);&#10;                        addReminderToList(reminder);&#10;&#10;                        // ✅ THÊM: Lên lịch thông báo cho nhắc nhở mới&#10;                        scheduleReminderNotification(reminder);&#10;                    }&#10;                }&#10;&#10;                @Override&#10;                public void onError(String error) {&#10;                    if (isViewAttached()) {&#10;                        view.hideLoading();&#10;                        view.showError(&quot;Lỗi khi tạo nhắc nhở: &quot; + error);&#10;                    }&#10;                }&#10;            });&#10;        } else {&#10;            // Cập nhật&#10;            reminderRepository.updateReminder(reminder, new ReminderRepository.RepositoryCallback&lt;Void&gt;() {&#10;                @Override&#10;                public void onSuccess(Void result) {&#10;                    if (isViewAttached()) {&#10;                        view.hideLoading();&#10;                        view.showSuccess(&quot;Cập nhật nhắc nhở thành công&quot;);&#10;                        updateReminderInList(reminder);&#10;&#10;                        // ✅ THÊM: Cập nhật lịch thông báo cho nhắc nhở đã chỉnh sửa&#10;                        scheduleReminderNotification(reminder);&#10;                    }&#10;                }&#10;&#10;                @Override&#10;                public void onError(String error) {&#10;                    if (isViewAttached()) {&#10;                        view.hideLoading();&#10;                        view.showError(&quot;Lỗi khi cập nhật nhắc nhở: &quot; + error);&#10;                    }&#10;                }&#10;            });&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void toggleReminder(Reminder reminder) {&#10;        if (!isViewAttached() || reminder == null) {&#10;            return;&#10;        }&#10;&#10;        boolean newStatus = !reminder.isActive();&#10;&#10;        reminderRepository.toggleReminder(reminder.getId(), newStatus, new ReminderRepository.RepositoryCallback&lt;Void&gt;() {&#10;            @Override&#10;            public void onSuccess(Void result) {&#10;                if (isViewAttached()) {&#10;                    reminder.setActive(newStatus);&#10;                    updateReminderInList(reminder);&#10;&#10;                    String message = newStatus ? &quot;Đã bật nhắc nhở&quot; : &quot;Đã tắt nhắc nhở&quot;;&#10;                    view.showSuccess(message);&#10;&#10;                    // ✅ THÊM: Cập nhật lịch thông báo khi bật/tắt&#10;                    scheduleReminderNotification(reminder);&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                if (isViewAttached()) {&#10;                    view.showError(&quot;Lỗi khi thay đổi trạng thái nhắc nhở: &quot; + error);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * ✅ THÊM: Method để lên lịch thông báo cho nhắc nhở&#10;     */&#10;    private void scheduleReminderNotification(Reminder reminder) {&#10;        if (!isViewAttached() || reminder == null) {&#10;            return;&#10;        }&#10;&#10;        // Lấy context từ view để tạo ReminderService&#10;        android.content.Context context = getContextFromView();&#10;        if (context == null) {&#10;            android.util.Log.w(&quot;ReminderPresenter&quot;, &quot;Không thể lấy context để schedule reminder&quot;);&#10;            return;&#10;        }&#10;&#10;        try {&#10;            ReminderService reminderService = new ReminderService(context);&#10;&#10;            if (reminder.isActive()) {&#10;                // Lên lịch thông báo nếu reminder đang bật&#10;                reminderService.scheduleReminder(reminder);&#10;                android.util.Log.d(&quot;ReminderPresenter&quot;, &quot;✅ Đã lên lịch thông báo cho reminder: &quot; + reminder.getTitle());&#10;            } else {&#10;                // Hủy thông báo nếu reminder bị tắt - cần thêm context&#10;                ReminderService.cancelReminder(getContextFromView(), reminder.getId());&#10;                android.util.Log.d(&quot;ReminderPresenter&quot;, &quot;❌ Đã hủy thông báo cho reminder: &quot; + reminder.getTitle());&#10;            }&#10;        } catch (Exception e) {&#10;            android.util.Log.e(&quot;ReminderPresenter&quot;, &quot;Lỗi khi schedule reminder: &quot; + e.getMessage());&#10;            if (isViewAttached()) {&#10;                view.showError(&quot;Lỗi khi thiết lập thông báo: &quot; + e.getMessage());&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * ✅ THÊM: Lấy context từ view (giả sử view là Fragment hoặc Activity)&#10;     */&#10;    private android.content.Context getContextFromView() {&#10;        if (!isViewAttached()) {&#10;            return null;&#10;        }&#10;&#10;        // Thử cast view thành các loại có thể có context&#10;        if (view instanceof androidx.fragment.app.Fragment) {&#10;            return ((androidx.fragment.app.Fragment) view).getContext();&#10;        } else if (view instanceof android.app.Activity) {&#10;            return (android.app.Activity) view;&#10;        } else if (view instanceof ReminderFragment) {&#10;            return ((ReminderFragment) view).getContext();&#10;        }&#10;&#10;        // Nếu không thể lấy context trực tiếp, thử cách khác&#10;        return null;&#10;    }&#10;&#10;    @Override&#10;    public void refreshReminders() {&#10;        loadReminders();&#10;    }&#10;&#10;    @Override&#10;    public void searchReminders(String query) {&#10;        currentSearchQuery = query != null ? query.trim() : &quot;&quot;;&#10;        applyFiltersAndSearch();&#10;&#10;        if (isViewAttached()) {&#10;            if (filteredReminders.isEmpty() &amp;&amp; !allReminders.isEmpty()) {&#10;                view.showEmptyState();&#10;            } else {&#10;                view.hideEmptyState();&#10;                view.showReminders(filteredReminders);&#10;            }&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void filterReminders(boolean activeOnly) {&#10;        showActiveOnly = activeOnly;&#10;        applyFiltersAndSearch();&#10;&#10;        if (isViewAttached()) {&#10;            if (filteredReminders.isEmpty() &amp;&amp; !allReminders.isEmpty()) {&#10;                view.showEmptyState();&#10;            } else {&#10;                view.hideEmptyState();&#10;                view.showReminders(filteredReminders);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Xóa nhắc nhở sau khi xác nhận&#10;     */&#10;    public void confirmDeleteReminder(Reminder reminder) {&#10;        if (!isViewAttached() || reminder == null) {&#10;            return;&#10;        }&#10;&#10;        view.showLoading();&#10;&#10;        reminderRepository.deleteReminder(reminder.getId(), new ReminderRepository.RepositoryCallback&lt;Void&gt;() {&#10;            @Override&#10;            public void onSuccess(Void result) {&#10;                if (isViewAttached()) {&#10;                    view.hideLoading();&#10;                    view.showSuccess(&quot;Xóa nhắc nhở thành công&quot;);&#10;                    removeReminderFromList(reminder);&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                if (isViewAttached()) {&#10;                    view.hideLoading();&#10;                    view.showError(&quot;Lỗi khi xóa nhắc nhở: &quot; + error);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Áp dụng bộ lọc và tìm kiếm&#10;     */&#10;    private void applyFiltersAndSearch() {&#10;        filteredReminders.clear();&#10;&#10;        for (Reminder reminder : allReminders) {&#10;            boolean matchesSearch = true;&#10;            boolean matchesFilter = true;&#10;&#10;            // Kiểm tra tìm kiếm&#10;            if (!currentSearchQuery.isEmpty()) {&#10;                String title = reminder.getTitle() != null ? reminder.getTitle().toLowerCase() : &quot;&quot;;&#10;                String description = reminder.getDescription() != null ? reminder.getDescription().toLowerCase() : &quot;&quot;;&#10;                String query = currentSearchQuery.toLowerCase();&#10;&#10;                matchesSearch = title.contains(query) || description.contains(query);&#10;            }&#10;&#10;            // Kiểm tra bộ lọc&#10;            if (showActiveOnly) {&#10;                matchesFilter = reminder.isActive();&#10;            }&#10;&#10;            if (matchesSearch &amp;&amp; matchesFilter) {&#10;                filteredReminders.add(reminder);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Thêm reminder mới vào danh sách&#10;     */&#10;    private void addReminderToList(Reminder reminder) {&#10;        allReminders.add(0, reminder); // Thêm vào đầu danh sách&#10;        applyFiltersAndSearch();&#10;&#10;        if (isViewAttached()) {&#10;            if (filteredReminders.isEmpty()) {&#10;                view.showEmptyState();&#10;            } else {&#10;                view.hideEmptyState();&#10;                view.addReminderItem(reminder);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Cập nhật reminder trong danh sách&#10;     */&#10;    private void updateReminderInList(Reminder updatedReminder) {&#10;        for (int i = 0; i &lt; allReminders.size(); i++) {&#10;            if (allReminders.get(i).getId().equals(updatedReminder.getId())) {&#10;                allReminders.set(i, updatedReminder);&#10;                break;&#10;            }&#10;        }&#10;&#10;        applyFiltersAndSearch();&#10;&#10;        if (isViewAttached()) {&#10;            view.updateReminderItem(updatedReminder);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Xóa reminder khỏi danh sách&#10;     */&#10;    private void removeReminderFromList(Reminder reminder) {&#10;        allReminders.removeIf(r -&gt; r.getId().equals(reminder.getId()));&#10;        filteredReminders.removeIf(r -&gt; r.getId().equals(reminder.getId()));&#10;&#10;        if (isViewAttached()) {&#10;            view.removeReminderItem(reminder);&#10;&#10;            if (filteredReminders.isEmpty()) {&#10;                view.showEmptyState();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lấy số lượng nhắc nhở đang hoạt động&#10;     */&#10;    public int getActiveReminderCount() {&#10;        int count = 0;&#10;        for (Reminder reminder : allReminders) {&#10;            if (reminder.isActive()) {&#10;                count++;&#10;            }&#10;        }&#10;        return count;&#10;    }&#10;&#10;    /**&#10;     * Lấy số lượng nhắc nhở tổng cộng&#10;     */&#10;    public int getTotalReminderCount() {&#10;        return allReminders.size();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/receivers/BootReceiver.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/receivers/BootReceiver.java" />
              <option name="originalContent" value="package com.vhn.doan.receivers;&#10;&#10;import android.content.BroadcastReceiver;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.util.Log;&#10;&#10;import com.vhn.doan.data.Reminder;&#10;import com.vhn.doan.data.repository.ReminderRepository;&#10;import com.vhn.doan.data.repository.ReminderRepositoryImpl;&#10;import com.vhn.doan.services.ReminderService;&#10;import com.vhn.doan.utils.UserSessionManager;&#10;&#10;import java.util.List;&#10;&#10;/**&#10; * BootReceiver để khởi động lại tất cả reminder active sau khi khởi động lại máy&#10; */&#10;public class BootReceiver extends BroadcastReceiver {&#10;&#10;    private static final String TAG = &quot;BootReceiver&quot;;&#10;&#10;    @Override&#10;    public void onReceive(Context context, Intent intent) {&#10;        String action = intent.getAction();&#10;        Log.d(TAG, &quot;BootReceiver triggered with action: &quot; + action);&#10;&#10;        if (Intent.ACTION_BOOT_COMPLETED.equals(action) ||&#10;            Intent.ACTION_MY_PACKAGE_REPLACED.equals(action) ||&#10;            Intent.ACTION_PACKAGE_REPLACED.equals(action)) {&#10;&#10;            Log.d(TAG, &quot;Device booted or app updated - rescheduling all active reminders&quot;);&#10;            rescheduleAllActiveReminders(context);&#10;        }&#10;    }&#10;&#10;    private void rescheduleAllActiveReminders(Context context) {&#10;        // Lấy user session&#10;        UserSessionManager userSessionManager = new UserSessionManager(context);&#10;        String userId = userSessionManager.getCurrentUserId();&#10;&#10;        if (userId == null || userId.isEmpty()) {&#10;            Log.w(TAG, &quot;No user logged in - skipping reminder rescheduling&quot;);&#10;            return;&#10;        }&#10;&#10;        // Lấy tất cả reminder active và reschedule&#10;        ReminderRepository reminderRepository = new ReminderRepositoryImpl();&#10;        reminderRepository.getActiveReminders(userId, new ReminderRepository.RepositoryCallback&lt;List&lt;Reminder&gt;&gt;() {&#10;            @Override&#10;            public void onSuccess(List&lt;Reminder&gt; reminders) {&#10;                Log.d(TAG, &quot;Found &quot; + reminders.size() + &quot; active reminders to reschedule&quot;);&#10;&#10;                ReminderService reminderService = new ReminderService(context);&#10;                int rescheduledCount = 0;&#10;&#10;                for (Reminder reminder : reminders) {&#10;                    if (reminder.isActive() &amp;&amp; reminder.getReminderTime() != null) {&#10;                        // Chỉ reschedule những reminder trong tương lai&#10;                        if (reminder.getReminderTime() &gt; System.currentTimeMillis()) {&#10;                            reminderService.scheduleReminder(reminder);&#10;                            rescheduledCount++;&#10;                            Log.d(TAG, &quot;Rescheduled reminder: &quot; + reminder.getTitle());&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Log.d(TAG, &quot;Successfully rescheduled &quot; + rescheduledCount + &quot; reminders&quot;);&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                Log.e(TAG, &quot;Failed to load active reminders: &quot; + error);&#10;            }&#10;        });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.receivers;&#10;&#10;import android.content.BroadcastReceiver;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.util.Log;&#10;&#10;import com.vhn.doan.data.Reminder;&#10;import com.vhn.doan.data.repository.ReminderRepository;&#10;import com.vhn.doan.data.repository.ReminderRepositoryImpl;&#10;import com.vhn.doan.services.ReminderService;&#10;import com.vhn.doan.utils.UserSessionManager;&#10;&#10;import java.util.List;&#10;&#10;/**&#10; * BootReceiver để khởi động lại tất cả reminder active sau khi khởi động lại máy&#10; */&#10;public class BootReceiver extends BroadcastReceiver {&#10;&#10;    private static final String TAG = &quot;BootReceiver&quot;;&#10;&#10;    @Override&#10;    public void onReceive(Context context, Intent intent) {&#10;        String action = intent.getAction();&#10;        Log.d(TAG, &quot;BootReceiver triggered with action: &quot; + action);&#10;&#10;        if (Intent.ACTION_BOOT_COMPLETED.equals(action) ||&#10;            Intent.ACTION_MY_PACKAGE_REPLACED.equals(action) ||&#10;            Intent.ACTION_PACKAGE_REPLACED.equals(action)) {&#10;&#10;            Log.d(TAG, &quot;Device booted or app updated - rescheduling all active reminders&quot;);&#10;            rescheduleAllActiveReminders(context);&#10;        }&#10;    }&#10;&#10;    private void rescheduleAllActiveReminders(Context context) {&#10;        // Lấy user session&#10;        UserSessionManager userSessionManager = new UserSessionManager(context);&#10;        String userId = userSessionManager.getCurrentUserId();&#10;&#10;        if (userId == null || userId.isEmpty()) {&#10;            Log.w(TAG, &quot;No user logged in - skipping reminder rescheduling&quot;);&#10;            return;&#10;        }&#10;&#10;        // Lấy tất cả reminder active và reschedule&#10;        ReminderRepository reminderRepository = new ReminderRepositoryImpl();&#10;        reminderRepository.getActiveReminders(userId, new ReminderRepository.RepositoryCallback&lt;List&lt;Reminder&gt;&gt;() {&#10;            @Override&#10;            public void onSuccess(List&lt;Reminder&gt; reminders) {&#10;                Log.d(TAG, &quot;Found &quot; + reminders.size() + &quot; active reminders to reschedule&quot;);&#10;&#10;                ReminderService reminderService = new ReminderService(context);&#10;                int rescheduledCount = 0;&#10;&#10;                for (Reminder reminder : reminders) {&#10;                    if (reminder.isActive() &amp;&amp; reminder.getReminderTime() != null) {&#10;                        // Chỉ reschedule những reminder trong tương lai&#10;                        if (reminder.getReminderTime() &gt; System.currentTimeMillis()) {&#10;                            reminderService.scheduleReminder(reminder);&#10;                            rescheduledCount++;&#10;                            Log.d(TAG, &quot;Rescheduled reminder: &quot; + reminder.getTitle());&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Log.d(TAG, &quot;Successfully rescheduled &quot; + rescheduledCount + &quot; reminders&quot;);&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                Log.e(TAG, &quot;Failed to load active reminders: &quot; + error);&#10;            }&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Public static method để có thể gọi từ các class khác&#10;     */&#10;    public static void rescheduleAllReminders(Context context) {&#10;        BootReceiver receiver = new BootReceiver();&#10;        receiver.rescheduleAllActiveReminders(context);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/receivers/ReminderBroadcastReceiver.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/receivers/ReminderBroadcastReceiver.java" />
              <option name="originalContent" value="package com.vhn.doan.receivers;&#10;&#10;import android.content.BroadcastReceiver;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.os.PowerManager;&#10;import android.util.Log;&#10;&#10;import com.vhn.doan.data.Reminder;&#10;import com.vhn.doan.data.repository.ReminderRepository;&#10;import com.vhn.doan.data.repository.ReminderRepositoryImpl;&#10;import com.vhn.doan.services.NotificationService;&#10;import com.vhn.doan.services.ReminderService;&#10;&#10;/**&#10; * BroadcastReceiver để xử lý khi thời gian nhắc nhở đã đến&#10; */&#10;public class ReminderBroadcastReceiver extends BroadcastReceiver {&#10;&#10;    private static final String TAG = &quot;ReminderBroadcastReceiver&quot;;&#10;&#10;    @Override&#10;    public void onReceive(Context context, Intent intent) {&#10;        // Acquire wake lock để đảm bảo thiết bị không sleep trong quá trình xử lý&#10;        PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);&#10;        PowerManager.WakeLock wakeLock = powerManager.newWakeLock(&#10;            PowerManager.PARTIAL_WAKE_LOCK,&#10;            &quot;HealthTips:ReminderReceiver&quot;&#10;        );&#10;&#10;        try {&#10;            // Acquire wake lock với timeout 10 giây&#10;            wakeLock.acquire(10 * 1000);&#10;&#10;            Log.d(TAG, &quot;ReminderBroadcastReceiver triggered&quot;);&#10;&#10;            String action = intent.getAction();&#10;            if (action == null) {&#10;                Log.w(TAG, &quot;Action is null&quot;);&#10;                return;&#10;            }&#10;&#10;            switch (action) {&#10;                case ReminderService.ACTION_REMINDER_TRIGGER:&#10;                    handleReminderTrigger(context, intent);&#10;                    break;&#10;                case &quot;REMINDER_STATUS_CHANGED&quot;:&#10;                    handleReminderStatusChanged(context, intent);&#10;                    break;&#10;                default:&#10;                    Log.w(TAG, &quot;Unknown action: &quot; + action);&#10;                    break;&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error in onReceive&quot;, e);&#10;        } finally {&#10;            // Luôn release wake lock&#10;            if (wakeLock.isHeld()) {&#10;                wakeLock.release();&#10;            }&#10;        }&#10;    }&#10;&#10;    private void handleReminderTrigger(Context context, Intent intent) {&#10;        String reminderId = intent.getStringExtra(&quot;reminder_id&quot;);&#10;        String title = intent.getStringExtra(&quot;title&quot;);&#10;        String message = intent.getStringExtra(&quot;message&quot;);&#10;&#10;        Log.d(TAG, &quot;Handling reminder trigger - ID: &quot; + reminderId + &quot;, Title: &quot; + title);&#10;&#10;        if (reminderId == null || title == null || message == null) {&#10;            Log.w(TAG, &quot;Missing reminder data&quot;);&#10;            return;&#10;        }&#10;&#10;        // Hiển thị thông báo ngay lập tức&#10;        NotificationService.showReminderNotification(context, title, message, reminderId);&#10;&#10;        // Cập nhật trạng thái reminder&#10;        ReminderRepository reminderRepository = new ReminderRepositoryImpl();&#10;        reminderRepository.getReminderById(reminderId, new ReminderRepository.RepositoryCallback&lt;Reminder&gt;() {&#10;            @Override&#10;            public void onSuccess(Reminder reminder) {&#10;                if (reminder != null) {&#10;                    Log.d(TAG, &quot;Successfully retrieved reminder: &quot; + reminder.getTitle());&#10;&#10;                    // Cập nhật lần thông báo cuối&#10;                    reminder.setLastNotified(System.currentTimeMillis());&#10;&#10;                    // Nếu không phải reminder lặp lại, đánh dấu là đã hoàn thành&#10;                    if (!reminder.isRepeating()) {&#10;                        reminder.setCompleted(true);&#10;                        reminder.setActive(false);&#10;                    }&#10;&#10;                    reminderRepository.updateReminder(reminder, new ReminderRepository.RepositoryCallback&lt;Void&gt;() {&#10;                        @Override&#10;                        public void onSuccess(Void result) {&#10;                            Log.d(TAG, &quot;Reminder updated successfully&quot;);&#10;                        }&#10;&#10;                        @Override&#10;                        public void onError(String error) {&#10;                            Log.e(TAG, &quot;Failed to update reminder: &quot; + error);&#10;                        }&#10;                    });&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                Log.e(TAG, &quot;Failed to get reminder: &quot; + error);&#10;                // Vẫn hiển thị thông báo ngay cả khi không lấy được reminder từ database&#10;                NotificationService.showReminderNotification(context, title, message, reminderId);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void handleReminderStatusChanged(Context context, Intent intent) {&#10;        String reminderId = intent.getStringExtra(&quot;reminder_id&quot;);&#10;        boolean isActive = intent.getBooleanExtra(&quot;is_active&quot;, false);&#10;&#10;        Log.d(TAG, &quot;Reminder status changed - ID: &quot; + reminderId + &quot;, Active: &quot; + isActive);&#10;&#10;        // Xử lý thay đổi trạng thái reminder nếu cần&#10;        if (!isActive) {&#10;            // Hủy alarm nếu reminder bị tắt&#10;            ReminderService.cancelReminder(context, reminderId);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.receivers;&#10;&#10;import android.content.BroadcastReceiver;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.os.PowerManager;&#10;import android.util.Log;&#10;&#10;import com.vhn.doan.data.Reminder;&#10;import com.vhn.doan.data.repository.ReminderRepository;&#10;import com.vhn.doan.data.repository.ReminderRepositoryImpl;&#10;import com.vhn.doan.services.ReminderService;&#10;&#10;/**&#10; * BroadcastReceiver để xử lý khi thời gian nhắc nhở đã đến&#10; */&#10;public class ReminderBroadcastReceiver extends BroadcastReceiver {&#10;&#10;    private static final String TAG = &quot;ReminderBroadcastReceiver&quot;;&#10;&#10;    @Override&#10;    public void onReceive(Context context, Intent intent) {&#10;        // Acquire wake lock để đảm bảo thiết bị không sleep trong quá trình xử lý&#10;        PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);&#10;        PowerManager.WakeLock wakeLock = powerManager.newWakeLock(&#10;            PowerManager.PARTIAL_WAKE_LOCK,&#10;            &quot;HealthTips:ReminderReceiver&quot;&#10;        );&#10;&#10;        try {&#10;            // Acquire wake lock với timeout 10 giây&#10;            wakeLock.acquire(10 * 1000);&#10;&#10;            Log.d(TAG, &quot;ReminderBroadcastReceiver triggered&quot;);&#10;&#10;            String action = intent.getAction();&#10;            if (action == null) {&#10;                Log.w(TAG, &quot;Action is null&quot;);&#10;                return;&#10;            }&#10;&#10;            switch (action) {&#10;                case ReminderService.ACTION_REMINDER_TRIGGER:&#10;                    handleReminderTrigger(context, intent);&#10;                    break;&#10;                case &quot;REMINDER_STATUS_CHANGED&quot;:&#10;                    handleReminderStatusChanged(context, intent);&#10;                    break;&#10;                default:&#10;                    Log.w(TAG, &quot;Unknown action: &quot; + action);&#10;                    break;&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error in onReceive&quot;, e);&#10;        } finally {&#10;            // Luôn release wake lock&#10;            if (wakeLock.isHeld()) {&#10;                wakeLock.release();&#10;            }&#10;        }&#10;    }&#10;&#10;    private void handleReminderTrigger(Context context, Intent intent) {&#10;        String reminderId = intent.getStringExtra(&quot;reminder_id&quot;);&#10;        String title = intent.getStringExtra(&quot;title&quot;);&#10;        String message = intent.getStringExtra(&quot;message&quot;);&#10;&#10;        Log.d(TAG, &quot;Handling reminder trigger - ID: &quot; + reminderId + &quot;, Title: &quot; + title);&#10;&#10;        if (reminderId == null || title == null || message == null) {&#10;            Log.w(TAG, &quot;Missing reminder data&quot;);&#10;            return;&#10;        }&#10;&#10;        // Sử dụng Foreground Service để đảm bảo thông báo hiển thị&#10;        com.vhn.doan.services.ReminderForegroundService.showReminder(context, reminderId, title, message);&#10;&#10;        // Cập nhật trạng thái reminder&#10;        ReminderRepository reminderRepository = new ReminderRepositoryImpl();&#10;        reminderRepository.getReminderById(reminderId, new ReminderRepository.RepositoryCallback&lt;Reminder&gt;() {&#10;            @Override&#10;            public void onSuccess(Reminder reminder) {&#10;                if (reminder != null) {&#10;                    Log.d(TAG, &quot;Successfully retrieved reminder: &quot; + reminder.getTitle());&#10;&#10;                    // Cập nhật lần thông báo cuối&#10;                    reminder.setLastNotified(System.currentTimeMillis());&#10;&#10;                    // Nếu không phải reminder lặp lại, đánh dấu là đã hoàn thành&#10;                    if (!reminder.isRepeating()) {&#10;                        reminder.setCompleted(true);&#10;                        reminder.setActive(false);&#10;                    }&#10;&#10;                    reminderRepository.updateReminder(reminder, new ReminderRepository.RepositoryCallback&lt;Void&gt;() {&#10;                        @Override&#10;                        public void onSuccess(Void result) {&#10;                            Log.d(TAG, &quot;Reminder updated successfully&quot;);&#10;                        }&#10;&#10;                        @Override&#10;                        public void onError(String error) {&#10;                            Log.e(TAG, &quot;Failed to update reminder: &quot; + error);&#10;                        }&#10;                    });&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                Log.e(TAG, &quot;Failed to get reminder: &quot; + error);&#10;                // Vẫn hiển thị thông báo ngay cả khi không lấy được reminder từ database&#10;                com.vhn.doan.services.ReminderForegroundService.showReminder(context, reminderId, title, message);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void handleReminderStatusChanged(Context context, Intent intent) {&#10;        String reminderId = intent.getStringExtra(&quot;reminder_id&quot;);&#10;        boolean isActive = intent.getBooleanExtra(&quot;is_active&quot;, false);&#10;&#10;        Log.d(TAG, &quot;Reminder status changed - ID: &quot; + reminderId + &quot;, Active: &quot; + isActive);&#10;&#10;        // Xử lý thay đổi trạng thái reminder nếu cần&#10;        if (!isActive) {&#10;            // Hủy alarm nếu reminder bị tắt&#10;            ReminderService.cancelReminder(context, reminderId);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/services/NotificationService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/services/NotificationService.java" />
              <option name="originalContent" value="package com.vhn.doan.services;&#10;&#10;import android.app.Notification;&#10;import android.app.NotificationChannel;&#10;import android.app.NotificationManager;&#10;import android.app.PendingIntent;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.os.Build;&#10;&#10;import androidx.core.app.NotificationCompat;&#10;import androidx.core.app.NotificationManagerCompat;&#10;&#10;import com.vhn.doan.R;&#10;import com.vhn.doan.data.Reminder;&#10;import com.vhn.doan.presentation.home.HomeActivity;&#10;import com.vhn.doan.receivers.ReminderActionReceiver;&#10;&#10;/**&#10; * Service để xử lý thông báo nhắc nhở&#10; */&#10;public class NotificationService {&#10;&#10;    private static final String REMINDER_CHANNEL_ID = &quot;reminder_channel&quot;;&#10;    private static final String REMINDER_CHANNEL_NAME = &quot;Nhắc nhở sức khỏe&quot;;&#10;    private static final String REMINDER_CHANNEL_DESCRIPTION = &quot;Thông báo nhắc nhở về sức khỏe&quot;;&#10;    private static final int REMINDER_NOTIFICATION_ID = 1001;&#10;&#10;    private Context context;&#10;    private NotificationManager notificationManager;&#10;&#10;    public NotificationService(Context context) {&#10;        this.context = context;&#10;        this.notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);&#10;        createNotificationChannel();&#10;    }&#10;&#10;    /**&#10;     * Tạo notification channel cho Android 8.0+&#10;     */&#10;    private void createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            NotificationChannel channel = new NotificationChannel(&#10;                REMINDER_CHANNEL_ID,&#10;                REMINDER_CHANNEL_NAME,&#10;                NotificationManager.IMPORTANCE_HIGH&#10;            );&#10;            channel.setDescription(REMINDER_CHANNEL_DESCRIPTION);&#10;            channel.enableLights(true);&#10;            channel.enableVibration(true);&#10;            channel.setVibrationPattern(new long[]{1000, 1000, 1000, 1000, 1000});&#10;            channel.setLightColor(android.graphics.Color.BLUE);&#10;            channel.setShowBadge(true);&#10;            channel.setLockscreenVisibility(Notification.VISIBILITY_PUBLIC);&#10;&#10;            notificationManager.createNotificationChannel(channel);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Hiển thị thông báo nhắc nhở&#10;     */&#10;    public void showReminderNotification(Reminder reminder) {&#10;        if (reminder == null) return;&#10;&#10;        // Tạo intent để mở app khi click notification&#10;        Intent intent = new Intent(context, HomeActivity.class);&#10;        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);&#10;        intent.putExtra(&quot;open_reminders&quot;, true);&#10;&#10;        PendingIntent pendingIntent = PendingIntent.getActivity(&#10;            context,&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#10;        );&#10;&#10;        // Tạo notification với âm thanh và rung&#10;        NotificationCompat.Builder builder = new NotificationCompat.Builder(context, REMINDER_CHANNEL_ID)&#10;            .setSmallIcon(R.drawable.ic_notification_reminder)&#10;            .setContentTitle(&quot; Nhắc nhở: &quot; + reminder.getTitle())&#10;            .setContentText(reminder.getDescription())&#10;            .setPriority(NotificationCompat.PRIORITY_HIGH)&#10;            .setDefaults(NotificationCompat.DEFAULT_ALL)&#10;            .setAutoCancel(true)&#10;            .setOngoing(false)&#10;            .setContentIntent(pendingIntent)&#10;            .setStyle(new NotificationCompat.BigTextStyle()&#10;                .bigText(reminder.getDescription())&#10;                .setBigContentTitle(&quot; Nhắc nhở: &quot; + reminder.getTitle()))&#10;            .addAction(&#10;                R.drawable.ic_check,&#10;                &quot;✓ Hoàn thành&quot;,&#10;                createMarkCompleteIntent(reminder)&#10;            )&#10;            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)&#10;            .setCategory(NotificationCompat.CATEGORY_REMINDER);&#10;&#10;        // Hiển thị notification&#10;        try {&#10;            NotificationManagerCompat notificationManagerCompat = NotificationManagerCompat.from(context);&#10;            if (notificationManagerCompat.areNotificationsEnabled()) {&#10;                int notificationId = REMINDER_NOTIFICATION_ID + reminder.getId().hashCode();&#10;                notificationManagerCompat.notify(notificationId, builder.build());&#10;&#10;                android.util.Log.d(&quot;NotificationService&quot;, &quot;Đã hiển thị thông báo cho reminder: &quot; +&#10;                    reminder.getTitle() + &quot; với ID: &quot; + notificationId);&#10;            } else {&#10;                android.util.Log.w(&quot;NotificationService&quot;, &quot;Thông báo bị tắt bởi người dùng&quot;);&#10;            }&#10;        } catch (SecurityException e) {&#10;            android.util.Log.e(&quot;NotificationService&quot;, &quot;Không có quyền hiển thị thông báo&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Tạo PendingIntent để đánh dấu hoàn thành nhắc nhở&#10;     */&#10;    private PendingIntent createMarkCompleteIntent(Reminder reminder) {&#10;        Intent intent = new Intent(context, ReminderActionReceiver.class);&#10;        intent.setAction(&quot;MARK_COMPLETE&quot;);&#10;        intent.putExtra(&quot;reminder_id&quot;, reminder.getId());&#10;&#10;        return PendingIntent.getBroadcast(&#10;            context,&#10;            reminder.getId().hashCode(),&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Hủy thông báo nhắc nhở&#10;     */&#10;    public void cancelReminderNotification(String reminderId) {&#10;        if (reminderId != null) {&#10;            notificationManager.cancel(REMINDER_NOTIFICATION_ID + reminderId.hashCode());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Hủy tất cả thông báo nhắc nhở&#10;     */&#10;    public void cancelAllReminderNotifications() {&#10;        notificationManager.cancelAll();&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra xem notification có được bật hay không&#10;     */&#10;    public boolean areNotificationsEnabled() {&#10;        NotificationManagerCompat notificationManagerCompat = NotificationManagerCompat.from(context);&#10;        return notificationManagerCompat.areNotificationsEnabled();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.services;&#13;&#10;&#13;&#10;import android.app.Notification;&#13;&#10;import android.app.NotificationChannel;&#13;&#10;import android.app.NotificationManager;&#13;&#10;import android.app.PendingIntent;&#13;&#10;import android.content.Context;&#13;&#10;import android.content.Intent;&#13;&#10;import android.os.Build;&#13;&#10;&#13;&#10;import androidx.core.app.NotificationCompat;&#13;&#10;import androidx.core.app.NotificationManagerCompat;&#13;&#10;&#13;&#10;import com.vhn.doan.R;&#13;&#10;import com.vhn.doan.data.Reminder;&#13;&#10;import com.vhn.doan.presentation.home.HomeActivity;&#13;&#10;import com.vhn.doan.receivers.ReminderActionReceiver;&#13;&#10;&#13;&#10;/**&#13;&#10; * Service để xử lý thông báo nhắc nhở&#13;&#10; */&#13;&#10;public class NotificationService {&#13;&#10;&#13;&#10;    private static final String REMINDER_CHANNEL_ID = &quot;reminder_channel&quot;;&#13;&#10;    private static final String REMINDER_CHANNEL_NAME = &quot;Nhắc nhở sức khỏe&quot;;&#13;&#10;    private static final String REMINDER_CHANNEL_DESCRIPTION = &quot;Thông báo nhắc nhở về sức khỏe&quot;;&#13;&#10;    private static final int REMINDER_NOTIFICATION_ID = 1001;&#13;&#10;&#13;&#10;    private Context context;&#13;&#10;    private NotificationManager notificationManager;&#13;&#10;&#13;&#10;    public NotificationService(Context context) {&#13;&#10;        this.context = context;&#13;&#10;        this.notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);&#13;&#10;        createNotificationChannel();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Tạo notification channel cho Android 8.0+&#13;&#10;     */&#13;&#10;    private void createNotificationChannel() {&#13;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#13;&#10;            NotificationChannel channel = new NotificationChannel(&#13;&#10;                REMINDER_CHANNEL_ID,&#13;&#10;                REMINDER_CHANNEL_NAME,&#13;&#10;                NotificationManager.IMPORTANCE_HIGH&#13;&#10;            );&#13;&#10;            channel.setDescription(REMINDER_CHANNEL_DESCRIPTION);&#13;&#10;            channel.enableLights(true);&#13;&#10;            channel.enableVibration(true);&#13;&#10;            channel.setVibrationPattern(new long[]{1000, 1000, 1000, 1000, 1000});&#13;&#10;            channel.setLightColor(android.graphics.Color.BLUE);&#13;&#10;            channel.setShowBadge(true);&#13;&#10;            channel.setLockscreenVisibility(Notification.VISIBILITY_PUBLIC);&#13;&#10;&#13;&#10;            notificationManager.createNotificationChannel(channel);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Hiển thị thông báo nhắc nhở&#13;&#10;     */&#13;&#10;    public void showReminderNotification(Reminder reminder) {&#13;&#10;        if (reminder == null) return;&#13;&#10;&#13;&#10;        // Tạo intent để mở app khi click notification&#13;&#10;        Intent intent = new Intent(context, HomeActivity.class);&#13;&#10;        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);&#13;&#10;        intent.putExtra(&quot;open_reminders&quot;, true);&#13;&#10;&#13;&#10;        PendingIntent pendingIntent = PendingIntent.getActivity(&#13;&#10;            context,&#13;&#10;            0,&#13;&#10;            intent,&#13;&#10;            PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#13;&#10;        );&#13;&#10;&#13;&#10;        // Tạo notification với âm thanh và rung&#13;&#10;        NotificationCompat.Builder builder = new NotificationCompat.Builder(context, REMINDER_CHANNEL_ID)&#13;&#10;            .setSmallIcon(R.drawable.ic_notification_reminder)&#13;&#10;            .setContentTitle(&quot; Nhắc nhở: &quot; + reminder.getTitle())&#13;&#10;            .setContentText(reminder.getDescription())&#13;&#10;            .setPriority(NotificationCompat.PRIORITY_HIGH)&#13;&#10;            .setDefaults(NotificationCompat.DEFAULT_ALL)&#13;&#10;            .setAutoCancel(true)&#13;&#10;            .setOngoing(false)&#13;&#10;            .setContentIntent(pendingIntent)&#13;&#10;            .setStyle(new NotificationCompat.BigTextStyle()&#13;&#10;                .bigText(reminder.getDescription())&#13;&#10;                .setBigContentTitle(&quot; Nhắc nhở: &quot; + reminder.getTitle()))&#13;&#10;            .addAction(&#13;&#10;                R.drawable.ic_check,&#13;&#10;                &quot;✓ Hoàn thành&quot;,&#13;&#10;                createMarkCompleteIntent(reminder)&#13;&#10;            )&#13;&#10;            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)&#13;&#10;            .setCategory(NotificationCompat.CATEGORY_REMINDER);&#13;&#10;&#13;&#10;        // Hiển thị notification&#13;&#10;        try {&#13;&#10;            NotificationManagerCompat notificationManagerCompat = NotificationManagerCompat.from(context);&#13;&#10;            if (notificationManagerCompat.areNotificationsEnabled()) {&#13;&#10;                int notificationId = REMINDER_NOTIFICATION_ID + reminder.getId().hashCode();&#13;&#10;                notificationManagerCompat.notify(notificationId, builder.build());&#13;&#10;&#13;&#10;                android.util.Log.d(&quot;NotificationService&quot;, &quot;Đã hiển thị thông báo cho reminder: &quot; +&#13;&#10;                    reminder.getTitle() + &quot; với ID: &quot; + notificationId);&#13;&#10;            } else {&#13;&#10;                android.util.Log.w(&quot;NotificationService&quot;, &quot;Thông báo bị tắt bởi người dùng&quot;);&#13;&#10;            }&#13;&#10;        } catch (SecurityException e) {&#13;&#10;            android.util.Log.e(&quot;NotificationService&quot;, &quot;Không có quyền hiển thị thông báo&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Tạo PendingIntent để đánh dấu hoàn thành nhắc nhở&#13;&#10;     */&#13;&#10;    private PendingIntent createMarkCompleteIntent(Reminder reminder) {&#13;&#10;        Intent intent = new Intent(context, ReminderActionReceiver.class);&#13;&#10;        intent.setAction(&quot;MARK_COMPLETE&quot;);&#13;&#10;        intent.putExtra(&quot;reminder_id&quot;, reminder.getId());&#13;&#10;&#13;&#10;        return PendingIntent.getBroadcast(&#13;&#10;            context,&#13;&#10;            reminder.getId().hashCode(),&#13;&#10;            intent,&#13;&#10;            PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#13;&#10;        );&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Hủy thông báo nhắc nhở&#13;&#10;     */&#13;&#10;    public void cancelReminderNotification(String reminderId) {&#13;&#10;        if (reminderId != null) {&#13;&#10;            notificationManager.cancel(REMINDER_NOTIFICATION_ID + reminderId.hashCode());&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Hủy tất cả thông báo nhắc nhở&#13;&#10;     */&#13;&#10;    public void cancelAllReminderNotifications() {&#13;&#10;        notificationManager.cancelAll();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Kiểm tra xem notification có được bật hay không&#13;&#10;     */&#13;&#10;    public boolean areNotificationsEnabled() {&#13;&#10;        NotificationManagerCompat notificationManagerCompat = NotificationManagerCompat.from(context);&#13;&#10;        return notificationManagerCompat.areNotificationsEnabled();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Hiển thị thông báo nhắc nhở với các tham số riêng lẻ (static method)&#13;&#10;     */&#13;&#10;    public static void showReminderNotification(Context context, String title, String message, String reminderId) {&#13;&#10;        NotificationService service = new NotificationService(context);&#13;&#10;        &#13;&#10;        // Tạo một Reminder object tạm thời để sử dụng method hiện tại&#13;&#10;        Reminder tempReminder = new Reminder();&#13;&#10;        tempReminder.setId(reminderId);&#13;&#10;        tempReminder.setTitle(title);&#13;&#10;        tempReminder.setDescription(message);&#13;&#10;        &#13;&#10;        service.showReminderNotification(tempReminder);&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/services/ReminderForegroundService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/services/ReminderForegroundService.java" />
              <option name="originalContent" value="package com.vhn.doan.services;&#10;&#10;import android.app.Notification;&#10;import android.app.NotificationChannel;&#10;import android.app.NotificationManager;&#10;import android.app.PendingIntent;&#10;import android.app.Service;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.os.Build;&#10;import android.os.IBinder;&#10;import android.os.PowerManager;&#10;import android.util.Log;&#10;&#10;import androidx.annotation.Nullable;&#10;import androidx.core.app.NotificationCompat;&#10;&#10;import com.vhn.doan.R;&#10;import com.vhn.doan.presentation.home.HomeActivity;&#10;&#10;/**&#10; * Foreground Service để đảm bảo thông báo nhắc nhở hoạt động mạnh mẽ&#10; * Service này sẽ chạy trong background và không bị kill bởi hệ thống&#10; */&#10;public class ReminderForegroundService extends Service {&#10;&#10;    private static final String TAG = &quot;ReminderForegroundService&quot;;&#10;    private static final int FOREGROUND_NOTIFICATION_ID = 9999;&#10;    private static final String CHANNEL_ID = &quot;reminder_foreground_channel&quot;;&#10;&#10;    private PowerManager.WakeLock wakeLock;&#10;    private NotificationManager notificationManager;&#10;&#10;    @Override&#10;    public void onCreate() {&#10;        super.onCreate();&#10;        Log.d(TAG, &quot;ReminderForegroundService created&quot;);&#10;&#10;        // Tạo notification channel&#10;        createNotificationChannel();&#10;&#10;        // Acquire wake lock&#10;        PowerManager powerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);&#10;        wakeLock = powerManager.newWakeLock(&#10;            PowerManager.PARTIAL_WAKE_LOCK,&#10;            &quot;HealthTips:ReminderForegroundService&quot;&#10;        );&#10;        wakeLock.acquire();&#10;&#10;        notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);&#10;    }&#10;&#10;    @Override&#10;    public int onStartCommand(Intent intent, int flags, int startId) {&#10;        Log.d(TAG, &quot;ReminderForegroundService started&quot;);&#10;&#10;        // Bắt đầu chạy foreground&#10;        startForeground(FOREGROUND_NOTIFICATION_ID, createForegroundNotification());&#10;&#10;        // Xử lý intent nếu có&#10;        if (intent != null) {&#10;            String action = intent.getAction();&#10;            if (&quot;SHOW_REMINDER&quot;.equals(action)) {&#10;                handleShowReminder(intent);&#10;            }&#10;        }&#10;&#10;        // Return STICKY để service tự động restart nếu bị kill&#10;        return START_STICKY;&#10;    }&#10;&#10;    @Override&#10;    public void onDestroy() {&#10;        super.onDestroy();&#10;        Log.d(TAG, &quot;ReminderForegroundService destroyed&quot;);&#10;&#10;        if (wakeLock != null &amp;&amp; wakeLock.isHeld()) {&#10;            wakeLock.release();&#10;        }&#10;    }&#10;&#10;    @Nullable&#10;    @Override&#10;    public IBinder onBind(Intent intent) {&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Tạo notification channel cho foreground service&#10;     */&#10;    private void createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            NotificationChannel channel = new NotificationChannel(&#10;                CHANNEL_ID,&#10;                &quot;Dịch vụ nhắc nhở sức khỏe&quot;,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            );&#10;            channel.setDescription(&quot;Dịch vụ chạy ngầm để đảm bảo nhắc nhở hoạt động&quot;);&#10;            channel.setShowBadge(false);&#10;&#10;            NotificationManager manager = getSystemService(NotificationManager.class);&#10;            manager.createNotificationChannel(channel);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Tạo notification cho foreground service&#10;     */&#10;    private Notification createForegroundNotification() {&#10;        Intent intent = new Intent(this, HomeActivity.class);&#10;        intent.putExtra(&quot;open_reminders&quot;, true);&#10;&#10;        PendingIntent pendingIntent = PendingIntent.getActivity(&#10;            this,&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#10;        );&#10;&#10;        return new NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(&quot;Dịch vụ nhắc nhở đang hoạt động&quot;)&#10;            .setContentText(&quot;Đảm bảo bạn nhận được thông báo đúng giờ&quot;)&#10;            .setSmallIcon(R.drawable.ic_notification_reminder)&#10;            .setContentIntent(pendingIntent)&#10;            .setOngoing(true)&#10;            .setPriority(NotificationCompat.PRIORITY_LOW)&#10;            .setVisibility(NotificationCompat.VISIBILITY_SECRET)&#10;            .build();&#10;    }&#10;&#10;    /**&#10;     * Xử lý hiển thị reminder&#10;     */&#10;    private void handleShowReminder(Intent intent) {&#10;        String reminderId = intent.getStringExtra(&quot;reminder_id&quot;);&#10;        String title = intent.getStringExtra(&quot;title&quot;);&#10;        String message = intent.getStringExtra(&quot;message&quot;);&#10;&#10;        Log.d(TAG, &quot;Handling show reminder: &quot; + title);&#10;&#10;        if (title != null &amp;&amp; message != null) {&#10;            // Hiển thị thông báo nhắc nhở&#10;            NotificationService.showReminderNotification(this, title, message, reminderId);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Static method để start service và hiển thị reminder&#10;     */&#10;    public static void showReminder(Context context, String reminderId, String title, String message) {&#10;        Intent serviceIntent = new Intent(context, ReminderForegroundService.class);&#10;        serviceIntent.setAction(&quot;SHOW_REMINDER&quot;);&#10;        serviceIntent.putExtra(&quot;reminder_id&quot;, reminderId);&#10;        serviceIntent.putExtra(&quot;title&quot;, title);&#10;        serviceIntent.putExtra(&quot;message&quot;, message);&#10;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            context.startForegroundService(serviceIntent);&#10;        } else {&#10;            context.startService(serviceIntent);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Static method để start service&#10;     */&#10;    public static void startService(Context context) {&#10;        Intent serviceIntent = new Intent(context, ReminderForegroundService.class);&#10;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            context.startForegroundService(serviceIntent);&#10;        } else {&#10;            context.startService(serviceIntent);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Static method để stop service&#10;     */&#10;    public static void stopService(Context context) {&#10;        Intent serviceIntent = new Intent(context, ReminderForegroundService.class);&#10;        context.stopService(serviceIntent);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.services;&#10;&#10;import android.app.Notification;&#10;import android.app.NotificationChannel;&#10;import android.app.NotificationManager;&#10;import android.app.PendingIntent;&#10;import android.app.Service;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.os.Build;&#10;import android.os.IBinder;&#10;import android.os.PowerManager;&#10;import android.util.Log;&#10;&#10;import androidx.annotation.Nullable;&#10;import androidx.core.app.NotificationCompat;&#10;&#10;import com.vhn.doan.R;&#10;import com.vhn.doan.presentation.home.HomeActivity;&#10;&#10;/**&#10; * Foreground Service để đảm bảo thông báo nhắc nhở hoạt động mạnh mẽ&#10; * Service này sẽ chạy trong background và không bị kill bởi hệ thống&#10; */&#10;public class ReminderForegroundService extends Service {&#10;&#10;    private static final String TAG = &quot;ReminderForegroundService&quot;;&#10;    private static final int FOREGROUND_NOTIFICATION_ID = 9999;&#10;    private static final String CHANNEL_ID = &quot;reminder_foreground_channel&quot;;&#10;&#10;    private PowerManager.WakeLock wakeLock;&#10;    private NotificationManager notificationManager;&#10;&#10;    @Override&#10;    public void onCreate() {&#10;        super.onCreate();&#10;        Log.d(TAG, &quot;ReminderForegroundService created&quot;);&#10;&#10;        // Tạo notification channel&#10;        createNotificationChannel();&#10;&#10;        // Acquire wake lock&#10;        PowerManager powerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);&#10;        wakeLock = powerManager.newWakeLock(&#10;            PowerManager.PARTIAL_WAKE_LOCK,&#10;            &quot;HealthTips:ReminderForegroundService&quot;&#10;        );&#10;        wakeLock.acquire();&#10;&#10;        notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);&#10;    }&#10;&#10;    @Override&#10;    public int onStartCommand(Intent intent, int flags, int startId) {&#10;        Log.d(TAG, &quot;ReminderForegroundService started&quot;);&#10;        &#10;        try {&#10;            // Bắt đầu chạy foreground với delay nhỏ để tránh lỗi&#10;            startForeground(FOREGROUND_NOTIFICATION_ID, createForegroundNotification());&#10;            &#10;            // Xử lý intent nếu có&#10;            if (intent != null) {&#10;                String action = intent.getAction();&#10;                if (&quot;SHOW_REMINDER&quot;.equals(action)) {&#10;                    handleShowReminder(intent);&#10;                }&#10;            }&#10;            &#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error starting foreground service&quot;, e);&#10;            // Nếu không thể start foreground, fallback về normal notification&#10;            handleFallbackNotification(intent);&#10;            stopSelf();&#10;            return START_NOT_STICKY;&#10;        }&#10;        &#10;        // Return STICKY để service tự động restart nếu bị kill&#10;        return START_STICKY;&#10;    }&#10;&#10;    @Override&#10;    public void onDestroy() {&#10;        super.onDestroy();&#10;        Log.d(TAG, &quot;ReminderForegroundService destroyed&quot;);&#10;&#10;        if (wakeLock != null &amp;&amp; wakeLock.isHeld()) {&#10;            wakeLock.release();&#10;        }&#10;    }&#10;&#10;    @Nullable&#10;    @Override&#10;    public IBinder onBind(Intent intent) {&#10;        return null;&#10;    }&#10;&#10;    /**&#10;     * Tạo notification channel cho foreground service&#10;     */&#10;    private void createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            NotificationChannel channel = new NotificationChannel(&#10;                CHANNEL_ID,&#10;                &quot;Dịch vụ nhắc nhở sức khỏe&quot;,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            );&#10;            channel.setDescription(&quot;Dịch vụ chạy ngầm để đảm bảo nhắc nhở hoạt động&quot;);&#10;            channel.setShowBadge(false);&#10;&#10;            NotificationManager manager = getSystemService(NotificationManager.class);&#10;            manager.createNotificationChannel(channel);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Tạo notification cho foreground service&#10;     */&#10;    private Notification createForegroundNotification() {&#10;        Intent intent = new Intent(this, HomeActivity.class);&#10;        intent.putExtra(&quot;open_reminders&quot;, true);&#10;&#10;        PendingIntent pendingIntent = PendingIntent.getActivity(&#10;            this,&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#10;        );&#10;&#10;        return new NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(&quot;Dịch vụ nhắc nhở đang hoạt động&quot;)&#10;            .setContentText(&quot;Đảm bảo bạn nhận được thông báo đúng giờ&quot;)&#10;            .setSmallIcon(R.drawable.ic_notification_reminder)&#10;            .setContentIntent(pendingIntent)&#10;            .setOngoing(true)&#10;            .setPriority(NotificationCompat.PRIORITY_LOW)&#10;            .setVisibility(NotificationCompat.VISIBILITY_SECRET)&#10;            .build();&#10;    }&#10;&#10;    /**&#10;     * Xử lý hiển thị reminder&#10;     */&#10;    private void handleShowReminder(Intent intent) {&#10;        String reminderId = intent.getStringExtra(&quot;reminder_id&quot;);&#10;        String title = intent.getStringExtra(&quot;title&quot;);&#10;        String message = intent.getStringExtra(&quot;message&quot;);&#10;&#10;        Log.d(TAG, &quot;Handling show reminder: &quot; + title);&#10;&#10;        if (title != null &amp;&amp; message != null) {&#10;            // Hiển thị thông báo nhắc nhở&#10;            NotificationService.showReminderNotification(this, title, message, reminderId);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Static method để start service và hiển thị reminder&#10;     */&#10;    public static void showReminder(Context context, String reminderId, String title, String message) {&#10;        Intent serviceIntent = new Intent(context, ReminderForegroundService.class);&#10;        serviceIntent.setAction(&quot;SHOW_REMINDER&quot;);&#10;        serviceIntent.putExtra(&quot;reminder_id&quot;, reminderId);&#10;        serviceIntent.putExtra(&quot;title&quot;, title);&#10;        serviceIntent.putExtra(&quot;message&quot;, message);&#10;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            context.startForegroundService(serviceIntent);&#10;        } else {&#10;            context.startService(serviceIntent);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Static method để start service&#10;     */&#10;    public static void startService(Context context) {&#10;        Intent serviceIntent = new Intent(context, ReminderForegroundService.class);&#10;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            context.startForegroundService(serviceIntent);&#10;        } else {&#10;            context.startService(serviceIntent);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Static method để stop service&#10;     */&#10;    public static void stopService(Context context) {&#10;        Intent serviceIntent = new Intent(context, ReminderForegroundService.class);&#10;        context.stopService(serviceIntent);&#10;    }&#10;&#10;    /**&#10;     * Fallback khi không thể start foreground service&#10;     */&#10;    private void handleFallbackNotification(Intent intent) {&#10;        if (intent != null &amp;&amp; &quot;SHOW_REMINDER&quot;.equals(intent.getAction())) {&#10;            String reminderId = intent.getStringExtra(&quot;reminder_id&quot;);&#10;            String title = intent.getStringExtra(&quot;title&quot;);&#10;            String message = intent.getStringExtra(&quot;message&quot;);&#10;            &#10;            if (title != null &amp;&amp; message != null) {&#10;                // Hiển thị thông báo trực tiếp mà không cần foreground service&#10;                NotificationService.showReminderNotification(this, title, message, reminderId);&#10;                Log.d(TAG, &quot;Showed notification via fallback method&quot;);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/services/ReminderService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/services/ReminderService.java" />
              <option name="originalContent" value="package com.vhn.doan.services;&#10;&#10;import android.app.AlarmManager;&#10;import android.app.PendingIntent;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.os.Build;&#10;import android.os.PowerManager;&#10;import android.util.Log;&#10;&#10;import androidx.work.Data;&#10;import androidx.work.OneTimeWorkRequest;&#10;import androidx.work.WorkManager;&#10;&#10;import com.vhn.doan.data.Reminder;&#10;import com.vhn.doan.receivers.ReminderBroadcastReceiver;&#10;import com.vhn.doan.workers.ReminderWorker;&#10;&#10;import java.util.Calendar;&#10;import java.util.Date;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;/**&#10; * Service để quản lý và lên lịch thông báo nhắc nhở&#10; * Sử dụng cả AlarmManager và WorkManager để đảm bảo hoạt động trong mọi tình huống&#10; */&#10;public class ReminderService {&#10;&#10;    private static final String TAG = &quot;ReminderService&quot;;&#10;    public static final String ACTION_REMINDER_TRIGGER = &quot;com.vhn.doan.REMINDER_TRIGGER&quot;;&#10;&#10;    private Context context;&#10;    private AlarmManager alarmManager;&#10;    private PowerManager.WakeLock wakeLock;&#10;&#10;    public ReminderService(Context context) {&#10;        this.context = context;&#10;        this.alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);&#10;&#10;        // Tạo wake lock để đảm bảo thiết bị không sleep khi xử lý alarm&#10;        PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);&#10;        wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, &quot;HealthTips:ReminderWakeLock&quot;);&#10;    }&#10;&#10;    /**&#10;     * Lên lịch thông báo nhắc nhở với cả AlarmManager và WorkManager&#10;     */&#10;    public void scheduleReminder(Reminder reminder) {&#10;        Log.d(TAG, &quot;=== BẮT ĐẦU SCHEDULE REMINDER ===&quot;);&#10;        Log.d(TAG, &quot;Reminder ID: &quot; + reminder.getId());&#10;        Log.d(TAG, &quot;Title: &quot; + reminder.getTitle());&#10;        Log.d(TAG, &quot;Description: &quot; + reminder.getDescription());&#10;        Log.d(TAG, &quot;Is Active: &quot; + reminder.isActive());&#10;        Log.d(TAG, &quot;Repeat Type: &quot; + reminder.getRepeatType());&#10;&#10;        if (reminder == null || reminder.getReminderTime() == null || !reminder.isActive()) {&#10;            Log.w(TAG, &quot;Reminder không hợp lệ - bỏ qua scheduling&quot;);&#10;            return;&#10;        }&#10;&#10;        long reminderTimeMillis = reminder.getReminderTime(); // getReminderTime() đã trả về Long&#10;        long currentTime = System.currentTimeMillis();&#10;&#10;        Log.d(TAG, &quot;Current time: &quot; + new Date(currentTime));&#10;        Log.d(TAG, &quot;Reminder time: &quot; + new Date(reminderTimeMillis));&#10;&#10;        if (reminderTimeMillis &lt;= currentTime) {&#10;            Log.w(TAG, &quot;Thời gian nhắc nhở đã qua - bỏ qua scheduling&quot;);&#10;            return;&#10;        }&#10;&#10;        // Schedule với cả hai phương pháp để đảm bảo độ tin cậy&#10;        scheduleWithAlarmManager(reminder, reminderTimeMillis);&#10;        scheduleWithWorkManager(reminder, reminderTimeMillis - currentTime);&#10;&#10;        Log.d(TAG, &quot;=== KẾT THÚC SCHEDULE REMINDER ===&quot;);&#10;    }&#10;&#10;    /**&#10;     * Schedule với AlarmManager (cho instant delivery)&#10;     */&#10;    private void scheduleWithAlarmManager(Reminder reminder, long reminderTimeMillis) {&#10;        try {&#10;            Intent intent = new Intent(context, ReminderBroadcastReceiver.class);&#10;            intent.setAction(ACTION_REMINDER_TRIGGER);&#10;            intent.putExtra(&quot;reminder_id&quot;, reminder.getId());&#10;            intent.putExtra(&quot;title&quot;, reminder.getTitle());&#10;            intent.putExtra(&quot;message&quot;, reminder.getDescription());&#10;&#10;            PendingIntent pendingIntent = PendingIntent.getBroadcast(&#10;                context,&#10;                reminder.getId().hashCode(),&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#10;            );&#10;&#10;            // Sử dụng setExactAndAllowWhileIdle để hoạt động trong Doze mode&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                alarmManager.setExactAndAllowWhileIdle(&#10;                    AlarmManager.RTC_WAKEUP,&#10;                    reminderTimeMillis,&#10;                    pendingIntent&#10;                );&#10;                Log.d(TAG, &quot;AlarmManager: Đã schedule với setExactAndAllowWhileIdle&quot;);&#10;            } else {&#10;                alarmManager.setExact(&#10;                    AlarmManager.RTC_WAKEUP,&#10;                    reminderTimeMillis,&#10;                    pendingIntent&#10;                );&#10;                Log.d(TAG, &quot;AlarmManager: Đã schedule với setExact&quot;);&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Lỗi khi schedule AlarmManager&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Schedule với WorkManager (backup cho reliability)&#10;     */&#10;    private void scheduleWithWorkManager(Reminder reminder, long delayMillis) {&#10;        try {&#10;            Data inputData = new Data.Builder()&#10;                .putString(ReminderWorker.KEY_REMINDER_ID, reminder.getId())&#10;                .putString(ReminderWorker.KEY_TITLE, reminder.getTitle())&#10;                .putString(ReminderWorker.KEY_MESSAGE, reminder.getDescription())&#10;                .build();&#10;&#10;            OneTimeWorkRequest workRequest = new OneTimeWorkRequest.Builder(ReminderWorker.class)&#10;                .setInitialDelay(delayMillis, TimeUnit.MILLISECONDS)&#10;                .setInputData(inputData)&#10;                .addTag(&quot;reminder_&quot; + reminder.getId())&#10;                .build();&#10;&#10;            WorkManager.getInstance(context).enqueue(workRequest);&#10;            Log.d(TAG, &quot;WorkManager: Đã schedule work request với delay &quot; + delayMillis + &quot;ms&quot;);&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Lỗi khi schedule WorkManager&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Hủy thông báo nhắc nhở&#10;     */&#10;    public static void cancelReminder(Context context, String reminderId) {&#10;        Log.d(TAG, &quot;Hủy reminder: &quot; + reminderId);&#10;&#10;        try {&#10;            // Hủy AlarmManager&#10;            AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);&#10;            Intent intent = new Intent(context, ReminderBroadcastReceiver.class);&#10;            intent.setAction(ACTION_REMINDER_TRIGGER);&#10;&#10;            PendingIntent pendingIntent = PendingIntent.getBroadcast(&#10;                context,&#10;                reminderId.hashCode(),&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#10;            );&#10;&#10;            alarmManager.cancel(pendingIntent);&#10;            Log.d(TAG, &quot;Đã hủy AlarmManager cho reminder: &quot; + reminderId);&#10;&#10;            // Hủy WorkManager&#10;            WorkManager.getInstance(context).cancelAllWorkByTag(&quot;reminder_&quot; + reminderId);&#10;            Log.d(TAG, &quot;Đã hủy WorkManager cho reminder: &quot; + reminderId);&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Lỗi khi hủy reminder&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Test thông báo ngay lập tức&#10;     */&#10;    public void testNotification(Reminder reminder) {&#10;        Log.d(TAG, &quot;Test thông báo cho reminder: &quot; + reminder.getTitle());&#10;&#10;        // Hiển thị thông báo ngay&#10;        NotificationService.showReminderNotification(&#10;            context,&#10;            reminder.getTitle(),&#10;            reminder.getDescription(),&#10;            reminder.getId()&#10;        );&#10;&#10;        // Schedule một thông báo test sau 5 giây&#10;        scheduleTestNotification(reminder, 5000);&#10;    }&#10;&#10;    /**&#10;     * Schedule test notification sau một khoảng thời gian ngắn&#10;     */&#10;    private void scheduleTestNotification(Reminder reminder, long delayMillis) {&#10;        try {&#10;            long triggerTime = System.currentTimeMillis() + delayMillis;&#10;&#10;            // Test với AlarmManager&#10;            Intent intent = new Intent(context, ReminderBroadcastReceiver.class);&#10;            intent.setAction(ACTION_REMINDER_TRIGGER);&#10;            intent.putExtra(&quot;reminder_id&quot;, reminder.getId());&#10;            intent.putExtra(&quot;title&quot;, &quot;[TEST] &quot; + reminder.getTitle());&#10;            intent.putExtra(&quot;message&quot;, &quot;[TEST] &quot; + reminder.getDescription());&#10;&#10;            PendingIntent pendingIntent = PendingIntent.getBroadcast(&#10;                context,&#10;                (&quot;test_&quot; + reminder.getId()).hashCode(),&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#10;            );&#10;&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                alarmManager.setExactAndAllowWhileIdle(&#10;                    AlarmManager.RTC_WAKEUP,&#10;                    triggerTime,&#10;                    pendingIntent&#10;                );&#10;            } else {&#10;                alarmManager.setExact(&#10;                    AlarmManager.RTC_WAKEUP,&#10;                    triggerTime,&#10;                    pendingIntent&#10;                );&#10;            }&#10;&#10;            Log.d(TAG, &quot;Đã schedule test notification sau &quot; + delayMillis + &quot;ms&quot;);&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Lỗi khi schedule test notification&quot;, e);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.services;&#10;&#10;import android.app.AlarmManager;&#10;import android.app.PendingIntent;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.os.Build;&#10;import android.os.PowerManager;&#10;import android.util.Log;&#10;&#10;import androidx.work.Data;&#10;import androidx.work.OneTimeWorkRequest;&#10;import androidx.work.WorkManager;&#10;&#10;import com.vhn.doan.data.Reminder;&#10;import com.vhn.doan.receivers.ReminderBroadcastReceiver;&#10;import com.vhn.doan.workers.ReminderWorker;&#10;&#10;import java.util.Calendar;&#10;import java.util.Date;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;/**&#10; * Service để quản lý và lên lịch thông báo nhắc nhở&#10; * Sử dụng cả AlarmManager và WorkManager để đảm bảo hoạt động trong mọi tình huống&#10; */&#10;public class ReminderService {&#10;&#10;    private static final String TAG = &quot;ReminderService&quot;;&#10;    public static final String ACTION_REMINDER_TRIGGER = &quot;com.vhn.doan.REMINDER_TRIGGER&quot;;&#10;&#10;    private Context context;&#10;    private AlarmManager alarmManager;&#10;    private PowerManager.WakeLock wakeLock;&#10;&#10;    public ReminderService(Context context) {&#10;        this.context = context;&#10;        this.alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);&#10;&#10;        // Tạo wake lock để đảm bảo thiết bị không sleep khi xử lý alarm&#10;        PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);&#10;        wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, &quot;HealthTips:ReminderWakeLock&quot;);&#10;    }&#10;&#10;    /**&#10;     * Lên lịch thông báo nhắc nhở với cả AlarmManager và WorkManager&#10;     */&#10;    public void scheduleReminder(Reminder reminder) {&#10;        Log.d(TAG, &quot;=== BẮT ĐẦU SCHEDULE REMINDER ===&quot;);&#10;        Log.d(TAG, &quot;Reminder ID: &quot; + reminder.getId());&#10;        Log.d(TAG, &quot;Title: &quot; + reminder.getTitle());&#10;        Log.d(TAG, &quot;Description: &quot; + reminder.getDescription());&#10;        Log.d(TAG, &quot;Is Active: &quot; + reminder.isActive());&#10;        Log.d(TAG, &quot;Repeat Type: &quot; + reminder.getRepeatType());&#10;&#10;        if (reminder == null || reminder.getReminderTime() == null || !reminder.isActive()) {&#10;            Log.w(TAG, &quot;Reminder không hợp lệ - bỏ qua scheduling&quot;);&#10;            return;&#10;        }&#10;&#10;        long reminderTimeMillis = reminder.getReminderTime(); // getReminderTime() đã trả về Long&#10;        long currentTime = System.currentTimeMillis();&#10;&#10;        Log.d(TAG, &quot;Current time: &quot; + new Date(currentTime));&#10;        Log.d(TAG, &quot;Reminder time: &quot; + new Date(reminderTimeMillis));&#10;&#10;        if (reminderTimeMillis &lt;= currentTime) {&#10;            Log.w(TAG, &quot;Thời gian nhắc nhở đã qua - bỏ qua scheduling&quot;);&#10;            return;&#10;        }&#10;&#10;        // Schedule với cả hai phương pháp để đảm bảo độ tin cậy&#10;        scheduleWithAlarmManager(reminder, reminderTimeMillis);&#10;        scheduleWithWorkManager(reminder, reminderTimeMillis - currentTime);&#10;&#10;        Log.d(TAG, &quot;=== KẾT THÚC SCHEDULE REMINDER ===&quot;);&#10;    }&#10;&#10;    /**&#10;     * Schedule với AlarmManager (cho instant delivery)&#10;     */&#10;    private void scheduleWithAlarmManager(Reminder reminder, long reminderTimeMillis) {&#10;        try {&#10;            Intent intent = new Intent(context, ReminderBroadcastReceiver.class);&#10;            intent.setAction(ACTION_REMINDER_TRIGGER);&#10;            intent.putExtra(&quot;reminder_id&quot;, reminder.getId());&#10;            intent.putExtra(&quot;title&quot;, reminder.getTitle());&#10;            intent.putExtra(&quot;message&quot;, reminder.getDescription());&#10;&#10;            PendingIntent pendingIntent = PendingIntent.getBroadcast(&#10;                context,&#10;                reminder.getId().hashCode(),&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#10;            );&#10;&#10;            // Sử dụng setAlarmClock để có độ ưu tiên cao nhất (bỏ qua Doze mode hoàn toàn)&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {&#10;                // Tạo intent để mở app khi click notification từ alarm clock&#10;                Intent showIntent = new Intent(context, com.vhn.doan.presentation.home.HomeActivity.class);&#10;                showIntent.putExtra(&quot;open_reminders&quot;, true);&#10;                PendingIntent showPendingIntent = PendingIntent.getActivity(&#10;                    context, &#10;                    reminder.getId().hashCode() + 1000, &#10;                    showIntent, &#10;                    PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#10;                );&#10;&#10;                AlarmManager.AlarmClockInfo alarmClockInfo = new AlarmManager.AlarmClockInfo(&#10;                    reminderTimeMillis, &#10;                    showPendingIntent&#10;                );&#10;                &#10;                alarmManager.setAlarmClock(alarmClockInfo, pendingIntent);&#10;                Log.d(TAG, &quot;AlarmManager: Đã schedule với setAlarmClock (cao nhất priority)&quot;);&#10;            } else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                alarmManager.setExactAndAllowWhileIdle(&#10;                    AlarmManager.RTC_WAKEUP,&#10;                    reminderTimeMillis,&#10;                    pendingIntent&#10;                );&#10;                Log.d(TAG, &quot;AlarmManager: Đã schedule với setExactAndAllowWhileIdle&quot;);&#10;            } else {&#10;                alarmManager.setExact(&#10;                    AlarmManager.RTC_WAKEUP,&#10;                    reminderTimeMillis,&#10;                    pendingIntent&#10;                );&#10;                Log.d(TAG, &quot;AlarmManager: Đã schedule với setExact&quot;);&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Lỗi khi schedule AlarmManager&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Schedule với WorkManager (backup cho reliability)&#10;     */&#10;    private void scheduleWithWorkManager(Reminder reminder, long delayMillis) {&#10;        try {&#10;            Data inputData = new Data.Builder()&#10;                .putString(ReminderWorker.KEY_REMINDER_ID, reminder.getId())&#10;                .putString(ReminderWorker.KEY_TITLE, reminder.getTitle())&#10;                .putString(ReminderWorker.KEY_MESSAGE, reminder.getDescription())&#10;                .build();&#10;&#10;            OneTimeWorkRequest workRequest = new OneTimeWorkRequest.Builder(ReminderWorker.class)&#10;                .setInitialDelay(delayMillis, TimeUnit.MILLISECONDS)&#10;                .setInputData(inputData)&#10;                .addTag(&quot;reminder_&quot; + reminder.getId())&#10;                .build();&#10;&#10;            WorkManager.getInstance(context).enqueue(workRequest);&#10;            Log.d(TAG, &quot;WorkManager: Đã schedule work request với delay &quot; + delayMillis + &quot;ms&quot;);&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Lỗi khi schedule WorkManager&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Hủy thông báo nhắc nhở&#10;     */&#10;    public static void cancelReminder(Context context, String reminderId) {&#10;        Log.d(TAG, &quot;Hủy reminder: &quot; + reminderId);&#10;&#10;        try {&#10;            // Hủy AlarmManager&#10;            AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);&#10;            Intent intent = new Intent(context, ReminderBroadcastReceiver.class);&#10;            intent.setAction(ACTION_REMINDER_TRIGGER);&#10;&#10;            PendingIntent pendingIntent = PendingIntent.getBroadcast(&#10;                context,&#10;                reminderId.hashCode(),&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#10;            );&#10;&#10;            alarmManager.cancel(pendingIntent);&#10;            Log.d(TAG, &quot;Đã hủy AlarmManager cho reminder: &quot; + reminderId);&#10;&#10;            // Hủy WorkManager&#10;            WorkManager.getInstance(context).cancelAllWorkByTag(&quot;reminder_&quot; + reminderId);&#10;            Log.d(TAG, &quot;Đã hủy WorkManager cho reminder: &quot; + reminderId);&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Lỗi khi hủy reminder&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Test thông báo ngay lập tức&#10;     */&#10;    public void testNotification(Reminder reminder) {&#10;        Log.d(TAG, &quot;Test thông báo cho reminder: &quot; + reminder.getTitle());&#10;&#10;        // Hiển thị thông báo ngay&#10;        NotificationService.showReminderNotification(&#10;            context,&#10;            reminder.getTitle(),&#10;            reminder.getDescription(),&#10;            reminder.getId()&#10;        );&#10;&#10;        // Schedule một thông báo test sau 5 giây&#10;        scheduleTestNotification(reminder, 5000);&#10;    }&#10;&#10;    /**&#10;     * Schedule test notification sau một khoảng thời gian ngắn&#10;     */&#10;    private void scheduleTestNotification(Reminder reminder, long delayMillis) {&#10;        try {&#10;            long triggerTime = System.currentTimeMillis() + delayMillis;&#10;&#10;            // Test với AlarmManager&#10;            Intent intent = new Intent(context, ReminderBroadcastReceiver.class);&#10;            intent.setAction(ACTION_REMINDER_TRIGGER);&#10;            intent.putExtra(&quot;reminder_id&quot;, reminder.getId());&#10;            intent.putExtra(&quot;title&quot;, &quot;[TEST] &quot; + reminder.getTitle());&#10;            intent.putExtra(&quot;message&quot;, &quot;[TEST] &quot; + reminder.getDescription());&#10;&#10;            PendingIntent pendingIntent = PendingIntent.getBroadcast(&#10;                context,&#10;                (&quot;test_&quot; + reminder.getId()).hashCode(),&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#10;            );&#10;&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                alarmManager.setExactAndAllowWhileIdle(&#10;                    AlarmManager.RTC_WAKEUP,&#10;                    triggerTime,&#10;                    pendingIntent&#10;                );&#10;            } else {&#10;                alarmManager.setExact(&#10;                    AlarmManager.RTC_WAKEUP,&#10;                    triggerTime,&#10;                    pendingIntent&#10;                );&#10;            }&#10;&#10;            Log.d(TAG, &quot;Đã schedule test notification sau &quot; + delayMillis + &quot;ms&quot;);&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Lỗi khi schedule test notification&quot;, e);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/utils/PermissionHelper.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/utils/PermissionHelper.java" />
              <option name="originalContent" value="package com.vhn.doan.utils;&#10;&#10;import android.Manifest;&#10;import android.app.AlertDialog;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.content.pm.PackageManager;&#10;import android.os.Build;&#10;import android.os.PowerManager;&#10;import androidx.core.app.ActivityCompat;&#10;import androidx.core.content.ContextCompat;&#10;import androidx.fragment.app.Fragment;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Helper class để quản lý quyền ứng dụng&#10; */&#10;public class PermissionHelper {&#10;&#10;    // Mã yêu cầu quyền cho reminder&#10;    public static final int PERMISSION_REQUEST_REMINDER = 1001;&#10;&#10;    // Quyền cần thiết cho tính năng reminder - chỉ cần thông báo&#10;    private static final String[] REMINDER_PERMISSIONS = {&#10;            Manifest.permission.POST_NOTIFICATIONS&#10;    };&#10;&#10;    // Map để lưu trữ callback theo fragment hashCode&#10;    private static final Map&lt;Integer, PermissionCallback&gt; callbackMap = new HashMap&lt;&gt;();&#10;&#10;    /**&#10;     * Interface callback cho việc xử lý kết quả quyền&#10;     */&#10;    public interface PermissionCallback {&#10;        void onPermissionsGranted();&#10;        void onPermissionsDenied(List&lt;String&gt; deniedPermissions);&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra xem tất cả quyền reminder đã được cấp chưa (bao gồm tối ưu hóa pin)&#10;     */&#10;    public static boolean hasReminderPermissions(Context context) {&#10;        // Kiểm tra quyền thông báo cơ bản&#10;        boolean hasNotificationPermission = hasBasicNotificationPermission(context);&#10;&#10;        // Kiểm tra tối ưu hóa pin&#10;        boolean isBatteryOptimizationIgnored = isBatteryOptimizationIgnored(context);&#10;&#10;        return hasNotificationPermission &amp;&amp; isBatteryOptimizationIgnored;&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra quyền thông báo cơ bản&#10;     */&#10;    public static boolean hasBasicNotificationPermission(Context context) {&#10;        // Đối với Android 13+ mới cần kiểm tra POST_NOTIFICATIONS&#10;        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.TIRAMISU) {&#10;            return true; // Không cần quyền thông báo cho Android &lt; 13&#10;        }&#10;&#10;        return ContextCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS)&#10;                == PackageManager.PERMISSION_GRANTED;&#10;    }&#10;&#10;    /**&#10;     * ✅ THÊM: Kiểm tra xem app có bị tối ưu hóa pin không&#10;     */&#10;    public static boolean isBatteryOptimizationIgnored(Context context) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;            PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);&#10;            return powerManager.isIgnoringBatteryOptimizations(context.getPackageName());&#10;        }&#10;        return true; // Android &lt; 6.0 không có Doze Mode&#10;    }&#10;&#10;    /**&#10;     * Lấy danh sách quyền chưa được cấp (bao gồm tối ưu hóa pin)&#10;     */&#10;    public static List&lt;String&gt; getMissingReminderPermissions(Context context) {&#10;        List&lt;String&gt; missingPermissions = new ArrayList&lt;&gt;();&#10;&#10;        // Kiểm tra quyền thông báo&#10;        if (!hasBasicNotificationPermission(context)) {&#10;            missingPermissions.add(Manifest.permission.POST_NOTIFICATIONS);&#10;        }&#10;&#10;        // Kiểm tra tối ưu hóa pin&#10;        if (!isBatteryOptimizationIgnored(context)) {&#10;            missingPermissions.add(&quot;BATTERY_OPTIMIZATION&quot;);&#10;        }&#10;&#10;        return missingPermissions;&#10;    }&#10;&#10;    /**&#10;     * Hiển thị dialog giải thích tại sao cần quyền và yêu cầu cấp quyền (cập nhật)&#10;     */&#10;    public static void showPermissionExplanationDialog(Fragment fragment,&#10;                                                      PermissionCallback callback) {&#10;        if (fragment.getContext() == null) {&#10;            return;&#10;        }&#10;&#10;        List&lt;String&gt; missingPermissions = getMissingReminderPermissions(fragment.getContext());&#10;        if (missingPermissions.isEmpty()) {&#10;            callback.onPermissionsGranted();&#10;            return;&#10;        }&#10;&#10;        String message = buildPermissionMessage(missingPermissions);&#10;&#10;        new AlertDialog.Builder(fragment.getContext())&#10;                .setTitle(&quot;Cần cấp quyền&quot;)&#10;                .setMessage(message)&#10;                .setPositiveButton(&quot;Cấp quyền&quot;, (dialog, which) -&gt; {&#10;                    dialog.dismiss();&#10;                    requestPermissions(fragment, missingPermissions, callback);&#10;                })&#10;                .setNegativeButton(&quot;Hủy&quot;, (dialog, which) -&gt; {&#10;                    dialog.dismiss();&#10;                    callback.onPermissionsDenied(missingPermissions);&#10;                })&#10;                .setCancelable(false)&#10;                .show();&#10;    }&#10;&#10;    /**&#10;     * Yêu cầu cấp quyền (cập nhật để xử lý tối ưu hóa pin)&#10;     */&#10;    private static void requestPermissions(Fragment fragment,&#10;                                         List&lt;String&gt; permissions,&#10;                                         PermissionCallback callback) {&#10;        // Lưu callback vào map với key là hashCode của fragment&#10;        int fragmentKey = fragment.hashCode();&#10;        callbackMap.put(fragmentKey, callback);&#10;&#10;        // Kiểm tra xem có cần yêu cầu tối ưu hóa pin không&#10;        boolean needsBatteryOptimization = permissions.contains(&quot;BATTERY_OPTIMIZATION&quot;);&#10;        boolean needsNotificationPermission = permissions.contains(Manifest.permission.POST_NOTIFICATIONS);&#10;&#10;        if (needsBatteryOptimization) {&#10;            // Ưu tiên xử lý tối ưu hóa pin trước&#10;            requestIgnoreBatteryOptimization(fragment, callback);&#10;        } else if (needsNotificationPermission) {&#10;            // Chỉ yêu cầu quyền thông báo&#10;            String[] permissionArray = {Manifest.permission.POST_NOTIFICATIONS};&#10;            fragment.requestPermissions(permissionArray, PERMISSION_REQUEST_REMINDER);&#10;        } else {&#10;            // Không có quyền nào cần yêu cầu&#10;            callback.onPermissionsGranted();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * ✅ THÊM: Yêu cầu tắt tối ưu hóa pin&#10;     */&#10;    private static void requestIgnoreBatteryOptimization(Fragment fragment, PermissionCallback callback) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;            try {&#10;                String packageName = fragment.requireContext().getPackageName();&#10;                Intent intent = new Intent(android.provider.Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);&#10;                intent.setData(android.net.Uri.parse(&quot;package:&quot; + packageName));&#10;                fragment.startActivity(intent);&#10;&#10;                // Hiển thị thông báo hướng dẫn&#10;                new AlertDialog.Builder(fragment.getContext())&#10;                    .setTitle(&quot;Tối ưu hóa pin&quot;)&#10;                    .setMessage(&quot;Vui lòng chọn \&quot;Cho phép\&quot; để đảm bảo nhắc nhở hoạt động khi app ở chế độ nền.\n\nSau khi cài đặt xong, vui lòng quay lại app.&quot;)&#10;                    .setPositiveButton(&quot;Đã hiểu&quot;, (dialog, which) -&gt; {&#10;                        // Kiểm tra lại sau khi người dùng quay lại&#10;                        checkPermissionsAfterBatteryOptimization(fragment, callback);&#10;                    })&#10;                    .setCancelable(false)&#10;                    .show();&#10;&#10;            } catch (Exception e) {&#10;                android.util.Log.e(&quot;PermissionHelper&quot;, &quot;Lỗi khi mở cài đặt tối ưu hóa pin&quot;, e);&#10;                callback.onPermissionsDenied(java.util.Arrays.asList(&quot;BATTERY_OPTIMIZATION&quot;));&#10;            }&#10;        } else {&#10;            callback.onPermissionsGranted();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * ✅ THÊM: Kiểm tra quyền sau khi cài đặt tối ưu hóa pin&#10;     */&#10;    private static void checkPermissionsAfterBatteryOptimization(Fragment fragment, PermissionCallback callback) {&#10;        if (fragment.getContext() == null) return;&#10;&#10;        // Kiểm tra lại tất cả quyền&#10;        List&lt;String&gt; stillMissingPermissions = getMissingReminderPermissions(fragment.getContext());&#10;&#10;        if (stillMissingPermissions.isEmpty()) {&#10;            callback.onPermissionsGranted();&#10;        } else if (stillMissingPermissions.contains(Manifest.permission.POST_NOTIFICATIONS)) {&#10;            // Vẫn cần quyền thông báo&#10;            String[] permissionArray = {Manifest.permission.POST_NOTIFICATIONS};&#10;            fragment.requestPermissions(permissionArray, PERMISSION_REQUEST_REMINDER);&#10;        } else {&#10;            callback.onPermissionsDenied(stillMissingPermissions);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Tạo thông điệp giải thích về quyền cần thiết (cập nhật)&#10;     */&#10;    private static String buildPermissionMessage(List&lt;String&gt; missingPermissions) {&#10;        StringBuilder message = new StringBuilder();&#10;        message.append(&quot;Ứng dụng cần các quyền sau để nhắc nhở hoạt động ổn định:\n\n&quot;);&#10;&#10;        for (String permission : missingPermissions) {&#10;            switch (permission) {&#10;                case Manifest.permission.POST_NOTIFICATIONS:&#10;                    message.append(&quot;• Thông báo: Để hiển thị nhắc nhở đúng thời gian\n&quot;);&#10;                    break;&#10;                case &quot;BATTERY_OPTIMIZATION&quot;:&#10;                    message.append(&quot;• Tắt tối ưu hóa pin: Để nhắc nhở hoạt động khi app ở chế độ nền\n&quot;);&#10;                    break;&#10;            }&#10;        }&#10;&#10;        message.append(&quot;\nBạn có muốn cấp quyền để sử dụng đầy đủ tính năng không?&quot;);&#10;        return message.toString();&#10;    }&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.utils;&#13;&#10;&#13;&#10;import android.Manifest;&#13;&#10;import android.app.AlertDialog;&#13;&#10;import android.content.Context;&#13;&#10;import android.content.Intent;&#13;&#10;import android.content.pm.PackageManager;&#13;&#10;import android.os.Build;&#13;&#10;import android.os.PowerManager;&#13;&#10;import androidx.core.app.ActivityCompat;&#13;&#10;import androidx.core.content.ContextCompat;&#13;&#10;import androidx.fragment.app.Fragment;&#13;&#10;import java.util.ArrayList;&#13;&#10;import java.util.List;&#13;&#10;import java.util.HashMap;&#13;&#10;import java.util.Map;&#13;&#10;&#13;&#10;/**&#13;&#10; * Helper class để quản lý quyền ứng dụng&#13;&#10; */&#13;&#10;public class PermissionHelper {&#13;&#10;&#13;&#10;    // Mã yêu cầu quyền cho reminder&#13;&#10;    public static final int PERMISSION_REQUEST_REMINDER = 1001;&#13;&#10;&#13;&#10;    // Quyền cần thiết cho tính năng reminder - chỉ cần thông báo&#13;&#10;    private static final String[] REMINDER_PERMISSIONS = {&#13;&#10;            Manifest.permission.POST_NOTIFICATIONS&#13;&#10;    };&#13;&#10;&#13;&#10;    // Map để lưu trữ callback theo fragment hashCode&#13;&#10;    private static final Map&lt;Integer, PermissionCallback&gt; callbackMap = new HashMap&lt;&gt;();&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Interface callback cho việc xử lý kết quả quyền&#13;&#10;     */&#13;&#10;    public interface PermissionCallback {&#13;&#10;        void onPermissionsGranted();&#13;&#10;        void onPermissionsDenied(List&lt;String&gt; deniedPermissions);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Kiểm tra xem tất cả quyền reminder đã được cấp chưa (bao gồm tối ưu hóa pin)&#13;&#10;     */&#13;&#10;    public static boolean hasReminderPermissions(Context context) {&#13;&#10;        // Kiểm tra quyền thông báo cơ bản&#13;&#10;        boolean hasNotificationPermission = hasBasicNotificationPermission(context);&#13;&#10;&#13;&#10;        // Kiểm tra tối ưu hóa pin&#13;&#10;        boolean isBatteryOptimizationIgnored = isBatteryOptimizationIgnored(context);&#13;&#10;&#13;&#10;        return hasNotificationPermission &amp;&amp; isBatteryOptimizationIgnored;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Kiểm tra quyền thông báo cơ bản&#13;&#10;     */&#13;&#10;    public static boolean hasBasicNotificationPermission(Context context) {&#13;&#10;        // Đối với Android 13+ mới cần kiểm tra POST_NOTIFICATIONS&#13;&#10;        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.TIRAMISU) {&#13;&#10;            return true; // Không cần quyền thông báo cho Android &lt; 13&#13;&#10;        }&#13;&#10;&#13;&#10;        return ContextCompat.checkSelfPermission(context, Manifest.permission.POST_NOTIFICATIONS)&#13;&#10;                == PackageManager.PERMISSION_GRANTED;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * ✅ THÊM: Kiểm tra xem app có bị tối ưu hóa pin không&#13;&#10;     */&#13;&#10;    public static boolean isBatteryOptimizationIgnored(Context context) {&#13;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#13;&#10;            PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);&#13;&#10;            return powerManager.isIgnoringBatteryOptimizations(context.getPackageName());&#13;&#10;        }&#13;&#10;        return true; // Android &lt; 6.0 không có Doze Mode&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Lấy danh sách quyền chưa được cấp (bao gồm tối ưu hóa pin)&#13;&#10;     */&#13;&#10;    public static List&lt;String&gt; getMissingReminderPermissions(Context context) {&#13;&#10;        List&lt;String&gt; missingPermissions = new ArrayList&lt;&gt;();&#13;&#10;&#13;&#10;        // Kiểm tra quyền thông báo&#13;&#10;        if (!hasBasicNotificationPermission(context)) {&#13;&#10;            missingPermissions.add(Manifest.permission.POST_NOTIFICATIONS);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Kiểm tra tối ưu hóa pin&#13;&#10;        if (!isBatteryOptimizationIgnored(context)) {&#13;&#10;            missingPermissions.add(&quot;BATTERY_OPTIMIZATION&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        return missingPermissions;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Hiển thị dialog giải thích tại sao cần quyền và yêu cầu cấp quyền (cập nhật)&#13;&#10;     */&#13;&#10;    public static void showPermissionExplanationDialog(Fragment fragment,&#13;&#10;                                                      PermissionCallback callback) {&#13;&#10;        if (fragment.getContext() == null) {&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        List&lt;String&gt; missingPermissions = getMissingReminderPermissions(fragment.getContext());&#13;&#10;        if (missingPermissions.isEmpty()) {&#13;&#10;            callback.onPermissionsGranted();&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        String message = buildPermissionMessage(missingPermissions);&#13;&#10;&#13;&#10;        new AlertDialog.Builder(fragment.getContext())&#13;&#10;                .setTitle(&quot;Cần cấp quyền&quot;)&#13;&#10;                .setMessage(message)&#13;&#10;                .setPositiveButton(&quot;Cấp quyền&quot;, (dialog, which) -&gt; {&#13;&#10;                    dialog.dismiss();&#13;&#10;                    requestPermissions(fragment, missingPermissions, callback);&#13;&#10;                })&#13;&#10;                .setNegativeButton(&quot;Hủy&quot;, (dialog, which) -&gt; {&#13;&#10;                    dialog.dismiss();&#13;&#10;                    callback.onPermissionsDenied(missingPermissions);&#13;&#10;                })&#13;&#10;                .setCancelable(false)&#13;&#10;                .show();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Yêu cầu cấp quyền (cập nhật để xử lý tối ưu hóa pin)&#13;&#10;     */&#13;&#10;    private static void requestPermissions(Fragment fragment,&#13;&#10;                                         List&lt;String&gt; permissions,&#13;&#10;                                         PermissionCallback callback) {&#13;&#10;        // Lưu callback vào map với key là hashCode của fragment&#13;&#10;        int fragmentKey = fragment.hashCode();&#13;&#10;        callbackMap.put(fragmentKey, callback);&#13;&#10;&#13;&#10;        // Kiểm tra xem có cần yêu cầu tối ưu hóa pin không&#13;&#10;        boolean needsBatteryOptimization = permissions.contains(&quot;BATTERY_OPTIMIZATION&quot;);&#13;&#10;        boolean needsNotificationPermission = permissions.contains(Manifest.permission.POST_NOTIFICATIONS);&#13;&#10;&#13;&#10;        if (needsBatteryOptimization) {&#13;&#10;            // Ưu tiên xử lý tối ưu hóa pin trước&#13;&#10;            requestIgnoreBatteryOptimization(fragment, callback);&#13;&#10;        } else if (needsNotificationPermission) {&#13;&#10;            // Chỉ yêu cầu quyền thông báo&#13;&#10;            String[] permissionArray = {Manifest.permission.POST_NOTIFICATIONS};&#13;&#10;            fragment.requestPermissions(permissionArray, PERMISSION_REQUEST_REMINDER);&#13;&#10;        } else {&#13;&#10;            // Không có quyền nào cần yêu cầu&#13;&#10;            callback.onPermissionsGranted();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * ✅ THÊM: Yêu cầu tắt tối ưu hóa pin&#13;&#10;     */&#13;&#10;    private static void requestIgnoreBatteryOptimization(Fragment fragment, PermissionCallback callback) {&#13;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#13;&#10;            try {&#13;&#10;                String packageName = fragment.requireContext().getPackageName();&#13;&#10;                Intent intent = new Intent(android.provider.Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);&#13;&#10;                intent.setData(android.net.Uri.parse(&quot;package:&quot; + packageName));&#13;&#10;                fragment.startActivity(intent);&#13;&#10;&#13;&#10;                // Hiển thị thông báo hướng dẫn&#13;&#10;                new AlertDialog.Builder(fragment.getContext())&#13;&#10;                    .setTitle(&quot;Tối ưu hóa pin&quot;)&#13;&#10;                    .setMessage(&quot;Vui lòng chọn \&quot;Cho phép\&quot; để đảm bảo nhắc nhở hoạt động khi app ở chế độ nền.\n\nSau khi cài đặt xong, vui lòng quay lại app.&quot;)&#13;&#10;                    .setPositiveButton(&quot;Đã hiểu&quot;, (dialog, which) -&gt; {&#13;&#10;                        // Kiểm tra lại sau khi người dùng quay lại&#13;&#10;                        checkPermissionsAfterBatteryOptimization(fragment, callback);&#13;&#10;                    })&#13;&#10;                    .setCancelable(false)&#13;&#10;                    .show();&#13;&#10;&#13;&#10;            } catch (Exception e) {&#13;&#10;                android.util.Log.e(&quot;PermissionHelper&quot;, &quot;Lỗi khi mở cài đặt tối ưu hóa pin&quot;, e);&#13;&#10;                callback.onPermissionsDenied(java.util.Arrays.asList(&quot;BATTERY_OPTIMIZATION&quot;));&#13;&#10;            }&#13;&#10;        } else {&#13;&#10;            callback.onPermissionsGranted();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * ✅ THÊM: Kiểm tra quyền sau khi cài đặt tối ưu hóa pin&#13;&#10;     */&#13;&#10;    private static void checkPermissionsAfterBatteryOptimization(Fragment fragment, PermissionCallback callback) {&#13;&#10;        if (fragment.getContext() == null) return;&#13;&#10;&#13;&#10;        // Kiểm tra lại tất cả quyền&#13;&#10;        List&lt;String&gt; stillMissingPermissions = getMissingReminderPermissions(fragment.getContext());&#13;&#10;&#13;&#10;        if (stillMissingPermissions.isEmpty()) {&#13;&#10;            callback.onPermissionsGranted();&#13;&#10;        } else if (stillMissingPermissions.contains(Manifest.permission.POST_NOTIFICATIONS)) {&#13;&#10;            // Vẫn cần quyền thông báo&#13;&#10;            String[] permissionArray = {Manifest.permission.POST_NOTIFICATIONS};&#13;&#10;            fragment.requestPermissions(permissionArray, PERMISSION_REQUEST_REMINDER);&#13;&#10;        } else {&#13;&#10;            callback.onPermissionsDenied(stillMissingPermissions);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Tạo thông điệp giải thích về quyền cần thiết (cập nhật)&#13;&#10;     */&#13;&#10;    private static String buildPermissionMessage(List&lt;String&gt; missingPermissions) {&#13;&#10;        StringBuilder message = new StringBuilder();&#13;&#10;        message.append(&quot;Ứng dụng cần các quyền sau để nhắc nhở hoạt động ổn định:\n\n&quot;);&#13;&#10;&#13;&#10;        for (String permission : missingPermissions) {&#13;&#10;            switch (permission) {&#13;&#10;                case Manifest.permission.POST_NOTIFICATIONS:&#13;&#10;                    message.append(&quot;• Thông báo: Để hiển thị nhắc nhở đúng thời gian\n&quot;);&#13;&#10;                    break;&#13;&#10;                case &quot;BATTERY_OPTIMIZATION&quot;:&#13;&#10;                    message.append(&quot;• Tắt tối ưu hóa pin: Để nhắc nhở hoạt động khi app ở chế độ nền\n&quot;);&#13;&#10;                    break;&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        message.append(&quot;\nBạn có muốn cấp quyền để sử dụng đầy đủ tính năng không?&quot;);&#13;&#10;        return message.toString();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Xử lý kết quả yêu cầu quyền&#13;&#10;     */&#13;&#10;    public static void handlePermissionResult(Fragment fragment,&#13;&#10;                                            int requestCode,&#13;&#10;                                            String[] permissions,&#13;&#10;                                            int[] grantResults) {&#13;&#10;        if (requestCode != PERMISSION_REQUEST_REMINDER) {&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        // Lấy callback từ map&#13;&#10;        int fragmentKey = fragment.hashCode();&#13;&#10;        PermissionCallback callback = callbackMap.get(fragmentKey);&#13;&#10;        if (callback == null) {&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        List&lt;String&gt; deniedPermissions = new ArrayList&lt;&gt;();&#13;&#10;        for (int i = 0; i &lt; permissions.length; i++) {&#13;&#10;            if (grantResults[i] != PackageManager.PERMISSION_GRANTED) {&#13;&#10;                deniedPermissions.add(permissions[i]);&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        if (deniedPermissions.isEmpty()) {&#13;&#10;            callback.onPermissionsGranted();&#13;&#10;        } else {&#13;&#10;            callback.onPermissionsDenied(deniedPermissions);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Xóa callback khỏi map&#13;&#10;        callbackMap.remove(fragmentKey);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Kiểm tra xem có nên hiển thị giải thích quyền hay không&#13;&#10;     */&#13;&#10;    public static boolean shouldShowRequestPermissionRationale(Fragment fragment, String permission) {&#13;&#10;        return fragment.shouldShowRequestPermissionRationale(permission);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Kiểm tra xem có quyền thông báo hay không&#13;&#10;     */&#13;&#10;    public static boolean hasNotificationPermission(Context context) {&#13;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#13;&#10;            return ContextCompat.checkSelfPermission(context,&#13;&#10;                Manifest.permission.POST_NOTIFICATIONS) == PackageManager.PERMISSION_GRANTED;&#13;&#10;        }&#13;&#10;        return true; // Android &lt; 13 không cần quyền thông báo runtime&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Yêu cầu quyền thông báo&#13;&#10;     */&#13;&#10;    public static void requestNotificationPermission(Fragment fragment, NotificationPermissionCallback callback) {&#13;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#13;&#10;            // Lưu callback&#13;&#10;            int fragmentKey = fragment.hashCode();&#13;&#10;            notificationCallbackMap.put(fragmentKey, callback);&#13;&#10;&#13;&#10;            // Yêu cầu quyền&#13;&#10;            fragment.requestPermissions(&#13;&#10;                new String[]{Manifest.permission.POST_NOTIFICATIONS},&#13;&#10;                PERMISSION_REQUEST_REMINDER&#13;&#10;            );&#13;&#10;        } else {&#13;&#10;            // Android &lt; 13 tự động có quyền&#13;&#10;            callback.onResult(true);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Interface callback cho quyền thông báo&#13;&#10;     */&#13;&#10;    public interface NotificationPermissionCallback {&#13;&#10;        void onResult(boolean granted);&#13;&#10;    }&#13;&#10;&#13;&#10;    // Map để lưu notification permission callbacks&#13;&#10;    private static final Map&lt;Integer, NotificationPermissionCallback&gt; notificationCallbackMap = new HashMap&lt;&gt;();&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/utils/ReminderPermissionHelper.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/utils/ReminderPermissionHelper.java" />
              <option name="updatedContent" value="package com.vhn.doan.utils;&#10;&#10;import android.app.AlertDialog;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.net.Uri;&#10;import android.os.Build;&#10;import android.os.PowerManager;&#10;import android.provider.Settings;&#10;import android.util.Log;&#10;&#10;import androidx.fragment.app.Fragment;&#10;&#10;/**&#10; * Helper class để quản lý các quyền đặc biệt cần thiết cho hệ thống nhắc nhở&#10; */&#10;public class ReminderPermissionHelper {&#10;    &#10;    private static final String TAG = &quot;ReminderPermissionHelper&quot;;&#10;&#10;    /**&#10;     * Kiểm tra và yêu cầu tất cả quyền cần thiết cho reminder&#10;     */&#10;    public static void checkAndRequestAllPermissions(Fragment fragment, ReminderPermissionCallback callback) {&#10;        Context context = fragment.getContext();&#10;        if (context == null) {&#10;            callback.onError(&quot;Context is null&quot;);&#10;            return;&#10;        }&#10;&#10;        // Kiểm tra quyền thông báo&#10;        if (!PermissionHelper.hasNotificationPermission(context)) {&#10;            showPermissionDialog(fragment, &quot;Quyền thông báo&quot;, &#10;                &quot;Ứng dụng cần quyền hiển thị thông báo để nhắc nhở bạn về sức khỏe.&quot;,&#10;                () -&gt; PermissionHelper.requestNotificationPermission(fragment, callback::onNotificationPermissionResult));&#10;            return;&#10;        }&#10;&#10;        // Kiểm tra quyền exact alarm&#10;        if (!hasExactAlarmPermission(context)) {&#10;            showPermissionDialog(fragment, &quot;Quyền báo thức chính xác&quot;, &#10;                &quot;Ứng dụng cần quyền đặt báo thức chính xác để thông báo đúng giờ.&quot;,&#10;                () -&gt; requestExactAlarmPermission(fragment));&#10;            return;&#10;        }&#10;&#10;        // Kiểm tra tối ưu hóa pin&#10;        if (!isBatteryOptimizationDisabled(context)) {&#10;            showBatteryOptimizationDialog(fragment, callback);&#10;            return;&#10;        }&#10;&#10;        // Tất cả quyền đã được cấp&#10;        callback.onAllPermissionsGranted();&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra quyền exact alarm&#10;     */&#10;    public static boolean hasExactAlarmPermission(Context context) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;            android.app.AlarmManager alarmManager = (android.app.AlarmManager) context.getSystemService(Context.ALARM_SERVICE);&#10;            return alarmManager.canScheduleExactAlarms();&#10;        }&#10;        return true;&#10;    }&#10;&#10;    /**&#10;     * Yêu cầu quyền exact alarm&#10;     */&#10;    public static void requestExactAlarmPermission(Fragment fragment) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;            Intent intent = new Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM);&#10;            intent.setData(Uri.parse(&quot;package:&quot; + fragment.requireContext().getPackageName()));&#10;            fragment.startActivity(intent);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra xem battery optimization có bị tắt không&#10;     */&#10;    public static boolean isBatteryOptimizationDisabled(Context context) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;            PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);&#10;            return powerManager.isIgnoringBatteryOptimizations(context.getPackageName());&#10;        }&#10;        return true;&#10;    }&#10;&#10;    /**&#10;     * Hiển thị dialog yêu cầu tắt battery optimization&#10;     */&#10;    private static void showBatteryOptimizationDialog(Fragment fragment, ReminderPermissionCallback callback) {&#10;        new AlertDialog.Builder(fragment.requireContext())&#10;            .setTitle(&quot;Tối ưu hóa pin&quot;)&#10;            .setMessage(&quot;Để đảm bảo nhắc nhở hoạt động ngay cả khi app bị tắt, vui lòng tắt tối ưu hóa pin cho ứng dụng này.\n\n&quot; +&#10;                       &quot;Điều này sẽ không ảnh hưởng đáng kể đến thời lượng pin của bạn.&quot;)&#10;            .setPositiveButton(&quot;Cài đặt&quot;, (dialog, which) -&gt; {&#10;                requestBatteryOptimizationDisable(fragment);&#10;                dialog.dismiss();&#10;            })&#10;            .setNegativeButton(&quot;Bỏ qua&quot;, (dialog, which) -&gt; {&#10;                dialog.dismiss();&#10;                callback.onBatteryOptimizationDenied();&#10;            })&#10;            .setCancelable(false)&#10;            .show();&#10;    }&#10;&#10;    /**&#10;     * Yêu cầu tắt battery optimization&#10;     */&#10;    public static void requestBatteryOptimizationDisable(Fragment fragment) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;            try {&#10;                Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);&#10;                intent.setData(Uri.parse(&quot;package:&quot; + fragment.requireContext().getPackageName()));&#10;                fragment.startActivity(intent);&#10;            } catch (Exception e) {&#10;                Log.e(TAG, &quot;Failed to open battery optimization settings&quot;, e);&#10;                // Fallback to general battery optimization settings&#10;                Intent intent = new Intent(Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS);&#10;                fragment.startActivity(intent);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Hiển thị dialog thông báo quyền&#10;     */&#10;    private static void showPermissionDialog(Fragment fragment, String title, String message, Runnable onAccept) {&#10;        new AlertDialog.Builder(fragment.requireContext())&#10;            .setTitle(title)&#10;            .setMessage(message)&#10;            .setPositiveButton(&quot;Cấp quyền&quot;, (dialog, which) -&gt; {&#10;                dialog.dismiss();&#10;                onAccept.run();&#10;            })&#10;            .setNegativeButton(&quot;Hủy&quot;, (dialog, which) -&gt; dialog.dismiss())&#10;            .setCancelable(false)&#10;            .show();&#10;    }&#10;&#10;    /**&#10;     * Khởi động foreground service để duy trì hoạt động&#10;     */&#10;    public static void startReminderService(Context context) {&#10;        try {&#10;            com.vhn.doan.services.ReminderForegroundService.startService(context);&#10;            Log.d(TAG, &quot;Reminder foreground service started&quot;);&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Failed to start reminder service&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Interface callback cho permission results&#10;     */&#10;    public interface ReminderPermissionCallback {&#10;        void onAllPermissionsGranted();&#10;        void onNotificationPermissionResult(boolean granted);&#10;        void onBatteryOptimizationDenied();&#10;        void onError(String error);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/workers/ReminderWorker.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/workers/ReminderWorker.java" />
              <option name="originalContent" value="package com.vhn.doan.workers;&#10;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.os.PowerManager;&#10;import android.util.Log;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.work.Worker;&#10;import androidx.work.WorkerParameters;&#10;&#10;import com.vhn.doan.data.Reminder;&#10;import com.vhn.doan.data.repository.ReminderRepository;&#10;import com.vhn.doan.data.repository.ReminderRepositoryImpl;&#10;import com.vhn.doan.data.repository.RepositoryCallback;&#10;import com.vhn.doan.services.NotificationService;&#10;&#10;/**&#10; * WorkManager Worker để xử lý thông báo nhắc nhở&#10; * Hoạt động mạnh mẽ hơn AlarmManager trong việc xử lý Doze mode&#10; */&#10;public class ReminderWorker extends Worker {&#10;&#10;    private static final String TAG = &quot;ReminderWorker&quot;;&#10;&#10;    // Input data keys&#10;    public static final String KEY_REMINDER_ID = &quot;reminder_id&quot;;&#10;    public static final String KEY_TITLE = &quot;title&quot;;&#10;    public static final String KEY_MESSAGE = &quot;message&quot;;&#10;&#10;    public ReminderWorker(@NonNull Context context, @NonNull WorkerParameters workerParams) {&#10;        super(context, workerParams);&#10;    }&#10;&#10;    @NonNull&#10;    @Override&#10;    public Result doWork() {&#10;        Log.d(TAG, &quot;ReminderWorker started&quot;);&#10;&#10;        // Acquire wake lock để đảm bảo thiết bị không sleep&#10;        PowerManager powerManager = (PowerManager) getApplicationContext().getSystemService(Context.POWER_SERVICE);&#10;        PowerManager.WakeLock wakeLock = powerManager.newWakeLock(&#10;            PowerManager.PARTIAL_WAKE_LOCK,&#10;            &quot;HealthTips:ReminderWorker&quot;&#10;        );&#10;&#10;        try {&#10;            wakeLock.acquire(30 * 1000); // 30 giây timeout&#10;&#10;            String reminderId = getInputData().getString(KEY_REMINDER_ID);&#10;            String title = getInputData().getString(KEY_TITLE);&#10;            String message = getInputData().getString(KEY_MESSAGE);&#10;&#10;            Log.d(TAG, &quot;Processing reminder - ID: &quot; + reminderId + &quot;, Title: &quot; + title);&#10;&#10;            if (reminderId == null || title == null || message == null) {&#10;                Log.w(TAG, &quot;Missing reminder data&quot;);&#10;                return Result.failure();&#10;            }&#10;&#10;            // Hiển thị thông báo ngay lập tức&#10;            NotificationService.showReminderNotification(getApplicationContext(), title, message, reminderId);&#10;            Log.d(TAG, &quot;Notification shown successfully&quot;);&#10;&#10;            // Cập nhật trạng thái reminder&#10;            updateReminderStatus(reminderId);&#10;&#10;            return Result.success();&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error in ReminderWorker&quot;, e);&#10;            return Result.failure();&#10;        } finally {&#10;            if (wakeLock.isHeld()) {&#10;                wakeLock.release();&#10;            }&#10;        }&#10;    }&#10;&#10;    private void updateReminderStatus(String reminderId) {&#10;        ReminderRepository reminderRepository = new ReminderRepositoryImpl();&#10;        reminderRepository.getReminderById(reminderId, new RepositoryCallback&lt;Reminder&gt;() {&#10;            @Override&#10;            public void onSuccess(Reminder reminder) {&#10;                if (reminder != null) {&#10;                    Log.d(TAG, &quot;Successfully retrieved reminder for update: &quot; + reminder.getTitle());&#10;&#10;                    // Cập nhật lần thông báo cuối&#10;                    reminder.setLastNotified(System.currentTimeMillis());&#10;&#10;                    // Nếu không phải reminder lặp lại, đánh dấu là đã hoàn thành&#10;                    if (!reminder.isRepeating()) {&#10;                        reminder.setCompleted(true);&#10;                        reminder.setActive(false);&#10;                    }&#10;&#10;                    reminderRepository.updateReminder(reminder, new RepositoryCallback&lt;Void&gt;() {&#10;                        @Override&#10;                        public void onSuccess(Void result) {&#10;                            Log.d(TAG, &quot;Reminder status updated successfully&quot;);&#10;                        }&#10;&#10;                        @Override&#10;                        public void onError(String error) {&#10;                            Log.e(TAG, &quot;Failed to update reminder status: &quot; + error);&#10;                        }&#10;                    });&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                Log.e(TAG, &quot;Failed to retrieve reminder for update: &quot; + error);&#10;            }&#10;        });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.workers;&#10;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.os.PowerManager;&#10;import android.util.Log;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.work.Worker;&#10;import androidx.work.WorkerParameters;&#10;&#10;import com.vhn.doan.data.Reminder;&#10;import com.vhn.doan.data.repository.ReminderRepository;&#10;import com.vhn.doan.data.repository.ReminderRepositoryImpl;&#10;import com.vhn.doan.services.NotificationService;&#10;&#10;/**&#10; * WorkManager Worker để xử lý thông báo nhắc nhở&#10; * Hoạt động mạnh mẽ hơn AlarmManager trong việc xử lý Doze mode&#10; */&#10;public class ReminderWorker extends Worker {&#10;&#10;    private static final String TAG = &quot;ReminderWorker&quot;;&#10;&#10;    // Input data keys&#10;    public static final String KEY_REMINDER_ID = &quot;reminder_id&quot;;&#10;    public static final String KEY_TITLE = &quot;title&quot;;&#10;    public static final String KEY_MESSAGE = &quot;message&quot;;&#10;&#10;    public ReminderWorker(@NonNull Context context, @NonNull WorkerParameters workerParams) {&#10;        super(context, workerParams);&#10;    }&#10;&#10;    @NonNull&#10;    @Override&#10;    public Result doWork() {&#10;        Log.d(TAG, &quot;ReminderWorker started&quot;);&#10;&#10;        // Acquire wake lock để đảm bảo thiết bị không sleep&#10;        PowerManager powerManager = (PowerManager) getApplicationContext().getSystemService(Context.POWER_SERVICE);&#10;        PowerManager.WakeLock wakeLock = powerManager.newWakeLock(&#10;            PowerManager.PARTIAL_WAKE_LOCK,&#10;            &quot;HealthTips:ReminderWorker&quot;&#10;        );&#10;&#10;        try {&#10;            wakeLock.acquire(30 * 1000); // 30 giây timeout&#10;&#10;            String reminderId = getInputData().getString(KEY_REMINDER_ID);&#10;            String title = getInputData().getString(KEY_TITLE);&#10;            String message = getInputData().getString(KEY_MESSAGE);&#10;&#10;            Log.d(TAG, &quot;Processing reminder - ID: &quot; + reminderId + &quot;, Title: &quot; + title);&#10;&#10;            if (reminderId == null || title == null || message == null) {&#10;                Log.w(TAG, &quot;Missing reminder data&quot;);&#10;                return Result.failure();&#10;            }&#10;&#10;            // Hiển thị thông báo ngay lập tức&#10;            NotificationService.showReminderNotification(getApplicationContext(), title, message, reminderId);&#10;            Log.d(TAG, &quot;Notification shown successfully&quot;);&#10;&#10;            // Cập nhật trạng thái reminder&#10;            updateReminderStatus(reminderId);&#10;&#10;            return Result.success();&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error in ReminderWorker&quot;, e);&#10;            return Result.failure();&#10;        } finally {&#10;            if (wakeLock.isHeld()) {&#10;                wakeLock.release();&#10;            }&#10;        }&#10;    }&#10;&#10;    private void updateReminderStatus(String reminderId) {&#10;        ReminderRepository reminderRepository = new ReminderRepositoryImpl();&#10;        reminderRepository.getReminderById(reminderId, new ReminderRepository.RepositoryCallback&lt;Reminder&gt;() {&#10;            @Override&#10;            public void onSuccess(Reminder reminder) {&#10;                if (reminder != null) {&#10;                    Log.d(TAG, &quot;Successfully retrieved reminder for update: &quot; + reminder.getTitle());&#10;&#10;                    // Cập nhật lần thông báo cuối&#10;                    reminder.setLastNotified(System.currentTimeMillis());&#10;&#10;                    // Nếu không phải reminder lặp lại, đánh dấu là đã hoàn thành&#10;                    if (!reminder.isRepeating()) {&#10;                        reminder.setCompleted(true);&#10;                        reminder.setActive(false);&#10;                    }&#10;&#10;                    reminderRepository.updateReminder(reminder, new ReminderRepository.RepositoryCallback&lt;Void&gt;() {&#10;                        @Override&#10;                        public void onSuccess(Void result) {&#10;                            Log.d(TAG, &quot;Reminder status updated successfully&quot;);&#10;                        }&#10;&#10;                        @Override&#10;                        public void onError(String error) {&#10;                            Log.e(TAG, &quot;Failed to update reminder status: &quot; + error);&#10;                        }&#10;                    });&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                Log.e(TAG, &quot;Failed to retrieve reminder for update: &quot; + error);&#10;            }&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/bg_reminder_due.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/bg_reminder_due.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:shape=&quot;rectangle&quot;&gt;&#10;    &#10;    &lt;!-- Màu nền nhấn mạnh cho nhắc nhở đã đến giờ --&gt;&#10;    &lt;solid android:color=&quot;#1AFF5722&quot; /&gt;&#10;    &#10;    &lt;!-- Bo góc --&gt;&#10;    &lt;corners android:radius=&quot;8dp&quot; /&gt;&#10;    &#10;    &lt;!-- Đường viền đỏ cam để làm nổi bật --&gt;&#10;    &lt;stroke&#10;        android:width=&quot;2dp&quot;&#10;        android:color=&quot;@color/status_due&quot; /&gt;&#10;        &#10;&lt;/shape&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/bg_reminder_normal.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/bg_reminder_normal.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:shape=&quot;rectangle&quot;&gt;&#10;    &#10;    &lt;!-- Màu nền bình thường --&gt;&#10;    &lt;solid android:color=&quot;@android:color/transparent&quot; /&gt;&#10;    &#10;    &lt;!-- Bo góc --&gt;&#10;    &lt;corners android:radius=&quot;8dp&quot; /&gt;&#10;    &#10;    &lt;!-- Đường viền nhẹ --&gt;&#10;    &lt;stroke&#10;        android:width=&quot;1dp&quot;&#10;        android:color=&quot;@color/divider_color&quot; /&gt;&#10;        &#10;&lt;/shape&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/bg_repeat_type.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/bg_repeat_type.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:shape=&quot;rectangle&quot;&gt;&#10;    &#10;    &lt;!-- Màu nền trong suốt với tông màu chính --&gt;&#10;    &lt;solid android:color=&quot;#1A4CAF50&quot; /&gt;&#10;    &#10;    &lt;!-- Bo góc tròn --&gt;&#10;    &lt;corners android:radius=&quot;12dp&quot; /&gt;&#10;    &#10;    &lt;!-- Đường viền màu chính --&gt;&#10;    &lt;stroke&#10;        android:width=&quot;1dp&quot;&#10;        android:color=&quot;@color/primary_color&quot; /&gt;&#10;        &#10;&lt;/shape&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_add.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_add.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&#10;    android:tint=&quot;?attr/colorOnSurface&quot;&gt;&#10;  &lt;path&#10;      android:fillColor=&quot;@android:color/white&quot;&#10;      android:pathData=&quot;M19,13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_check.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_check.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&#10;    android:tint=&quot;?attr/colorOnPrimary&quot;&gt;&#10;  &lt;path&#10;      android:fillColor=&quot;@android:color/white&quot;&#10;      android:pathData=&quot;M9,16.17L4.83,12l-1.42,1.41L9,19 21,7l-1.41,-1.41z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_delete.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_delete.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&#10;    android:tint=&quot;?attr/colorOnSurface&quot;&gt;&#10;  &lt;path&#10;      android:fillColor=&quot;@android:color/white&quot;&#10;      android:pathData=&quot;M6,19c0,1.1 0.9,2 2,2h8c1.1,0 2,-0.9 2,-2V7H6v12zM19,4h-3.5l-1,-1h-5l-1,1H5v2h14V4z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_filter_list.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_filter_list.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&#10;    android:tint=&quot;?attr/colorOnSurface&quot;&gt;&#10;  &lt;path&#10;      android:fillColor=&quot;@android:color/white&quot;&#10;      android:pathData=&quot;M10,18h4v-2h-4v2zM3,6v2h18L21,6L3,6zM6,13h12v-2L6,11v2z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_filter_list_off.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_filter_list_off.xml" />
              <option name="updatedContent" value="&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&#10;    android:tint=&quot;?attr/colorOnSurface&quot;&gt;&#10;  &lt;path&#10;      android:fillColor=&quot;@android:color/white&quot;&#10;      android:pathData=&quot;M10.83,8H21V6H8.83l2,2zM12.83,12H21v-2H10.83l2,2zM14.83,16H21v-2h-4.17l2,2zM2.81,2.81L1.39,4.22l4.44,4.44H3v2h4.83l2,2H6v2h5.83l2,2H10v2h5.83l1.95,1.95l1.41-1.41L2.81,2.81z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>