<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/data/ChatApiResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/data/ChatApiResponse.java" />
              <option name="updatedContent" value="package com.vhn.doan.data;&#10;&#10;import java.util.List;&#10;&#10;/**&#10; * Model cho phản hồi từ OpenRouter API&#10; */&#10;public class ChatApiResponse {&#10;    private List&lt;Choice&gt; choices;&#10;    private String error;&#10;&#10;    public ChatApiResponse() {&#10;    }&#10;&#10;    public List&lt;Choice&gt; getChoices() {&#10;        return choices;&#10;    }&#10;&#10;    public void setChoices(List&lt;Choice&gt; choices) {&#10;        this.choices = choices;&#10;    }&#10;&#10;    public String getError() {&#10;        return error;&#10;    }&#10;&#10;    public void setError(String error) {&#10;        this.error = error;&#10;    }&#10;&#10;    public static class Choice {&#10;        private Message message;&#10;&#10;        public Message getMessage() {&#10;            return message;&#10;        }&#10;&#10;        public void setMessage(Message message) {&#10;            this.message = message;&#10;        }&#10;    }&#10;&#10;    public static class Message {&#10;        private String role;&#10;        private String content;&#10;&#10;        public String getRole() {&#10;            return role;&#10;        }&#10;&#10;        public void setRole(String role) {&#10;            this.role = role;&#10;        }&#10;&#10;        public String getContent() {&#10;            return content;&#10;        }&#10;&#10;        public void setContent(String content) {&#10;            this.content = content;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/data/ChatMessage.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/data/ChatMessage.java" />
              <option name="originalContent" value="package com.vhn.doan.data;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * Model cho tin nhắn chat giữa người dùng và AI&#10; */&#10;public class ChatMessage {&#10;    private String id;&#10;    private String userId;&#10;    private String content;&#10;    private boolean isFromUser; // true nếu tin nhắn từ user, false nếu từ AI&#10;    private long timestamp;&#10;    private String topic; // Chủ đề được trích xuất từ nội dung&#10;&#10;    public ChatMessage() {&#10;        // Constructor rỗng cho Firebase&#10;    }&#10;&#10;    public ChatMessage(String userId, String content, boolean isFromUser, long timestamp) {&#10;        this.userId = userId;&#10;        this.content = content;&#10;        this.isFromUser = isFromUser;&#10;        this.timestamp = timestamp;&#10;    }&#10;&#10;    public ChatMessage(String id, String userId, String content, boolean isFromUser, long timestamp, String topic) {&#10;        this.id = id;&#10;        this.userId = userId;&#10;        this.content = content;&#10;        this.isFromUser = isFromUser;&#10;        this.timestamp = timestamp;&#10;        this.topic = topic;&#10;    }&#10;&#10;    // Getters&#10;    public String getId() {&#10;        return id;&#10;    }&#10;&#10;    public String getUserId() {&#10;        return userId;&#10;    }&#10;&#10;    public String getContent() {&#10;        return content;&#10;    }&#10;&#10;    public boolean isFromUser() {&#10;        return isFromUser;&#10;    }&#10;&#10;    public long getTimestamp() {&#10;        return timestamp;&#10;    }&#10;&#10;    public String getTopic() {&#10;        return topic;&#10;    }&#10;&#10;    // Setters&#10;    public void setId(String id) {&#10;        this.id = id;&#10;    }&#10;&#10;    public void setUserId(String userId) {&#10;        this.userId = userId;&#10;    }&#10;&#10;    public void setContent(String content) {&#10;        this.content = content;&#10;    }&#10;&#10;    public void setFromUser(boolean fromUser) {&#10;        isFromUser = fromUser;&#10;    }&#10;&#10;    public void setTimestamp(long timestamp) {&#10;        this.timestamp = timestamp;&#10;    }&#10;&#10;    public void setTopic(String topic) {&#10;        this.topic = topic;&#10;    }&#10;&#10;    /**&#10;     * Chuyển đổi object thành Map để lưu vào Firebase&#10;     */&#10;    public Map&lt;String, Object&gt; toMap() {&#10;        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();&#10;        map.put(&quot;userId&quot;, userId);&#10;        map.put(&quot;content&quot;, content);&#10;        map.put(&quot;isFromUser&quot;, isFromUser);&#10;        map.put(&quot;timestamp&quot;, timestamp);&#10;        map.put(&quot;topic&quot;, topic);&#10;        return map;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;ChatMessage{&quot; +&#10;                &quot;id='&quot; + id + '\'' +&#10;                &quot;, userId='&quot; + userId + '\'' +&#10;                &quot;, content='&quot; + content + '\'' +&#10;                &quot;, isFromUser=&quot; + isFromUser +&#10;                &quot;, timestamp=&quot; + timestamp +&#10;                &quot;, topic='&quot; + topic + '\'' +&#10;                '}';&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.data;&#13;&#10;&#13;&#10;import java.util.HashMap;&#13;&#10;import java.util.Map;&#13;&#10;&#13;&#10;/**&#13;&#10; * Model cho tin nhắn chat giữa người dùng và AI&#13;&#10; */&#13;&#10;public class ChatMessage {&#13;&#10;    private String id;&#13;&#10;    private String conversationId; // ID của cuộc trò chuyện chứa tin nhắn này&#13;&#10;    private String userId;&#13;&#10;    private String content;&#13;&#10;    private boolean isFromUser; // true nếu tin nhắn từ user, false nếu từ AI&#13;&#10;    private long timestamp;&#13;&#10;    private String topic; // Chủ đề được trích xuất từ nội dung&#13;&#10;&#13;&#10;    public ChatMessage() {&#13;&#10;        // Constructor rỗng cho Firebase&#13;&#10;    }&#13;&#10;&#13;&#10;    public ChatMessage(String conversationId, String userId, String content, boolean isFromUser, long timestamp) {&#13;&#10;        this.conversationId = conversationId;&#13;&#10;        this.userId = userId;&#13;&#10;        this.content = content;&#13;&#10;        this.isFromUser = isFromUser;&#13;&#10;        this.timestamp = timestamp;&#13;&#10;    }&#13;&#10;&#13;&#10;    public ChatMessage(String id, String conversationId, String userId, String content, boolean isFromUser, long timestamp, String topic) {&#13;&#10;        this.id = id;&#13;&#10;        this.conversationId = conversationId;&#13;&#10;        this.userId = userId;&#13;&#10;        this.content = content;&#13;&#10;        this.isFromUser = isFromUser;&#13;&#10;        this.timestamp = timestamp;&#13;&#10;        this.topic = topic;&#13;&#10;    }&#13;&#10;&#13;&#10;    // Getters&#13;&#10;    public String getId() {&#13;&#10;        return id;&#13;&#10;    }&#13;&#10;&#13;&#10;    public String getConversationId() {&#13;&#10;        return conversationId;&#13;&#10;    }&#13;&#10;&#13;&#10;    public String getUserId() {&#13;&#10;        return userId;&#13;&#10;    }&#13;&#10;&#13;&#10;    public String getContent() {&#13;&#10;        return content;&#13;&#10;    }&#13;&#10;&#13;&#10;    public boolean isFromUser() {&#13;&#10;        return isFromUser;&#13;&#10;    }&#13;&#10;&#13;&#10;    public long getTimestamp() {&#13;&#10;        return timestamp;&#13;&#10;    }&#13;&#10;&#13;&#10;    public String getTopic() {&#13;&#10;        return topic;&#13;&#10;    }&#13;&#10;&#13;&#10;    // Setters&#13;&#10;    public void setId(String id) {&#13;&#10;        this.id = id;&#13;&#10;    }&#13;&#10;&#13;&#10;    public void setConversationId(String conversationId) {&#13;&#10;        this.conversationId = conversationId;&#13;&#10;    }&#13;&#10;&#13;&#10;    public void setUserId(String userId) {&#13;&#10;        this.userId = userId;&#13;&#10;    }&#13;&#10;&#13;&#10;    public void setContent(String content) {&#13;&#10;        this.content = content;&#13;&#10;    }&#13;&#10;&#13;&#10;    public void setFromUser(boolean fromUser) {&#13;&#10;        isFromUser = fromUser;&#13;&#10;    }&#13;&#10;&#13;&#10;    public void setTimestamp(long timestamp) {&#13;&#10;        this.timestamp = timestamp;&#13;&#10;    }&#13;&#10;&#13;&#10;    public void setTopic(String topic) {&#13;&#10;        this.topic = topic;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Chuyển đổi object thành Map để lưu vào Firebase&#13;&#10;     */&#13;&#10;    public Map&lt;String, Object&gt; toMap() {&#13;&#10;        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();&#13;&#10;        map.put(&quot;conversationId&quot;, conversationId);&#13;&#10;        map.put(&quot;userId&quot;, userId);&#13;&#10;        map.put(&quot;content&quot;, content);&#13;&#10;        map.put(&quot;isFromUser&quot;, isFromUser);&#13;&#10;        map.put(&quot;timestamp&quot;, timestamp);&#13;&#10;        map.put(&quot;topic&quot;, topic);&#13;&#10;        return map;&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public String toString() {&#13;&#10;        return &quot;ChatMessage{&quot; +&#13;&#10;                &quot;id='&quot; + id + '\'' +&#13;&#10;                &quot;, conversationId='&quot; + conversationId + '\'' +&#13;&#10;                &quot;, userId='&quot; + userId + '\'' +&#13;&#10;                &quot;, content='&quot; + content + '\'' +&#13;&#10;                &quot;, isFromUser=&quot; + isFromUser +&#13;&#10;                &quot;, timestamp=&quot; + timestamp +&#13;&#10;                &quot;, topic='&quot; + topic + '\'' +&#13;&#10;                '}';&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/data/repository/ChatRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/data/repository/ChatRepository.java" />
              <option name="originalContent" value="package com.vhn.doan.data.repository;&#10;&#10;import com.vhn.doan.data.ChatMessage;&#10;import com.vhn.doan.data.Conversation;&#10;&#10;import java.util.List;&#10;&#10;/**&#10; * Repository interface cho chức năng Chat với hỗ trợ multiple conversations&#10; */&#10;public interface ChatRepository {&#10;&#10;    /**&#10;     * Gửi tin nhắn tới AI qua OpenRouter API&#10;     * @param message Nội dung tin nhắn&#10;     * @param callback Callback để nhận kết quả&#10;     */&#10;    void sendMessageToAI(String message, RepositoryCallback&lt;String&gt; callback);&#10;&#10;    // ========== CONVERSATION MANAGEMENT ==========&#10;&#10;    /**&#10;     * Tạo cuộc trò chuyện mới&#10;     * @param userId ID người dùng&#10;     * @param firstMessage Tin nhắn đầu tiên để tạo tiêu đề&#10;     * @param callback Callback để nhận kết quả&#10;     */&#10;    void createConversation(String userId, String firstMessage, RepositoryCallback&lt;Conversation&gt; callback);&#10;&#10;    /**&#10;     * Lấy danh sách cuộc trò chuyện của người dùng (có phân trang)&#10;     * @param userId ID người dùng&#10;     * @param limit Số lượng cuộc trò chuyện cần lấy (tối đa 8 cho lần đầu)&#10;     * @param lastConversationTime Thời gian của cuộc trò chuyện cuối cùng (để phân trang)&#10;     * @param callback Callback để nhận kết quả&#10;     */&#10;    void getConversations(String userId, int limit, Long lastConversationTime, RepositoryCallback&lt;List&lt;Conversation&gt;&gt; callback);&#10;&#10;    /**&#10;     * Cập nhật thông tin cuộc trò chuyện (tin nhắn cuối, số lượng tin nhắn)&#10;     * @param conversation Cuộc trò chuyện cần cập nhật&#10;     * @param callback Callback để nhận kết quả&#10;     */&#10;    void updateConversation(Conversation conversation, RepositoryCallback&lt;Conversation&gt; callback);&#10;&#10;    /**&#10;     * Xóa cuộc trò chuyện và tất cả tin nhắn trong đó&#10;     * @param conversationId ID cuộc trò chuyện&#10;     * @param callback Callback để nhận kết quả&#10;     */&#10;    void deleteConversation(String conversationId, RepositoryCallback&lt;Boolean&gt; callback);&#10;&#10;    // ========== MESSAGE MANAGEMENT ==========&#10;&#10;    /**&#10;     * Lưu tin nhắn vào Firebase&#10;     * @param chatMessage Tin nhắn cần lưu&#10;     * @param callback Callback để nhận kết quả&#10;     */&#10;    void saveChatMessage(ChatMessage chatMessage, RepositoryCallback&lt;ChatMessage&gt; callback);&#10;&#10;    /**&#10;     * Lấy danh sách tin nhắn của một cuộc trò chuyện cụ thể&#10;     * @param conversationId ID cuộc trò chuyện&#10;     * @param callback Callback để nhận kết quả&#10;     */&#10;    void getChatMessages(String conversationId, RepositoryCallback&lt;List&lt;ChatMessage&gt;&gt; callback);&#10;&#10;    /**&#10;     * Xóa tất cả tin nhắn trong một cuộc trò chuyện&#10;     * @param conversationId ID cuộc trò chuyện&#10;     * @param callback Callback để nhận kết quả&#10;     */&#10;    void clearChatMessages(String conversationId, RepositoryCallback&lt;Boolean&gt; callback);&#10;&#10;    // ========== UTILITY METHODS ==========&#10;&#10;    /**&#10;     * Trích xuất chủ đề từ nội dung tin nhắn&#10;     * @param content Nội dung tin nhắn&#10;     * @return Chủ đề được trích xuất&#10;     */&#10;    String extractTopic(String content);&#10;&#10;    /**&#10;     * Kiểm tra xem còn cuộc trò chuyện nào để load không&#10;     * @param userId ID người dùng&#10;     * @param lastConversationTime Thời gian cuộc trò chuyện cuối cùng đã load&#10;     * @param callback Callback để nhận kết quả&#10;     */&#10;    void hasMoreConversations(String userId, Long lastConversationTime, RepositoryCallback&lt;Boolean&gt; callback);&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.data.repository;&#10;&#10;import com.vhn.doan.data.ChatMessage;&#10;import com.vhn.doan.data.Conversation;&#10;&#10;import java.util.List;&#10;&#10;/**&#10; * Repository interface cho chức năng Chat với hỗ trợ multiple conversations&#10; */&#10;public interface ChatRepository {&#10;&#10;    /**&#10;     * Gửi tin nhắn tới AI qua OpenRouter API&#10;     * @param message Nội dung tin nhắn&#10;     * @param callback Callback để nhận kết quả&#10;     */&#10;    void sendMessageToAI(String message, RepositoryCallback&lt;String&gt; callback);&#10;&#10;    // ========== CONVERSATION MANAGEMENT ==========&#10;&#10;    /**&#10;     * Tạo cuộc trò chuyện mới&#10;     * @param userId ID người dùng&#10;     * @param firstMessage Tin nhắn đầu tiên để tạo tiêu đề&#10;     * @param callback Callback để nhận kết quả&#10;     */&#10;    void createConversation(String userId, String firstMessage, RepositoryCallback&lt;Conversation&gt; callback);&#10;&#10;    /**&#10;     * Lấy danh sách cuộc trò chuyện của người dùng (có phân trang)&#10;     * @param userId ID người dùng&#10;     * @param limit Số lượng cuộc trò chuyện cần lấy (tối đa 8 cho lần đầu)&#10;     * @param lastConversationTime Thời gian của cuộc trò chuyện cuối cùng (để phân trang)&#10;     * @param callback Callback để nhận kết quả&#10;     */&#10;    void getConversations(String userId, int limit, Long lastConversationTime, RepositoryCallback&lt;List&lt;Conversation&gt;&gt; callback);&#10;&#10;    /**&#10;     * Cập nhật thông tin cuộc trò chuyện (tin nhắn cuối, số lượng tin nhắn)&#10;     * @param conversation Cuộc trò chuyện cần cập nhật&#10;     * @param callback Callback để nhận kết quả&#10;     */&#10;    void updateConversation(Conversation conversation, RepositoryCallback&lt;Conversation&gt; callback);&#10;&#10;    /**&#10;     * Xóa cuộc trò chuyện và tất cả tin nhắn trong đó&#10;     * @param conversationId ID cuộc trò chuyện&#10;     * @param callback Callback để nhận kết quả&#10;     */&#10;    void deleteConversation(String conversationId, RepositoryCallback&lt;Boolean&gt; callback);&#10;&#10;    // ========== MESSAGE MANAGEMENT ==========&#10;&#10;    /**&#10;     * Lưu tin nhắn vào Firebase&#10;     * @param chatMessage Tin nhắn cần lưu&#10;     * @param callback Callback để nhận kết quả&#10;     */&#10;    void saveChatMessage(ChatMessage chatMessage, RepositoryCallback&lt;ChatMessage&gt; callback);&#10;&#10;    /**&#10;     * Lấy danh sách tin nhắn của một cuộc trò chuyện cụ thể&#10;     * @param conversationId ID cuộc trò chuyện&#10;     * @param callback Callback để nhận kết quả&#10;     */&#10;    void getChatMessages(String conversationId, RepositoryCallback&lt;List&lt;ChatMessage&gt;&gt; callback);&#10;&#10;    /**&#10;     * Xóa tất cả tin nhắn trong một cuộc trò chuyện&#10;     * @param conversationId ID cuộc trò chuyện&#10;     * @param callback Callback để nhận kết quả&#10;     */&#10;    void clearChatMessages(String conversationId, RepositoryCallback&lt;Boolean&gt; callback);&#10;&#10;    /**&#10;     * Xóa lịch sử chat của người dùng (tất cả cuộc trò chuyện)&#10;     * @param userId ID người dùng  &#10;     * @param callback Callback để nhận kết quả&#10;     */&#10;    void clearChatHistory(String userId, RepositoryCallback&lt;Boolean&gt; callback);&#10;&#10;    // ========== UTILITY METHODS ==========&#10;&#10;    /**&#10;     * Trích xuất chủ đề từ nội dung tin nhắn&#10;     * @param content Nội dung tin nhắn&#10;     * @return Chủ đề được trích xuất&#10;     */&#10;    String extractTopic(String content);&#10;&#10;    /**&#10;     * Kiểm tra xem còn cuộc trò chuyện nào để load không&#10;     * @param userId ID người dùng&#10;     * @param lastConversationTime Thời gian cuộc trò chuyện cuối cùng đã load&#10;     * @param callback Callback để nhận kết quả&#10;     */&#10;    void hasMoreConversations(String userId, Long lastConversationTime, RepositoryCallback&lt;Boolean&gt; callback);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/data/repository/ChatRepositoryImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/data/repository/ChatRepositoryImpl.java" />
              <option name="originalContent" value="package com.vhn.doan.data.repository;&#10;&#10;import android.os.Handler;&#10;import android.os.Looper;&#10;import android.util.Log;&#10;&#10;import com.google.firebase.database.DataSnapshot;&#10;import com.google.firebase.database.DatabaseError;&#10;import com.google.firebase.database.DatabaseReference;&#10;import com.google.firebase.database.FirebaseDatabase;&#10;import com.google.firebase.database.Query;&#10;import com.google.firebase.database.ValueEventListener;&#10;import com.google.gson.Gson;&#10;import com.google.gson.JsonObject;&#10;import com.google.gson.JsonArray;&#10;import com.vhn.doan.data.ChatMessage;&#10;import com.vhn.doan.data.ChatApiResponse;&#10;import com.vhn.doan.data.Conversation;&#10;&#10;import java.io.IOException;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.List;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;import okhttp3.Call;&#10;import okhttp3.Callback;&#10;import okhttp3.MediaType;&#10;import okhttp3.OkHttpClient;&#10;import okhttp3.Request;&#10;import okhttp3.RequestBody;&#10;import okhttp3.Response;&#10;&#10;/**&#10; * Implementation của ChatRepository với hỗ trợ multiple conversations&#10; */&#10;public class ChatRepositoryImpl implements ChatRepository {&#10;&#10;    private static final String TAG = &quot;ChatRepositoryImpl&quot;;&#10;    private static final String OPENROUTER_API_URL = &quot;https://openrouter.ai/api/v1/chat/completions&quot;;&#10;    // Sử dụng API key mới&#10;    private static final String API_KEY = &quot;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&quot;;&#10;&#10;    // Firebase paths&#10;    private static final String CONVERSATIONS_PATH = &quot;conversations&quot;;&#10;    private static final String CHAT_MESSAGES_PATH = &quot;chat_messages&quot;;&#10;    private static final String USER_TOPICS_PATH = &quot;user_topics&quot;;&#10;&#10;    // Pagination constants&#10;    private static final int DEFAULT_CONVERSATIONS_LIMIT = 8;&#10;    private static final int LOAD_MORE_CONVERSATIONS_LIMIT = 3;&#10;&#10;    private final DatabaseReference database;&#10;    private final OkHttpClient httpClient;&#10;    private final Gson gson;&#10;    private final Handler mainHandler;&#10;&#10;    public ChatRepositoryImpl() {&#10;        this.database = FirebaseDatabase.getInstance().getReference();&#10;        this.httpClient = new OkHttpClient.Builder()&#10;                .connectTimeout(30, TimeUnit.SECONDS)&#10;                .readTimeout(30, TimeUnit.SECONDS)&#10;                .writeTimeout(30, TimeUnit.SECONDS)&#10;                .build();&#10;        this.gson = new Gson();&#10;        this.mainHandler = new Handler(Looper.getMainLooper());&#10;    }&#10;&#10;    // ========== CONVERSATION MANAGEMENT ==========&#10;&#10;    @Override&#10;    public void createConversation(String userId, String firstMessage, RepositoryCallback&lt;Conversation&gt; callback) {&#10;        try {&#10;            long currentTime = System.currentTimeMillis();&#10;            String title = Conversation.generateTitle(firstMessage);&#10;            String topic = extractTopic(firstMessage);&#10;&#10;            Conversation conversation = new Conversation(userId, title, currentTime);&#10;            conversation.setTopic(topic);&#10;&#10;            String conversationId = database.child(CONVERSATIONS_PATH)&#10;                    .child(userId)&#10;                    .push().getKey();&#10;&#10;            if (conversationId != null) {&#10;                conversation.setId(conversationId);&#10;&#10;                database.child(CONVERSATIONS_PATH)&#10;                        .child(userId)&#10;                        .child(conversationId)&#10;                        .setValue(conversation.toMap())&#10;                        .addOnSuccessListener(aVoid -&gt; {&#10;                            Log.d(TAG, &quot;Conversation created successfully: &quot; + conversationId);&#10;                            callback.onSuccess(conversation);&#10;                        })&#10;                        .addOnFailureListener(e -&gt; {&#10;                            Log.e(TAG, &quot;Failed to create conversation&quot;, e);&#10;                            callback.onError(&quot;Không thể tạo cuộc trò chuyện: &quot; + e.getMessage());&#10;                        });&#10;            } else {&#10;                callback.onError(&quot;Không thể tạo ID cho cuộc trò chuyện&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error creating conversation&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi tạo cuộc trò chuyện: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void getConversations(String userId, int limit, Long lastConversationTime, RepositoryCallback&lt;List&lt;Conversation&gt;&gt; callback) {&#10;        try {&#10;            DatabaseReference conversationsRef = database.child(CONVERSATIONS_PATH).child(userId);&#10;&#10;            // Sắp xếp theo lastMessageTime giảm dần (mới nhất trước)&#10;            Query query = conversationsRef.orderByChild(&quot;lastMessageTime&quot;);&#10;&#10;            // Nếu có lastConversationTime, query từ thời điểm đó trở về trước&#10;            if (lastConversationTime != null) {&#10;                query = query.endBefore(lastConversationTime);&#10;            }&#10;&#10;            // Giới hạn số lượng kết quả&#10;            query = query.limitToLast(limit);&#10;&#10;            query.addListenerForSingleValueEvent(new ValueEventListener() {&#10;                @Override&#10;                public void onDataChange(DataSnapshot dataSnapshot) {&#10;                    List&lt;Conversation&gt; conversations = new ArrayList&lt;&gt;();&#10;&#10;                    for (DataSnapshot conversationSnapshot : dataSnapshot.getChildren()) {&#10;                        try {&#10;                            Conversation conversation = parseConversationFromSnapshot(conversationSnapshot);&#10;                            if (conversation != null) {&#10;                                conversations.add(conversation);&#10;                            }&#10;                        } catch (Exception e) {&#10;                            Log.e(TAG, &quot;Error parsing conversation&quot;, e);&#10;                        }&#10;                    }&#10;&#10;                    // Sắp xếp lại theo thời gian giảm dần (mới nhất trước)&#10;                    Collections.sort(conversations, (c1, c2) -&gt;&#10;                        Long.compare(c2.getLastMessageTime(), c1.getLastMessageTime()));&#10;&#10;                    Log.d(TAG, &quot;Loaded &quot; + conversations.size() + &quot; conversations&quot;);&#10;                    callback.onSuccess(conversations);&#10;                }&#10;&#10;                @Override&#10;                public void onCancelled(DatabaseError databaseError) {&#10;                    Log.e(TAG, &quot;Failed to load conversations&quot;, databaseError.toException());&#10;                    callback.onError(&quot;Không thể tải danh sách cuộc trò chuyện: &quot; + databaseError.getMessage());&#10;                }&#10;            });&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error loading conversations&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi tải danh sách cuộc trò chuyện: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void updateConversation(Conversation conversation, RepositoryCallback&lt;Conversation&gt; callback) {&#10;        try {&#10;            if (conversation.getId() == null || conversation.getUserId() == null) {&#10;                callback.onError(&quot;Thông tin cuộc trò chuyện không hợp lệ&quot;);&#10;                return;&#10;            }&#10;&#10;            database.child(CONVERSATIONS_PATH)&#10;                    .child(conversation.getUserId())&#10;                    .child(conversation.getId())&#10;                    .setValue(conversation.toMap())&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Conversation updated successfully: &quot; + conversation.getId());&#10;                        callback.onSuccess(conversation);&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Failed to update conversation&quot;, e);&#10;                        callback.onError(&quot;Không thể cập nhật cuộc trò chuyện: &quot; + e.getMessage());&#10;                    });&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error updating conversation&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi cập nhật cuộc trò chuyện: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void deleteConversation(String conversationId, RepositoryCallback&lt;Boolean&gt; callback) {&#10;        // TODO: Implement delete conversation and all its messages&#10;        callback.onError(&quot;Chức năng xóa cuộc trò chuyện sẽ được triển khai sau&quot;);&#10;    }&#10;&#10;    @Override&#10;    public void hasMoreConversations(String userId, Long lastConversationTime, RepositoryCallback&lt;Boolean&gt; callback) {&#10;        try {&#10;            DatabaseReference conversationsRef = database.child(CONVERSATIONS_PATH).child(userId);&#10;&#10;            Query query = conversationsRef.orderByChild(&quot;lastMessageTime&quot;);&#10;            if (lastConversationTime != null) {&#10;                query = query.endBefore(lastConversationTime);&#10;            }&#10;            query = query.limitToLast(1);&#10;&#10;            query.addListenerForSingleValueEvent(new ValueEventListener() {&#10;                @Override&#10;                public void onDataChange(DataSnapshot dataSnapshot) {&#10;                    boolean hasMore = dataSnapshot.exists() &amp;&amp; dataSnapshot.getChildrenCount() &gt; 0;&#10;                    callback.onSuccess(hasMore);&#10;                }&#10;&#10;                @Override&#10;                public void onCancelled(DatabaseError databaseError) {&#10;                    Log.e(TAG, &quot;Failed to check more conversations&quot;, databaseError.toException());&#10;                    callback.onError(&quot;Không thể kiểm tra cuộc trò chuyện: &quot; + databaseError.getMessage());&#10;                }&#10;            });&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error checking more conversations&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi kiểm tra cuộc trò chuyện: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    // ========== MESSAGE MANAGEMENT ==========&#10;&#10;    @Override&#10;    public void sendMessageToAI(String message, RepositoryCallback&lt;String&gt; callback) {&#10;        try {&#10;            // Tạo JSON request body theo format chính xác của OpenRouter&#10;            JsonObject requestJson = new JsonObject();&#10;            requestJson.addProperty(&quot;model&quot;, &quot;openai/gpt-3.5-turbo&quot;);&#10;&#10;            // Thêm các parameters bổ sung theo yêu cầu OpenRouter&#10;            requestJson.addProperty(&quot;max_tokens&quot;, 1000);&#10;            requestJson.addProperty(&quot;temperature&quot;, 0.7);&#10;&#10;            JsonArray messagesArray = new JsonArray();&#10;&#10;            // System message&#10;            JsonObject systemMessage = new JsonObject();&#10;            systemMessage.addProperty(&quot;role&quot;, &quot;system&quot;);&#10;            systemMessage.addProperty(&quot;content&quot;, &quot;Bạn là trợ lý AI chuyên về sức khỏe. Chỉ trả lời các câu hỏi liên quan đến sức khỏe, y tế, dinh dưỡng, thể dục thể thao. Nếu người dùng hỏi ngoài lĩnh vực sức khỏe thì từ chối một cách lịch sự và đề nghị họ hỏi về sức khỏe.&quot;);&#10;            messagesArray.add(systemMessage);&#10;&#10;            // User message&#10;            JsonObject userMessage = new JsonObject();&#10;            userMessage.addProperty(&quot;role&quot;, &quot;user&quot;);&#10;            userMessage.addProperty(&quot;content&quot;, message);&#10;            messagesArray.add(userMessage);&#10;&#10;            requestJson.add(&quot;messages&quot;, messagesArray);&#10;&#10;            String jsonString = gson.toJson(requestJson);&#10;            Log.d(TAG, &quot;Request JSON: &quot; + jsonString);&#10;&#10;            RequestBody body = RequestBody.create(&#10;                    MediaType.parse(&quot;application/json&quot;),&#10;                    jsonString&#10;            );&#10;&#10;            Request request = new Request.Builder()&#10;                    .url(OPENROUTER_API_URL)&#10;                    .post(body)&#10;                    .addHeader(&quot;Authorization&quot;, &quot;Bearer &quot; + API_KEY)&#10;                    .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                    .addHeader(&quot;HTTP-Referer&quot;, &quot;https://healthtips-vn.app&quot;)&#10;                    .addHeader(&quot;X-Title&quot;, &quot;HealthTips Vietnam&quot;)&#10;                    .build();&#10;&#10;            Log.d(TAG, &quot;Sending request to: &quot; + OPENROUTER_API_URL);&#10;            Log.d(TAG, &quot;Authorization header: Bearer &quot; + API_KEY.substring(0, 20) + &quot;...&quot;);&#10;&#10;            httpClient.newCall(request).enqueue(new Callback() {&#10;                @Override&#10;                public void onFailure(Call call, IOException e) {&#10;                    Log.e(TAG, &quot;Network request failed&quot;, e);&#10;                    mainHandler.post(() -&gt; {&#10;                        callback.onError(&quot;Không thể kết nối đến máy chủ AI. Kiểm tra kết nối mạng của bạn.&quot;);&#10;                    });&#10;                }&#10;&#10;                @Override&#10;                public void onResponse(Call call, Response response) throws IOException {&#10;                    String responseBody = &quot;&quot;;&#10;                    try {&#10;                        if (response.body() != null) {&#10;                            responseBody = response.body().string();&#10;                        }&#10;&#10;                        Log.d(TAG, &quot;Response Code: &quot; + response.code());&#10;                        Log.d(TAG, &quot;Response Headers: &quot; + response.headers().toString());&#10;                        Log.d(TAG, &quot;Response Body: &quot; + responseBody);&#10;&#10;                        if (response.isSuccessful()) {&#10;                            ChatApiResponse apiResponse = gson.fromJson(responseBody, ChatApiResponse.class);&#10;&#10;                            if (apiResponse != null &amp;&amp;&#10;                                apiResponse.getChoices() != null &amp;&amp;&#10;                                !apiResponse.getChoices().isEmpty() &amp;&amp;&#10;                                apiResponse.getChoices().get(0).getMessage() != null) {&#10;&#10;                                String aiMessage = apiResponse.getChoices().get(0).getMessage().getContent();&#10;                                if (aiMessage != null &amp;&amp; !aiMessage.trim().isEmpty()) {&#10;                                    mainHandler.post(() -&gt; callback.onSuccess(aiMessage.trim()));&#10;                                } else {&#10;                                    mainHandler.post(() -&gt; callback.onError(&quot;AI trả về phản hồi trống.&quot;));&#10;                                }&#10;                            } else {&#10;                                mainHandler.post(() -&gt; callback.onError(&quot;Định dạng phản hồi từ AI không hợp lệ.&quot;));&#10;                            }&#10;                        } else {&#10;                            // Xử lý các lỗi HTTP cụ thể&#10;                            String errorMessage = parseErrorMessage(response.code(), responseBody);&#10;                            Log.e(TAG, &quot;API Error: &quot; + errorMessage);&#10;&#10;                            mainHandler.post(() -&gt; callback.onError(errorMessage));&#10;                        }&#10;                    } catch (Exception e) {&#10;                        Log.e(TAG, &quot;Error parsing response&quot;, e);&#10;                        Log.e(TAG, &quot;Response body was: &quot; + responseBody);&#10;&#10;                        mainHandler.post(() -&gt; {&#10;                            callback.onError(&quot;Lỗi xử lý phản hồi từ AI. Vui lòng thử lại.&quot;);&#10;                        });&#10;                    }&#10;                }&#10;            });&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error creating request&quot;, e);&#10;            callback.onError(&quot;Lỗi tạo yêu cầu gửi đến AI.&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Phân tích thông báo lỗi từ API response&#10;     */&#10;    private String parseErrorMessage(int responseCode, String responseBody) {&#10;        try {&#10;            // Thử parse JSON error response&#10;            JsonObject errorResponse = gson.fromJson(responseBody, JsonObject.class);&#10;            if (errorResponse.has(&quot;error&quot;)) {&#10;                JsonObject error = errorResponse.getAsJsonObject(&quot;error&quot;);&#10;                if (error.has(&quot;message&quot;)) {&#10;                    String apiErrorMessage = error.get(&quot;message&quot;).getAsString();&#10;                    Log.d(TAG, &quot;API Error Message: &quot; + apiErrorMessage);&#10;&#10;                    // Dịch một số lỗi phổ biến&#10;                    if (apiErrorMessage.contains(&quot;No auth credentials&quot;)) {&#10;                        return &quot;Lỗi xác thực API. Vui lòng liên hệ quản trị viên.&quot;;&#10;                    } else if (apiErrorMessage.contains(&quot;Rate limit&quot;)) {&#10;                        return &quot;Đã vượt quá giới hạn yêu cầu. Vui lòng thử lại sau ít phút.&quot;;&#10;                    } else if (apiErrorMessage.contains(&quot;Invalid model&quot;)) {&#10;                        return &quot;Mô hình AI không hợp lệ. Vui lòng thử lại.&quot;;&#10;                    }&#10;                    return &quot;Lỗi từ AI: &quot; + apiErrorMessage;&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error parsing error response&quot;, e);&#10;        }&#10;&#10;        // Fallback cho các HTTP status codes&#10;        switch (responseCode) {&#10;            case 401:&#10;                return &quot;Lỗi xác thực. API key có thể đã hết hạn hoặc không hợp lệ.&quot;;&#10;            case 403:&#10;                return &quot;Không có quyền truy cập. Vui lòng kiểm tra cấu hình API.&quot;;&#10;            case 429:&#10;                return &quot;Quá nhiều yêu cầu. Vui lòng chờ một chút rồi thử lại.&quot;;&#10;            case 500:&#10;                return &quot;Lỗi máy chủ AI. Vui lòng thử lại sau.&quot;;&#10;            case 502:&#10;            case 503:&#10;            case 504:&#10;                return &quot;Máy chủ AI tạm thời không khả dụng. Vui lòng thử lại sau.&quot;;&#10;            default:&#10;                return &quot;Lỗi không xác định từ AI (Mã: &quot; + responseCode + &quot;). Vui lòng thử lại.&quot;;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public String extractTopic(String content) {&#10;        try {&#10;            // Các từ khóa chủ đề về sức khỏe&#10;            String[] healthTopics = {&#10;                &quot;tim mạch&quot;, &quot;huyết áp&quot;, &quot;cholesterol&quot;, &quot;đường huyết&quot;, &quot;tiểu đường&quot;,&#10;                &quot;dinh dưỡng&quot;, &quot;vitamin&quot;, &quot;protein&quot;, &quot;carb&quot;, &quot;chất béo&quot;,&#10;                &quot;tập luyện&quot;, &quot;thể dục&quot;, &quot;yoga&quot;, &quot;cardio&quot;, &quot;cơ bắp&quot;,&#10;                &quot;giảm cân&quot;, &quot;tăng cân&quot;, &quot;béo phì&quot;, &quot;ăn kiêng&quot;,&#10;                &quot;stress&quot;, &quot;lo âu&quot;, &quot;trầm cảm&quot;, &quot;tâm lý&quot;, &quot;tinh thần&quot;,&#10;                &quot;giấc ngủ&quot;, &quot;mất ngủ&quot;, &quot;ngủ&quot;, &quot;nghỉ ngơi&quot;,&#10;                &quot;da&quot;, &quot;tóc&quot;, &quot;móng&quot;, &quot;mỹ phẩm&quot;, &quot;chăm sóc da&quot;,&#10;                &quot;mang thai&quot;, &quot;sinh sản&quot;, &quot;kinh nguyệt&quot;, &quot;phụ khoa&quot;,&#10;                &quot;trẻ em&quot;, &quot;em bé&quot;, &quot;sức khỏe trẻ&quot;, &quot;phát triển&quot;,&#10;                &quot;người cao tuổi&quot;, &quot;lão hóa&quot;, &quot;xương khớp&quot;, &quot;cột sống&quot;,&#10;                &quot;mắt&quot;, &quot;thị lực&quot;, &quot;tai&quot;, &quot;thính giác&quot;,&#10;                &quot;răng&quot;, &quot;miệng&quot;, &quot;nha khoa&quot;, &quot;vệ sinh răng miệng&quot;,&#10;                &quot;cảm cúm&quot;, &quot;sốt&quot;, &quot;ho&quot;, &quot;viêm họng&quot;, &quot;virus&quot;,&#10;                &quot;thuốc&quot;, &quot;dược phẩm&quot;, &quot;tác dụng phụ&quot;, &quot;liều dùng&quot;&#10;            };&#10;&#10;            content = content.toLowerCase();&#10;&#10;            for (String topic : healthTopics) {&#10;                if (content.contains(topic)) {&#10;                    return topic;&#10;                }&#10;            }&#10;&#10;            // Nếu không tìm thấy chủ đề cụ thể, trả về chủ đề chung&#10;            return &quot;sức khỏe tổng quát&quot;;&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error extracting topic&quot;, e);&#10;            return &quot;sức khỏe tổng quát&quot;;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lưu chủ đề mà người dùng quan tâm vào Firebase&#10;     */&#10;    private void saveUserTopic(String userId, String topic) {&#10;        try {&#10;            database.child(USER_TOPICS_PATH)&#10;                    .child(userId)&#10;                    .child(topic)&#10;                    .setValue(System.currentTimeMillis())&#10;                    .addOnSuccessListener(aVoid -&gt; Log.d(TAG, &quot;User topic saved: &quot; + topic))&#10;                    .addOnFailureListener(e -&gt; Log.e(TAG, &quot;Failed to save user topic&quot;, e));&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error saving user topic&quot;, e);&#10;        }&#10;    }&#10;&#10;    // ========== HELPER METHODS ==========&#10;&#10;    /**&#10;     * Parse Conversation từ Firebase DataSnapshot&#10;     */&#10;    private Conversation parseConversationFromSnapshot(DataSnapshot snapshot) {&#10;        try {&#10;            Conversation conversation = new Conversation();&#10;            conversation.setId(snapshot.getKey());&#10;            conversation.setUserId(snapshot.child(&quot;userId&quot;).getValue(String.class));&#10;            conversation.setTitle(snapshot.child(&quot;title&quot;).getValue(String.class));&#10;            conversation.setLastMessage(snapshot.child(&quot;lastMessage&quot;).getValue(String.class));&#10;&#10;            Long lastMessageTime = snapshot.child(&quot;lastMessageTime&quot;).getValue(Long.class);&#10;            if (lastMessageTime != null) {&#10;                conversation.setLastMessageTime(lastMessageTime);&#10;            }&#10;&#10;            Boolean isFromUser = snapshot.child(&quot;isFromUser&quot;).getValue(Boolean.class);&#10;            if (isFromUser != null) {&#10;                conversation.setFromUser(isFromUser);&#10;            }&#10;&#10;            Integer messageCount = snapshot.child(&quot;messageCount&quot;).getValue(Integer.class);&#10;            if (messageCount != null) {&#10;                conversation.setMessageCount(messageCount);&#10;            }&#10;&#10;            Long createdTime = snapshot.child(&quot;createdTime&quot;).getValue(Long.class);&#10;            if (createdTime != null) {&#10;                conversation.setCreatedTime(createdTime);&#10;            }&#10;&#10;            conversation.setTopic(snapshot.child(&quot;topic&quot;).getValue(String.class));&#10;            return conversation;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error parsing conversation from snapshot&quot;, e);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Parse ChatMessage từ Firebase DataSnapshot&#10;     */&#10;    private ChatMessage parseChatMessageFromSnapshot(DataSnapshot snapshot) {&#10;        try {&#10;            ChatMessage message = new ChatMessage();&#10;            message.setId(snapshot.getKey());&#10;            message.setConversationId(snapshot.child(&quot;conversationId&quot;).getValue(String.class));&#10;            message.setUserId(snapshot.child(&quot;userId&quot;).getValue(String.class));&#10;            message.setContent(snapshot.child(&quot;content&quot;).getValue(String.class));&#10;&#10;            Boolean isFromUser = snapshot.child(&quot;isFromUser&quot;).getValue(Boolean.class);&#10;            if (isFromUser != null) {&#10;                message.setFromUser(isFromUser);&#10;            }&#10;&#10;            Long timestamp = snapshot.child(&quot;timestamp&quot;).getValue(Long.class);&#10;            if (timestamp != null) {&#10;                message.setTimestamp(timestamp);&#10;            }&#10;&#10;            message.setTopic(snapshot.child(&quot;topic&quot;).getValue(String.class));&#10;            return message;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error parsing message from snapshot&quot;, e);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void clearChatHistory(String userId, RepositoryCallback&lt;Boolean&gt; callback) {&#10;        try {&#10;            // Xóa tất cả cuộc trò chuyện của user&#10;            DatabaseReference userConversationsRef = database.child(CONVERSATIONS_PATH).child(userId);&#10;            &#10;            userConversationsRef.addListenerForSingleValueEvent(new ValueEventListener() {&#10;                @Override&#10;                public void onDataChange(DataSnapshot dataSnapshot) {&#10;                    try {&#10;                        List&lt;String&gt; conversationIds = new ArrayList&lt;&gt;();&#10;                        &#10;                        // Lấy danh sách ID các cuộc trò chuyện&#10;                        for (DataSnapshot conversationSnapshot : dataSnapshot.getChildren()) {&#10;                            conversationIds.add(conversationSnapshot.getKey());&#10;                        }&#10;                        &#10;                        if (conversationIds.isEmpty()) {&#10;                            callback.onSuccess(true);&#10;                            return;&#10;                        }&#10;                        &#10;                        // Xóa từng cuộc trò chuyện và tin nhắn của nó&#10;                        deleteConversationsRecursively(conversationIds, 0, userId, callback);&#10;                        &#10;                    } catch (Exception e) {&#10;                        Log.e(TAG, &quot;Error processing chat history deletion&quot;, e);&#10;                        callback.onError(&quot;Lỗi xử lý xóa lịch sử chat: &quot; + e.getMessage());&#10;                    }&#10;                }&#10;&#10;                @Override&#10;                public void onCancelled(DatabaseError databaseError) {&#10;                    Log.e(TAG, &quot;Error clearing chat history&quot;, databaseError.toException());&#10;                    callback.onError(&quot;Lỗi xóa lịch sử chat: &quot; + databaseError.getMessage());&#10;                }&#10;            });&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error initiating chat history clear&quot;, e);&#10;            callback.onError(&quot;Lỗi khởi tạo xóa lịch sử chat: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Xóa các cuộc trò chuyện một cách đệ quy&#10;     */&#10;    private void deleteConversationsRecursively(List&lt;String&gt; conversationIds, int index, String userId, RepositoryCallback&lt;Boolean&gt; callback) {&#10;        if (index &gt;= conversationIds.size()) {&#10;            // Xóa xong tất cả cuộc trò chuyện, xóa thư mục user trong conversations&#10;            database.child(CONVERSATIONS_PATH).child(userId).removeValue()&#10;                    .addOnSuccessListener(aVoid -&gt; callback.onSuccess(true))&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error removing user conversations folder&quot;, e);&#10;                        callback.onError(&quot;Lỗi xóa thư mục cuộc trò chuyện: &quot; + e.getMessage());&#10;                    });&#10;            return;&#10;        }&#10;&#10;        String conversationId = conversationIds.get(index);&#10;        &#10;        // Xóa tin nhắn của cuộc trò chuyện này trước&#10;        clearChatMessages(conversationId, new RepositoryCallback&lt;Boolean&gt;() {&#10;            @Override&#10;            public void onSuccess(Boolean result) {&#10;                // Sau khi xóa tin nhắn, xóa cuộc trò chuyện&#10;                database.child(CONVERSATIONS_PATH).child(userId).child(conversationId).removeValue()&#10;                        .addOnSuccessListener(aVoid -&gt; {&#10;                            // Tiếp tục xóa cuộc trò chuyện tiếp theo&#10;                            deleteConversationsRecursively(conversationIds, index + 1, userId, callback);&#10;                        })&#10;                        .addOnFailureListener(e -&gt; {&#10;                            Log.e(TAG, &quot;Error deleting conversation: &quot; + conversationId, e);&#10;                            callback.onError(&quot;Lỗi xóa cuộc trò chuyện: &quot; + e.getMessage());&#10;                        });&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                Log.e(TAG, &quot;Error clearing messages for conversation: &quot; + conversationId + &quot;, error: &quot; + error);&#10;                callback.onError(&quot;Lỗi xóa tin nhắn cuộc trò chuyện: &quot; + error);&#10;            }&#10;        });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.data.repository;&#10;&#10;import android.os.Handler;&#10;import android.os.Looper;&#10;import android.util.Log;&#10;&#10;import com.google.firebase.database.DataSnapshot;&#10;import com.google.firebase.database.DatabaseError;&#10;import com.google.firebase.database.DatabaseReference;&#10;import com.google.firebase.database.FirebaseDatabase;&#10;import com.google.firebase.database.Query;&#10;import com.google.firebase.database.ValueEventListener;&#10;import com.google.gson.Gson;&#10;import com.google.gson.JsonObject;&#10;import com.google.gson.JsonArray;&#10;import com.vhn.doan.data.ChatMessage;&#10;import com.vhn.doan.data.ChatApiResponse;&#10;import com.vhn.doan.data.Conversation;&#10;&#10;import java.io.IOException;&#10;import java.util.ArrayList;&#10;import java.util.Collections;&#10;import java.util.List;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;import okhttp3.Call;&#10;import okhttp3.Callback;&#10;import okhttp3.MediaType;&#10;import okhttp3.OkHttpClient;&#10;import okhttp3.Request;&#10;import okhttp3.RequestBody;&#10;import okhttp3.Response;&#10;&#10;/**&#10; * Implementation của ChatRepository với hỗ trợ multiple conversations&#10; */&#10;public class ChatRepositoryImpl implements ChatRepository {&#10;&#10;    private static final String TAG = &quot;ChatRepositoryImpl&quot;;&#10;    private static final String OPENROUTER_API_URL = &quot;https://openrouter.ai/api/v1/chat/completions&quot;;&#10;    // Sử dụng API key mới&#10;    private static final String API_KEY = &quot;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&quot;;&#10;&#10;    // Firebase paths&#10;    private static final String CONVERSATIONS_PATH = &quot;conversations&quot;;&#10;    private static final String CHAT_MESSAGES_PATH = &quot;chat_messages&quot;;&#10;    private static final String USER_TOPICS_PATH = &quot;user_topics&quot;;&#10;&#10;    // Pagination constants&#10;    private static final int DEFAULT_CONVERSATIONS_LIMIT = 8;&#10;    private static final int LOAD_MORE_CONVERSATIONS_LIMIT = 3;&#10;&#10;    private final DatabaseReference database;&#10;    private final OkHttpClient httpClient;&#10;    private final Gson gson;&#10;    private final Handler mainHandler;&#10;&#10;    public ChatRepositoryImpl() {&#10;        this.database = FirebaseDatabase.getInstance().getReference();&#10;        this.httpClient = new OkHttpClient.Builder()&#10;                .connectTimeout(30, TimeUnit.SECONDS)&#10;                .readTimeout(30, TimeUnit.SECONDS)&#10;                .writeTimeout(30, TimeUnit.SECONDS)&#10;                .build();&#10;        this.gson = new Gson();&#10;        this.mainHandler = new Handler(Looper.getMainLooper());&#10;    }&#10;&#10;    // ========== CONVERSATION MANAGEMENT ==========&#10;&#10;    @Override&#10;    public void createConversation(String userId, String firstMessage, RepositoryCallback&lt;Conversation&gt; callback) {&#10;        try {&#10;            long currentTime = System.currentTimeMillis();&#10;            String title = Conversation.generateTitle(firstMessage);&#10;            String topic = extractTopic(firstMessage);&#10;&#10;            Conversation conversation = new Conversation(userId, title, currentTime);&#10;            conversation.setTopic(topic);&#10;&#10;            String conversationId = database.child(CONVERSATIONS_PATH)&#10;                    .child(userId)&#10;                    .push().getKey();&#10;&#10;            if (conversationId != null) {&#10;                conversation.setId(conversationId);&#10;&#10;                database.child(CONVERSATIONS_PATH)&#10;                        .child(userId)&#10;                        .child(conversationId)&#10;                        .setValue(conversation.toMap())&#10;                        .addOnSuccessListener(aVoid -&gt; {&#10;                            Log.d(TAG, &quot;Conversation created successfully: &quot; + conversationId);&#10;                            callback.onSuccess(conversation);&#10;                        })&#10;                        .addOnFailureListener(e -&gt; {&#10;                            Log.e(TAG, &quot;Failed to create conversation&quot;, e);&#10;                            callback.onError(&quot;Không thể tạo cuộc trò chuyện: &quot; + e.getMessage());&#10;                        });&#10;            } else {&#10;                callback.onError(&quot;Không thể tạo ID cho cuộc trò chuyện&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error creating conversation&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi tạo cuộc trò chuyện: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void getConversations(String userId, int limit, Long lastConversationTime, RepositoryCallback&lt;List&lt;Conversation&gt;&gt; callback) {&#10;        try {&#10;            DatabaseReference conversationsRef = database.child(CONVERSATIONS_PATH).child(userId);&#10;&#10;            // Sắp xếp theo lastMessageTime giảm dần (mới nhất trước)&#10;            Query query = conversationsRef.orderByChild(&quot;lastMessageTime&quot;);&#10;&#10;            // Nếu có lastConversationTime, query từ thời điểm đó trở về trước&#10;            if (lastConversationTime != null) {&#10;                query = query.endBefore(lastConversationTime);&#10;            }&#10;&#10;            // Giới hạn số lượng kết quả&#10;            query = query.limitToLast(limit);&#10;&#10;            query.addListenerForSingleValueEvent(new ValueEventListener() {&#10;                @Override&#10;                public void onDataChange(DataSnapshot dataSnapshot) {&#10;                    List&lt;Conversation&gt; conversations = new ArrayList&lt;&gt;();&#10;&#10;                    for (DataSnapshot conversationSnapshot : dataSnapshot.getChildren()) {&#10;                        try {&#10;                            Conversation conversation = parseConversationFromSnapshot(conversationSnapshot);&#10;                            if (conversation != null) {&#10;                                conversations.add(conversation);&#10;                            }&#10;                        } catch (Exception e) {&#10;                            Log.e(TAG, &quot;Error parsing conversation&quot;, e);&#10;                        }&#10;                    }&#10;&#10;                    // Sắp xếp lại theo thời gian giảm dần (mới nhất trước)&#10;                    Collections.sort(conversations, (c1, c2) -&gt;&#10;                        Long.compare(c2.getLastMessageTime(), c1.getLastMessageTime()));&#10;&#10;                    Log.d(TAG, &quot;Loaded &quot; + conversations.size() + &quot; conversations&quot;);&#10;                    callback.onSuccess(conversations);&#10;                }&#10;&#10;                @Override&#10;                public void onCancelled(DatabaseError databaseError) {&#10;                    Log.e(TAG, &quot;Failed to load conversations&quot;, databaseError.toException());&#10;                    callback.onError(&quot;Không thể tải danh sách cuộc trò chuyện: &quot; + databaseError.getMessage());&#10;                }&#10;            });&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error loading conversations&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi tải danh sách cuộc trò chuyện: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void updateConversation(Conversation conversation, RepositoryCallback&lt;Conversation&gt; callback) {&#10;        try {&#10;            if (conversation.getId() == null || conversation.getUserId() == null) {&#10;                callback.onError(&quot;Thông tin cuộc trò chuyện không hợp lệ&quot;);&#10;                return;&#10;            }&#10;&#10;            database.child(CONVERSATIONS_PATH)&#10;                    .child(conversation.getUserId())&#10;                    .child(conversation.getId())&#10;                    .setValue(conversation.toMap())&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Conversation updated successfully: &quot; + conversation.getId());&#10;                        callback.onSuccess(conversation);&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Failed to update conversation&quot;, e);&#10;                        callback.onError(&quot;Không thể cập nhật cuộc trò chuyện: &quot; + e.getMessage());&#10;                    });&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error updating conversation&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi cập nhật cuộc trò chuyện: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void deleteConversation(String conversationId, RepositoryCallback&lt;Boolean&gt; callback) {&#10;        // TODO: Implement delete conversation and all its messages&#10;        callback.onError(&quot;Chức năng xóa cuộc trò chuyện sẽ được triển khai sau&quot;);&#10;    }&#10;&#10;    @Override&#10;    public void hasMoreConversations(String userId, Long lastConversationTime, RepositoryCallback&lt;Boolean&gt; callback) {&#10;        try {&#10;            DatabaseReference conversationsRef = database.child(CONVERSATIONS_PATH).child(userId);&#10;&#10;            Query query = conversationsRef.orderByChild(&quot;lastMessageTime&quot;);&#10;            if (lastConversationTime != null) {&#10;                query = query.endBefore(lastConversationTime);&#10;            }&#10;            query = query.limitToLast(1);&#10;&#10;            query.addListenerForSingleValueEvent(new ValueEventListener() {&#10;                @Override&#10;                public void onDataChange(DataSnapshot dataSnapshot) {&#10;                    boolean hasMore = dataSnapshot.exists() &amp;&amp; dataSnapshot.getChildrenCount() &gt; 0;&#10;                    callback.onSuccess(hasMore);&#10;                }&#10;&#10;                @Override&#10;                public void onCancelled(DatabaseError databaseError) {&#10;                    Log.e(TAG, &quot;Failed to check more conversations&quot;, databaseError.toException());&#10;                    callback.onError(&quot;Không thể kiểm tra cuộc trò chuyện: &quot; + databaseError.getMessage());&#10;                }&#10;            });&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error checking more conversations&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi kiểm tra cuộc trò chuyện: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    // ========== MESSAGE MANAGEMENT ==========&#10;&#10;    @Override&#10;    public void sendMessageToAI(String message, RepositoryCallback&lt;String&gt; callback) {&#10;        try {&#10;            // Tạo JSON request body theo format chính xác của OpenRouter&#10;            JsonObject requestJson = new JsonObject();&#10;            requestJson.addProperty(&quot;model&quot;, &quot;openai/gpt-3.5-turbo&quot;);&#10;&#10;            // Thêm các parameters bổ sung theo yêu cầu OpenRouter&#10;            requestJson.addProperty(&quot;max_tokens&quot;, 1000);&#10;            requestJson.addProperty(&quot;temperature&quot;, 0.7);&#10;&#10;            JsonArray messagesArray = new JsonArray();&#10;&#10;            // System message&#10;            JsonObject systemMessage = new JsonObject();&#10;            systemMessage.addProperty(&quot;role&quot;, &quot;system&quot;);&#10;            systemMessage.addProperty(&quot;content&quot;, &quot;Bạn là trợ lý AI chuyên về sức khỏe. Chỉ trả lời các câu hỏi liên quan đến sức khỏe, y tế, dinh dưỡng, thể dục thể thao. Nếu người dùng hỏi ngoài lĩnh vực sức khỏe thì từ chối một cách lịch sự và đề nghị họ hỏi về sức khỏe.&quot;);&#10;            messagesArray.add(systemMessage);&#10;&#10;            // User message&#10;            JsonObject userMessage = new JsonObject();&#10;            userMessage.addProperty(&quot;role&quot;, &quot;user&quot;);&#10;            userMessage.addProperty(&quot;content&quot;, message);&#10;            messagesArray.add(userMessage);&#10;&#10;            requestJson.add(&quot;messages&quot;, messagesArray);&#10;&#10;            String jsonString = gson.toJson(requestJson);&#10;            Log.d(TAG, &quot;Request JSON: &quot; + jsonString);&#10;&#10;            RequestBody body = RequestBody.create(&#10;                    MediaType.parse(&quot;application/json&quot;),&#10;                    jsonString&#10;            );&#10;&#10;            Request request = new Request.Builder()&#10;                    .url(OPENROUTER_API_URL)&#10;                    .post(body)&#10;                    .addHeader(&quot;Authorization&quot;, &quot;Bearer &quot; + API_KEY)&#10;                    .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                    .addHeader(&quot;HTTP-Referer&quot;, &quot;https://healthtips-vn.app&quot;)&#10;                    .addHeader(&quot;X-Title&quot;, &quot;HealthTips Vietnam&quot;)&#10;                    .build();&#10;&#10;            Log.d(TAG, &quot;Sending request to: &quot; + OPENROUTER_API_URL);&#10;            Log.d(TAG, &quot;Authorization header: Bearer &quot; + API_KEY.substring(0, 20) + &quot;...&quot;);&#10;&#10;            httpClient.newCall(request).enqueue(new Callback() {&#10;                @Override&#10;                public void onFailure(Call call, IOException e) {&#10;                    Log.e(TAG, &quot;Network request failed&quot;, e);&#10;                    mainHandler.post(() -&gt; {&#10;                        callback.onError(&quot;Không thể kết nối đến máy chủ AI. Kiểm tra kết nối mạng của bạn.&quot;);&#10;                    });&#10;                }&#10;&#10;                @Override&#10;                public void onResponse(Call call, Response response) throws IOException {&#10;                    String responseBody = &quot;&quot;;&#10;                    try {&#10;                        if (response.body() != null) {&#10;                            responseBody = response.body().string();&#10;                        }&#10;&#10;                        Log.d(TAG, &quot;Response Code: &quot; + response.code());&#10;                        Log.d(TAG, &quot;Response Headers: &quot; + response.headers().toString());&#10;                        Log.d(TAG, &quot;Response Body: &quot; + responseBody);&#10;&#10;                        if (response.isSuccessful()) {&#10;                            ChatApiResponse apiResponse = gson.fromJson(responseBody, ChatApiResponse.class);&#10;&#10;                            if (apiResponse != null &amp;&amp;&#10;                                apiResponse.getChoices() != null &amp;&amp;&#10;                                !apiResponse.getChoices().isEmpty() &amp;&amp;&#10;                                apiResponse.getChoices().get(0).getMessage() != null) {&#10;&#10;                                String aiMessage = apiResponse.getChoices().get(0).getMessage().getContent();&#10;                                if (aiMessage != null &amp;&amp; !aiMessage.trim().isEmpty()) {&#10;                                    mainHandler.post(() -&gt; callback.onSuccess(aiMessage.trim()));&#10;                                } else {&#10;                                    mainHandler.post(() -&gt; callback.onError(&quot;AI trả về phản hồi trống.&quot;));&#10;                                }&#10;                            } else {&#10;                                mainHandler.post(() -&gt; callback.onError(&quot;Định dạng phản hồi từ AI không hợp lệ.&quot;));&#10;                            }&#10;                        } else {&#10;                            // Xử lý các lỗi HTTP cụ thể&#10;                            String errorMessage = parseErrorMessage(response.code(), responseBody);&#10;                            Log.e(TAG, &quot;API Error: &quot; + errorMessage);&#10;&#10;                            mainHandler.post(() -&gt; callback.onError(errorMessage));&#10;                        }&#10;                    } catch (Exception e) {&#10;                        Log.e(TAG, &quot;Error parsing response&quot;, e);&#10;                        Log.e(TAG, &quot;Response body was: &quot; + responseBody);&#10;&#10;                        mainHandler.post(() -&gt; {&#10;                            callback.onError(&quot;Lỗi xử lý phản hồi từ AI. Vui lòng thử lại.&quot;);&#10;                        });&#10;                    }&#10;                }&#10;            });&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error creating request&quot;, e);&#10;            callback.onError(&quot;Lỗi tạo yêu cầu gửi đến AI.&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Phân tích thông báo lỗi từ API response&#10;     */&#10;    private String parseErrorMessage(int responseCode, String responseBody) {&#10;        try {&#10;            // Thử parse JSON error response&#10;            JsonObject errorResponse = gson.fromJson(responseBody, JsonObject.class);&#10;            if (errorResponse.has(&quot;error&quot;)) {&#10;                JsonObject error = errorResponse.getAsJsonObject(&quot;error&quot;);&#10;                if (error.has(&quot;message&quot;)) {&#10;                    String apiErrorMessage = error.get(&quot;message&quot;).getAsString();&#10;                    Log.d(TAG, &quot;API Error Message: &quot; + apiErrorMessage);&#10;&#10;                    // Dịch một số lỗi phổ biến&#10;                    if (apiErrorMessage.contains(&quot;No auth credentials&quot;)) {&#10;                        return &quot;Lỗi xác thực API. Vui lòng liên hệ quản trị viên.&quot;;&#10;                    } else if (apiErrorMessage.contains(&quot;Rate limit&quot;)) {&#10;                        return &quot;Đã vượt quá giới hạn yêu cầu. Vui lòng thử lại sau ít phút.&quot;;&#10;                    } else if (apiErrorMessage.contains(&quot;Invalid model&quot;)) {&#10;                        return &quot;Mô hình AI không hợp lệ. Vui lòng thử lại.&quot;;&#10;                    }&#10;                    return &quot;Lỗi từ AI: &quot; + apiErrorMessage;&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error parsing error response&quot;, e);&#10;        }&#10;&#10;        // Fallback cho các HTTP status codes&#10;        switch (responseCode) {&#10;            case 401:&#10;                return &quot;Lỗi xác thực. API key có thể đã hết hạn hoặc không hợp lệ.&quot;;&#10;            case 403:&#10;                return &quot;Không có quyền truy cập. Vui lòng kiểm tra cấu hình API.&quot;;&#10;            case 429:&#10;                return &quot;Quá nhiều yêu cầu. Vui lòng chờ một chút rồi thử lại.&quot;;&#10;            case 500:&#10;                return &quot;Lỗi máy chủ AI. Vui lòng thử lại sau.&quot;;&#10;            case 502:&#10;            case 503:&#10;            case 504:&#10;                return &quot;Máy chủ AI tạm thời không khả dụng. Vui lòng thử lại sau.&quot;;&#10;            default:&#10;                return &quot;Lỗi không xác định từ AI (Mã: &quot; + responseCode + &quot;). Vui lòng thử lại.&quot;;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public String extractTopic(String content) {&#10;        try {&#10;            // Các từ khóa chủ đề về sức khỏe&#10;            String[] healthTopics = {&#10;                &quot;tim mạch&quot;, &quot;huyết áp&quot;, &quot;cholesterol&quot;, &quot;đường huyết&quot;, &quot;tiểu đường&quot;,&#10;                &quot;dinh dưỡng&quot;, &quot;vitamin&quot;, &quot;protein&quot;, &quot;carb&quot;, &quot;chất béo&quot;,&#10;                &quot;tập luyện&quot;, &quot;thể dục&quot;, &quot;yoga&quot;, &quot;cardio&quot;, &quot;cơ bắp&quot;,&#10;                &quot;giảm cân&quot;, &quot;tăng cân&quot;, &quot;béo phì&quot;, &quot;ăn kiêng&quot;,&#10;                &quot;stress&quot;, &quot;lo âu&quot;, &quot;trầm cảm&quot;, &quot;tâm lý&quot;, &quot;tinh thần&quot;,&#10;                &quot;giấc ngủ&quot;, &quot;mất ngủ&quot;, &quot;ngủ&quot;, &quot;nghỉ ngơi&quot;,&#10;                &quot;da&quot;, &quot;tóc&quot;, &quot;móng&quot;, &quot;mỹ phẩm&quot;, &quot;chăm sóc da&quot;,&#10;                &quot;mang thai&quot;, &quot;sinh sản&quot;, &quot;kinh nguyệt&quot;, &quot;phụ khoa&quot;,&#10;                &quot;trẻ em&quot;, &quot;em bé&quot;, &quot;sức khỏe trẻ&quot;, &quot;phát triển&quot;,&#10;                &quot;người cao tuổi&quot;, &quot;lão hóa&quot;, &quot;xương khớp&quot;, &quot;cột sống&quot;,&#10;                &quot;mắt&quot;, &quot;thị lực&quot;, &quot;tai&quot;, &quot;thính giác&quot;,&#10;                &quot;răng&quot;, &quot;miệng&quot;, &quot;nha khoa&quot;, &quot;vệ sinh răng miệng&quot;,&#10;                &quot;cảm cúm&quot;, &quot;sốt&quot;, &quot;ho&quot;, &quot;viêm họng&quot;, &quot;virus&quot;,&#10;                &quot;thuốc&quot;, &quot;dược phẩm&quot;, &quot;tác dụng phụ&quot;, &quot;liều dùng&quot;&#10;            };&#10;&#10;            content = content.toLowerCase();&#10;&#10;            for (String topic : healthTopics) {&#10;                if (content.contains(topic)) {&#10;                    return topic;&#10;                }&#10;            }&#10;&#10;            // Nếu không tìm thấy chủ đề cụ thể, trả về chủ đề chung&#10;            return &quot;sức khỏe tổng quát&quot;;&#10;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error extracting topic&quot;, e);&#10;            return &quot;sức khỏe tổng quát&quot;;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lưu chủ đề mà người dùng quan tâm vào Firebase&#10;     */&#10;    private void saveUserTopic(String userId, String topic) {&#10;        try {&#10;            database.child(USER_TOPICS_PATH)&#10;                    .child(userId)&#10;                    .child(topic)&#10;                    .setValue(System.currentTimeMillis())&#10;                    .addOnSuccessListener(aVoid -&gt; Log.d(TAG, &quot;User topic saved: &quot; + topic))&#10;                    .addOnFailureListener(e -&gt; Log.e(TAG, &quot;Failed to save user topic&quot;, e));&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error saving user topic&quot;, e);&#10;        }&#10;    }&#10;&#10;    // ========== HELPER METHODS ==========&#10;&#10;    @Override&#10;    public void saveChatMessage(ChatMessage chatMessage, RepositoryCallback&lt;ChatMessage&gt; callback) {&#10;        try {&#10;            if (chatMessage.getConversationId() == null || chatMessage.getUserId() == null || chatMessage.getContent() == null) {&#10;                callback.onError(&quot;Thông tin tin nhắn không hợp lệ&quot;);&#10;                return;&#10;            }&#10;&#10;            String messageId = database.child(CHAT_MESSAGES_PATH)&#10;                    .child(chatMessage.getConversationId())&#10;                    .push().getKey();&#10;&#10;            if (messageId != null) {&#10;                chatMessage.setId(messageId);&#10;&#10;                database.child(CHAT_MESSAGES_PATH)&#10;                        .child(chatMessage.getConversationId())&#10;                        .child(messageId)&#10;                        .setValue(chatMessage.toMap())&#10;                        .addOnSuccessListener(aVoid -&gt; {&#10;                            Log.d(TAG, &quot;Chat message saved successfully: &quot; + messageId);&#10;                            callback.onSuccess(chatMessage);&#10;                        })&#10;                        .addOnFailureListener(e -&gt; {&#10;                            Log.e(TAG, &quot;Failed to save chat message&quot;, e);&#10;                            callback.onError(&quot;Không thể lưu tin nhắn: &quot; + e.getMessage());&#10;                        });&#10;            } else {&#10;                callback.onError(&quot;Không thể tạo ID cho tin nhắn&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error saving chat message&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi lưu tin nhắn: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void getChatMessages(String conversationId, RepositoryCallback&lt;List&lt;ChatMessage&gt;&gt; callback) {&#10;        try {&#10;            DatabaseReference messagesRef = database.child(CHAT_MESSAGES_PATH).child(conversationId);&#10;&#10;            messagesRef.orderByChild(&quot;timestamp&quot;).addListenerForSingleValueEvent(new ValueEventListener() {&#10;                @Override&#10;                public void onDataChange(DataSnapshot dataSnapshot) {&#10;                    List&lt;ChatMessage&gt; messages = new ArrayList&lt;&gt;();&#10;&#10;                    for (DataSnapshot messageSnapshot : dataSnapshot.getChildren()) {&#10;                        try {&#10;                            ChatMessage message = parseChatMessageFromSnapshot(messageSnapshot);&#10;                            if (message != null) {&#10;                                messages.add(message);&#10;                            }&#10;                        } catch (Exception e) {&#10;                            Log.e(TAG, &quot;Error parsing chat message&quot;, e);&#10;                        }&#10;                    }&#10;&#10;                    Log.d(TAG, &quot;Loaded &quot; + messages.size() + &quot; chat messages&quot;);&#10;                    callback.onSuccess(messages);&#10;                }&#10;&#10;                @Override&#10;                public void onCancelled(DatabaseError databaseError) {&#10;                    Log.e(TAG, &quot;Failed to load chat messages&quot;, databaseError.toException());&#10;                    callback.onError(&quot;Không thể tải tin nhắn: &quot; + databaseError.getMessage());&#10;                }&#10;            });&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error loading chat messages&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi tải tin nhắn: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void clearChatMessages(String conversationId, RepositoryCallback&lt;Boolean&gt; callback) {&#10;        try {&#10;            database.child(CHAT_MESSAGES_PATH)&#10;                    .child(conversationId)&#10;                    .removeValue()&#10;                    .addOnSuccessListener(aVoid -&gt; {&#10;                        Log.d(TAG, &quot;Chat messages cleared successfully for conversation: &quot; + conversationId);&#10;                        callback.onSuccess(true);&#10;                    })&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Failed to clear chat messages&quot;, e);&#10;                        callback.onError(&quot;Không thể xóa tin nhắn: &quot; + e.getMessage());&#10;                    });&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error clearing chat messages&quot;, e);&#10;            callback.onError(&quot;Có lỗi xảy ra khi xóa tin nhắn: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Parse Conversation từ Firebase DataSnapshot&#10;     */&#10;    private Conversation parseConversationFromSnapshot(DataSnapshot snapshot) {&#10;        try {&#10;            Conversation conversation = new Conversation();&#10;            conversation.setId(snapshot.getKey());&#10;            conversation.setUserId(snapshot.child(&quot;userId&quot;).getValue(String.class));&#10;            conversation.setTitle(snapshot.child(&quot;title&quot;).getValue(String.class));&#10;            conversation.setLastMessage(snapshot.child(&quot;lastMessage&quot;).getValue(String.class));&#10;&#10;            Long lastMessageTime = snapshot.child(&quot;lastMessageTime&quot;).getValue(Long.class);&#10;            if (lastMessageTime != null) {&#10;                conversation.setLastMessageTime(lastMessageTime);&#10;            }&#10;&#10;            Boolean isFromUser = snapshot.child(&quot;isFromUser&quot;).getValue(Boolean.class);&#10;            if (isFromUser != null) {&#10;                conversation.setFromUser(isFromUser);&#10;            }&#10;&#10;            Integer messageCount = snapshot.child(&quot;messageCount&quot;).getValue(Integer.class);&#10;            if (messageCount != null) {&#10;                conversation.setMessageCount(messageCount);&#10;            }&#10;&#10;            Long createdTime = snapshot.child(&quot;createdTime&quot;).getValue(Long.class);&#10;            if (createdTime != null) {&#10;                conversation.setCreatedTime(createdTime);&#10;            }&#10;&#10;            conversation.setTopic(snapshot.child(&quot;topic&quot;).getValue(String.class));&#10;            return conversation;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error parsing conversation from snapshot&quot;, e);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Parse ChatMessage từ Firebase DataSnapshot&#10;     */&#10;    private ChatMessage parseChatMessageFromSnapshot(DataSnapshot snapshot) {&#10;        try {&#10;            ChatMessage message = new ChatMessage();&#10;            message.setId(snapshot.getKey());&#10;            message.setConversationId(snapshot.child(&quot;conversationId&quot;).getValue(String.class));&#10;            message.setUserId(snapshot.child(&quot;userId&quot;).getValue(String.class));&#10;            message.setContent(snapshot.child(&quot;content&quot;).getValue(String.class));&#10;&#10;            Boolean isFromUser = snapshot.child(&quot;isFromUser&quot;).getValue(Boolean.class);&#10;            if (isFromUser != null) {&#10;                message.setFromUser(isFromUser);&#10;            }&#10;&#10;            Long timestamp = snapshot.child(&quot;timestamp&quot;).getValue(Long.class);&#10;            if (timestamp != null) {&#10;                message.setTimestamp(timestamp);&#10;            }&#10;&#10;            message.setTopic(snapshot.child(&quot;topic&quot;).getValue(String.class));&#10;            return message;&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error parsing message from snapshot&quot;, e);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void clearChatHistory(String userId, RepositoryCallback&lt;Boolean&gt; callback) {&#10;        try {&#10;            // Xóa tất cả cuộc trò chuyện của user&#10;            DatabaseReference userConversationsRef = database.child(CONVERSATIONS_PATH).child(userId);&#10;            &#10;            userConversationsRef.addListenerForSingleValueEvent(new ValueEventListener() {&#10;                @Override&#10;                public void onDataChange(DataSnapshot dataSnapshot) {&#10;                    try {&#10;                        List&lt;String&gt; conversationIds = new ArrayList&lt;&gt;();&#10;                        &#10;                        // Lấy danh sách ID các cuộc trò chuyện&#10;                        for (DataSnapshot conversationSnapshot : dataSnapshot.getChildren()) {&#10;                            conversationIds.add(conversationSnapshot.getKey());&#10;                        }&#10;                        &#10;                        if (conversationIds.isEmpty()) {&#10;                            callback.onSuccess(true);&#10;                            return;&#10;                        }&#10;                        &#10;                        // Xóa từng cuộc trò chuyện và tin nhắn của nó&#10;                        deleteConversationsRecursively(conversationIds, 0, userId, callback);&#10;                        &#10;                    } catch (Exception e) {&#10;                        Log.e(TAG, &quot;Error processing chat history deletion&quot;, e);&#10;                        callback.onError(&quot;Lỗi xử lý xóa lịch sử chat: &quot; + e.getMessage());&#10;                    }&#10;                }&#10;&#10;                @Override&#10;                public void onCancelled(DatabaseError databaseError) {&#10;                    Log.e(TAG, &quot;Error clearing chat history&quot;, databaseError.toException());&#10;                    callback.onError(&quot;Lỗi xóa lịch sử chat: &quot; + databaseError.getMessage());&#10;                }&#10;            });&#10;        } catch (Exception e) {&#10;            Log.e(TAG, &quot;Error initiating chat history clear&quot;, e);&#10;            callback.onError(&quot;Lỗi khởi tạo xóa lịch sử chat: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Xóa các cuộc trò chuyện một cách đệ quy&#10;     */&#10;    private void deleteConversationsRecursively(List&lt;String&gt; conversationIds, int index, String userId, RepositoryCallback&lt;Boolean&gt; callback) {&#10;        if (index &gt;= conversationIds.size()) {&#10;            // Xóa xong tất cả cuộc trò chuyện, xóa thư mục user trong conversations&#10;            database.child(CONVERSATIONS_PATH).child(userId).removeValue()&#10;                    .addOnSuccessListener(aVoid -&gt; callback.onSuccess(true))&#10;                    .addOnFailureListener(e -&gt; {&#10;                        Log.e(TAG, &quot;Error removing user conversations folder&quot;, e);&#10;                        callback.onError(&quot;Lỗi xóa thư mục cuộc trò chuyện: &quot; + e.getMessage());&#10;                    });&#10;            return;&#10;        }&#10;&#10;        String conversationId = conversationIds.get(index);&#10;        &#10;        // Xóa tin nhắn của cuộc trò chuyện này trước&#10;        clearChatMessages(conversationId, new RepositoryCallback&lt;Boolean&gt;() {&#10;            @Override&#10;            public void onSuccess(Boolean result) {&#10;                // Sau khi xóa tin nhắn, xóa cuộc trò chuyện&#10;                database.child(CONVERSATIONS_PATH).child(userId).child(conversationId).removeValue()&#10;                        .addOnSuccessListener(aVoid -&gt; {&#10;                            // Tiếp tục xóa cuộc trò chuyện tiếp theo&#10;                            deleteConversationsRecursively(conversationIds, index + 1, userId, callback);&#10;                        })&#10;                        .addOnFailureListener(e -&gt; {&#10;                            Log.e(TAG, &quot;Error deleting conversation: &quot; + conversationId, e);&#10;                            callback.onError(&quot;Lỗi xóa cuộc trò chuyện: &quot; + e.getMessage());&#10;                        });&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                Log.e(TAG, &quot;Error clearing messages for conversation: &quot; + conversationId + &quot;, error: &quot; + error);&#10;                callback.onError(&quot;Lỗi xóa tin nhắn cuộc trò chuyện: &quot; + error);&#10;            }&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/presentation/chat/ChatAdapter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/presentation/chat/ChatAdapter.java" />
              <option name="originalContent" value="package com.vhn.doan.presentation.chat;&#10;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.TextView;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.recyclerview.widget.RecyclerView;&#10;&#10;import com.vhn.doan.R;&#10;import com.vhn.doan.data.ChatMessage;&#10;&#10;import java.text.SimpleDateFormat;&#10;import java.util.ArrayList;&#10;import java.util.Date;&#10;import java.util.List;&#10;import java.util.Locale;&#10;&#10;/**&#10; * Adapter cho danh sách tin nhắn chat&#10; */&#10;public class ChatAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; {&#10;&#10;    private static final int VIEW_TYPE_USER_MESSAGE = 1;&#10;    private static final int VIEW_TYPE_AI_MESSAGE = 2;&#10;    private static final int VIEW_TYPE_TYPING = 3;&#10;&#10;    private List&lt;ChatMessage&gt; messages;&#10;    private boolean isAiTyping = false;&#10;    private final SimpleDateFormat timeFormat;&#10;&#10;    public ChatAdapter() {&#10;        this.messages = new ArrayList&lt;&gt;();&#10;        this.timeFormat = new SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault());&#10;    }&#10;&#10;    @Override&#10;    public int getItemViewType(int position) {&#10;        if (isAiTyping &amp;&amp; position == getItemCount() - 1) {&#10;            return VIEW_TYPE_TYPING;&#10;        }&#10;&#10;        ChatMessage message = messages.get(position);&#10;        return message.isFromUser() ? VIEW_TYPE_USER_MESSAGE : VIEW_TYPE_AI_MESSAGE;&#10;    }&#10;&#10;    @NonNull&#10;    @Override&#10;    public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {&#10;        LayoutInflater inflater = LayoutInflater.from(parent.getContext());&#10;&#10;        switch (viewType) {&#10;            case VIEW_TYPE_USER_MESSAGE:&#10;                View userView = inflater.inflate(R.layout.item_chat_user_message, parent, false);&#10;                return new UserMessageViewHolder(userView);&#10;&#10;            case VIEW_TYPE_AI_MESSAGE:&#10;                View aiView = inflater.inflate(R.layout.item_chat_ai_message, parent, false);&#10;                return new AiMessageViewHolder(aiView);&#10;&#10;            case VIEW_TYPE_TYPING:&#10;                View typingView = inflater.inflate(R.layout.item_chat_typing, parent, false);&#10;                return new TypingViewHolder(typingView);&#10;&#10;            default:&#10;                throw new IllegalArgumentException(&quot;Unknown view type: &quot; + viewType);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) {&#10;        if (holder instanceof TypingViewHolder) {&#10;            // Không cần bind data cho typing indicator&#10;            return;&#10;        }&#10;&#10;        ChatMessage message = messages.get(position);&#10;&#10;        if (holder instanceof UserMessageViewHolder) {&#10;            ((UserMessageViewHolder) holder).bind(message);&#10;        } else if (holder instanceof AiMessageViewHolder) {&#10;            ((AiMessageViewHolder) holder).bind(message);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public int getItemCount() {&#10;        int count = messages.size();&#10;        if (isAiTyping) {&#10;            count++;&#10;        }&#10;        return count;&#10;    }&#10;&#10;    /**&#10;     * Cập nhật danh sách tin nhắn&#10;     */&#10;    public void setMessages(List&lt;ChatMessage&gt; messages) {&#10;        this.messages.clear();&#10;        this.messages.addAll(messages);&#10;        notifyDataSetChanged();&#10;    }&#10;&#10;    /**&#10;     * Thêm tin nhắn mới&#10;     */&#10;    public void addMessage(ChatMessage message) {&#10;        this.messages.add(message);&#10;        notifyItemInserted(messages.size() - 1);&#10;    }&#10;&#10;    /**&#10;     * Hiển thị trạng thái AI đang gõ&#10;     */&#10;    public void showAiTyping() {&#10;        if (!isAiTyping) {&#10;            isAiTyping = true;&#10;            notifyItemInserted(getItemCount() - 1);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Ẩn trạng thái AI đang gõ&#10;     */&#10;    public void hideAiTyping() {&#10;        if (isAiTyping) {&#10;            isAiTyping = false;&#10;            notifyItemRemoved(getItemCount());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Xóa tất cả tin nhắn&#10;     */&#10;    public void clearMessages() {&#10;        int size = messages.size();&#10;        messages.clear();&#10;        notifyItemRangeRemoved(0, size);&#10;    }&#10;&#10;    // ViewHolder cho tin nhắn người dùng&#10;    class UserMessageViewHolder extends RecyclerView.ViewHolder {&#10;        private TextView messageText;&#10;        private TextView timeText;&#10;&#10;        public UserMessageViewHolder(@NonNull View itemView) {&#10;            super(itemView);&#10;            messageText = itemView.findViewById(R.id.tv_user_message);&#10;            timeText = itemView.findViewById(R.id.tv_user_time);&#10;        }&#10;&#10;        public void bind(ChatMessage message) {&#10;            messageText.setText(message.getContent());&#10;            timeText.setText(timeFormat.format(new Date(message.getTimestamp())));&#10;        }&#10;    }&#10;&#10;    // ViewHolder cho tin nhắn AI&#10;    class AiMessageViewHolder extends RecyclerView.ViewHolder {&#10;        private TextView messageText;&#10;        private TextView timeText;&#10;&#10;        public AiMessageViewHolder(@NonNull View itemView) {&#10;            super(itemView);&#10;            messageText = itemView.findViewById(R.id.tv_ai_message);&#10;            timeText = itemView.findViewById(R.id.tv_ai_time);&#10;        }&#10;&#10;        public void bind(ChatMessage message) {&#10;            messageText.setText(message.getContent());&#10;            timeText.setText(timeFormat.format(new Date(message.getTimestamp())));&#10;        }&#10;    }&#10;&#10;    // ViewHolder cho typing indicator&#10;    class TypingViewHolder extends RecyclerView.ViewHolder {&#10;        public TypingViewHolder(@NonNull View itemView) {&#10;            super(itemView);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.presentation.chat;&#13;&#10;&#13;&#10;import android.view.LayoutInflater;&#13;&#10;import android.view.View;&#13;&#10;import android.view.ViewGroup;&#13;&#10;import android.widget.TextView;&#13;&#10;&#13;&#10;import androidx.annotation.NonNull;&#13;&#10;import androidx.recyclerview.widget.RecyclerView;&#13;&#10;&#13;&#10;import com.vhn.doan.R;&#13;&#10;import com.vhn.doan.data.ChatMessage;&#13;&#10;&#13;&#10;import java.text.SimpleDateFormat;&#13;&#10;import java.util.ArrayList;&#13;&#10;import java.util.Date;&#13;&#10;import java.util.List;&#13;&#10;import java.util.Locale;&#13;&#10;&#13;&#10;/**&#13;&#10; * Adapter cho danh sách tin nhắn chat&#13;&#10; */&#13;&#10;public class ChatAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; {&#13;&#10;&#13;&#10;    private static final int VIEW_TYPE_USER_MESSAGE = 1;&#13;&#10;    private static final int VIEW_TYPE_AI_MESSAGE = 2;&#13;&#10;    private static final int VIEW_TYPE_TYPING = 3;&#13;&#10;&#13;&#10;    private List&lt;ChatMessage&gt; messages;&#13;&#10;    private boolean isAiTyping = false;&#13;&#10;    private final SimpleDateFormat timeFormat;&#13;&#10;&#13;&#10;    public ChatAdapter() {&#13;&#10;        this.messages = new ArrayList&lt;&gt;();&#13;&#10;        this.timeFormat = new SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault());&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public int getItemViewType(int position) {&#13;&#10;        if (isAiTyping &amp;&amp; position == getItemCount() - 1) {&#13;&#10;            return VIEW_TYPE_TYPING;&#13;&#10;        }&#13;&#10;&#13;&#10;        ChatMessage message = messages.get(position);&#13;&#10;        return message.isFromUser() ? VIEW_TYPE_USER_MESSAGE : VIEW_TYPE_AI_MESSAGE;&#13;&#10;    }&#13;&#10;&#13;&#10;    @NonNull&#13;&#10;    @Override&#13;&#10;    public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {&#13;&#10;        LayoutInflater inflater = LayoutInflater.from(parent.getContext());&#13;&#10;&#13;&#10;        switch (viewType) {&#13;&#10;            case VIEW_TYPE_USER_MESSAGE:&#13;&#10;                View userView = inflater.inflate(R.layout.item_chat_user_message, parent, false);&#13;&#10;                return new UserMessageViewHolder(userView);&#13;&#10;&#13;&#10;            case VIEW_TYPE_AI_MESSAGE:&#13;&#10;                View aiView = inflater.inflate(R.layout.item_chat_ai_message, parent, false);&#13;&#10;                return new AiMessageViewHolder(aiView);&#13;&#10;&#13;&#10;            case VIEW_TYPE_TYPING:&#13;&#10;                View typingView = inflater.inflate(R.layout.item_chat_typing, parent, false);&#13;&#10;                return new TypingViewHolder(typingView);&#13;&#10;&#13;&#10;            default:&#13;&#10;                throw new IllegalArgumentException(&quot;Unknown view type: &quot; + viewType);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) {&#13;&#10;        if (holder instanceof TypingViewHolder) {&#13;&#10;            // Không cần bind data cho typing indicator&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        ChatMessage message = messages.get(position);&#13;&#10;&#13;&#10;        if (holder instanceof UserMessageViewHolder) {&#13;&#10;            ((UserMessageViewHolder) holder).bind(message);&#13;&#10;        } else if (holder instanceof AiMessageViewHolder) {&#13;&#10;            ((AiMessageViewHolder) holder).bind(message);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public int getItemCount() {&#13;&#10;        int count = messages.size();&#13;&#10;        if (isAiTyping) {&#13;&#10;            count++;&#13;&#10;        }&#13;&#10;        return count;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Cập nhật danh sách tin nhắn&#13;&#10;     */&#13;&#10;    public void setMessages(List&lt;ChatMessage&gt; messages) {&#13;&#10;        this.messages.clear();&#13;&#10;        this.messages.addAll(messages);&#13;&#10;        notifyDataSetChanged();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Thêm tin nhắn mới&#13;&#10;     */&#13;&#10;    public void addMessage(ChatMessage message) {&#13;&#10;        this.messages.add(message);&#13;&#10;        notifyItemInserted(messages.size() - 1);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Hiển thị trạng thái AI đang gõ&#13;&#10;     */&#13;&#10;    public void showAiTyping() {&#13;&#10;        if (!isAiTyping) {&#13;&#10;            isAiTyping = true;&#13;&#10;            notifyItemInserted(getItemCount() - 1);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Ẩn trạng thái AI đang gõ&#13;&#10;     */&#13;&#10;    public void hideAiTyping() {&#13;&#10;        if (isAiTyping) {&#13;&#10;            isAiTyping = false;&#13;&#10;            notifyItemRemoved(getItemCount());&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Kiểm tra AI có đang gõ không&#13;&#10;     */&#13;&#10;    public boolean isAiTyping() {&#13;&#10;        return isAiTyping;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Xóa tất cả tin nhắn&#13;&#10;     */&#13;&#10;    public void clearMessages() {&#13;&#10;        int size = messages.size();&#13;&#10;        messages.clear();&#13;&#10;        notifyItemRangeRemoved(0, size);&#13;&#10;    }&#13;&#10;&#13;&#10;    // ViewHolder cho tin nhắn người dùng&#13;&#10;    class UserMessageViewHolder extends RecyclerView.ViewHolder {&#13;&#10;        private TextView messageText;&#13;&#10;        private TextView timeText;&#13;&#10;&#13;&#10;        public UserMessageViewHolder(@NonNull View itemView) {&#13;&#10;            super(itemView);&#13;&#10;            messageText = itemView.findViewById(R.id.tv_user_message);&#13;&#10;            timeText = itemView.findViewById(R.id.tv_user_time);&#13;&#10;        }&#13;&#10;&#13;&#10;        public void bind(ChatMessage message) {&#13;&#10;            messageText.setText(message.getContent());&#13;&#10;            timeText.setText(timeFormat.format(new Date(message.getTimestamp())));&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // ViewHolder cho tin nhắn AI&#13;&#10;    class AiMessageViewHolder extends RecyclerView.ViewHolder {&#13;&#10;        private TextView messageText;&#13;&#10;        private TextView timeText;&#13;&#10;&#13;&#10;        public AiMessageViewHolder(@NonNull View itemView) {&#13;&#10;            super(itemView);&#13;&#10;            messageText = itemView.findViewById(R.id.tv_ai_message);&#13;&#10;            timeText = itemView.findViewById(R.id.tv_ai_time);&#13;&#10;        }&#13;&#10;&#13;&#10;        public void bind(ChatMessage message) {&#13;&#10;            messageText.setText(message.getContent());&#13;&#10;            timeText.setText(timeFormat.format(new Date(message.getTimestamp())));&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // ViewHolder cho typing indicator&#13;&#10;    class TypingViewHolder extends RecyclerView.ViewHolder {&#13;&#10;        public TypingViewHolder(@NonNull View itemView) {&#13;&#10;            super(itemView);&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/presentation/chat/ChatContract.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/presentation/chat/ChatContract.java" />
              <option name="originalContent" value="package com.vhn.doan.presentation.chat;&#10;&#10;import com.vhn.doan.data.ChatMessage;&#10;import com.vhn.doan.presentation.base.BasePresenter;&#10;import com.vhn.doan.presentation.base.BaseView;&#10;&#10;import java.util.List;&#10;&#10;/**&#10; * Contract interface cho Chat feature theo kiến trúc MVP&#10; */&#10;public interface ChatContract {&#10;&#10;    interface View extends BaseView&lt;Presenter&gt; {&#10;        /**&#10;         * Hiển thị danh sách tin nhắn chat&#10;         */&#10;        void showMessages(List&lt;ChatMessage&gt; messages);&#10;&#10;        /**&#10;         * Thêm tin nhắn mới vào danh sách&#10;         */&#10;        void addMessage(ChatMessage message);&#10;&#10;        /**&#10;         * Hiển thị trạng thái đang gửi tin nhắn&#10;         */&#10;        void showSendingMessage();&#10;&#10;        /**&#10;         * Ẩn trạng thái đang gửi tin nhắn&#10;         */&#10;        void hideSendingMessage();&#10;&#10;        /**&#10;         * Hiển thị trạng thái AI đang trả lời&#10;         */&#10;        void showAiTyping();&#10;&#10;        /**&#10;         * Ẩn trạng thái AI đang trả lời&#10;         */&#10;        void hideAiTyping();&#10;&#10;        /**&#10;         * Xóa nội dung trong ô nhập tin nhắn&#10;         */&#10;        void clearMessageInput();&#10;&#10;        /**&#10;         * Cuộn xuống tin nhắn mới nhất&#10;         */&#10;        void scrollToLatestMessage();&#10;&#10;        /**&#10;         * Hiển thị thông báo lỗi khi gửi tin nhắn thất bại&#10;         */&#10;        void showSendMessageError(String error);&#10;&#10;        /**&#10;         * Hiển thị thông báo lỗi khi tải tin nhắn thất bại&#10;         */&#10;        void showLoadMessagesError(String error);&#10;&#10;        /**&#10;         * Hiển thị trạng thái đang tải tin nhắn&#10;         */&#10;        void showLoadingMessages();&#10;&#10;        /**&#10;         * Ẩn trạng thái đang tải tin nhắn&#10;         */&#10;        void hideLoadingMessages();&#10;    }&#10;&#10;    interface Presenter extends BasePresenter&lt;View&gt; {&#10;        /**&#10;         * Tải danh sách tin nhắn từ Firebase&#10;         */&#10;        void loadMessages();&#10;&#10;        /**&#10;         * Gửi tin nhắn mới&#10;         * @param content Nội dung tin nhắn&#10;         */&#10;        void sendMessage(String content);&#10;&#10;        /**&#10;         * Xóa lịch sử chat&#10;         */&#10;        void clearChatHistory();&#10;&#10;        /**&#10;         * Làm mới danh sách tin nhắn&#10;         */&#10;        void refreshMessages();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.presentation.chat;&#13;&#10;&#13;&#10;import com.vhn.doan.data.ChatMessage;&#13;&#10;import com.vhn.doan.presentation.base.BasePresenter;&#13;&#10;import com.vhn.doan.presentation.base.BaseView;&#13;&#10;&#13;&#10;import java.util.List;&#13;&#10;&#13;&#10;/**&#13;&#10; * Contract interface cho Chat feature theo kiến trúc MVP&#13;&#10; */&#13;&#10;public interface ChatContract {&#13;&#10;&#13;&#10;    interface View extends BaseView {&#13;&#10;        /**&#13;&#10;         * Hiển thị danh sách tin nhắn chat&#13;&#10;         */&#13;&#10;        void showMessages(List&lt;ChatMessage&gt; messages);&#13;&#10;&#13;&#10;        /**&#13;&#10;         * Thêm tin nhắn mới vào danh sách&#13;&#10;         */&#13;&#10;        void addMessage(ChatMessage message);&#13;&#10;&#13;&#10;        /**&#13;&#10;         * Hiển thị trạng thái đang gửi tin nhắn&#13;&#10;         */&#13;&#10;        void showSendingMessage();&#13;&#10;&#13;&#10;        /**&#13;&#10;         * Ẩn trạng thái đang gửi tin nhắn&#13;&#10;         */&#13;&#10;        void hideSendingMessage();&#13;&#10;&#13;&#10;        /**&#13;&#10;         * Hiển thị trạng thái AI đang trả lời&#13;&#10;         */&#13;&#10;        void showAiTyping();&#13;&#10;&#13;&#10;        /**&#13;&#10;         * Ẩn trạng thái AI đang trả lời&#13;&#10;         */&#13;&#10;        void hideAiTyping();&#13;&#10;&#13;&#10;        /**&#13;&#10;         * Xóa nội dung trong ô nhập tin nhắn&#13;&#10;         */&#13;&#10;        void clearMessageInput();&#13;&#10;&#13;&#10;        /**&#13;&#10;         * Cuộn xuống tin nhắn mới nhất&#13;&#10;         */&#13;&#10;        void scrollToLatestMessage();&#13;&#10;&#13;&#10;        /**&#13;&#10;         * Hiển thị thông báo lỗi khi gửi tin nhắn thất bại&#13;&#10;         */&#13;&#10;        void showSendMessageError(String error);&#13;&#10;&#13;&#10;        /**&#13;&#10;         * Hiển thị thông báo lỗi khi tải tin nhắn thất bại&#13;&#10;         */&#13;&#10;        void showLoadMessagesError(String error);&#13;&#10;&#13;&#10;        /**&#13;&#10;         * Hiển thị trạng thái đang tải tin nhắn&#13;&#10;         */&#13;&#10;        void showLoadingMessages();&#13;&#10;&#13;&#10;        /**&#13;&#10;         * Ẩn trạng thái đang tải tin nhắn&#13;&#10;         */&#13;&#10;        void hideLoadingMessages();&#13;&#10;&#13;&#10;        /**&#13;&#10;         * Hiển thị thông báo thành công&#13;&#10;         */&#13;&#10;        void showMessage(String message);&#13;&#10;    }&#13;&#10;&#13;&#10;    interface Presenter {&#13;&#10;        /**&#13;&#10;         * Gắn view vào presenter&#13;&#10;         */&#13;&#10;        void attachView(View view);&#13;&#10;&#13;&#10;        /**&#13;&#10;         * Gỡ bỏ view khỏi presenter&#13;&#10;         */&#13;&#10;        void detachView();&#13;&#10;&#13;&#10;        /**&#13;&#10;         * Tải danh sách tin nhắn từ Firebase&#13;&#10;         */&#13;&#10;        void loadMessages();&#13;&#10;&#13;&#10;        /**&#13;&#10;         * Gửi tin nhắn mới&#13;&#10;         * @param content Nội dung tin nhắn&#13;&#10;         */&#13;&#10;        void sendMessage(String content);&#13;&#10;&#13;&#10;        /**&#13;&#10;         * Xóa lịch sử chat&#13;&#10;         */&#13;&#10;        void clearChatHistory();&#13;&#10;&#13;&#10;        /**&#13;&#10;         * Làm mới danh sách tin nhắn&#13;&#10;         */&#13;&#10;        void refreshMessages();&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/presentation/chat/ChatPresenter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/vhn/doan/presentation/chat/ChatPresenter.java" />
              <option name="originalContent" value="package com.vhn.doan.presentation.chat;&#10;&#10;import android.util.Log;&#10;&#10;import com.google.firebase.auth.FirebaseAuth;&#10;import com.google.firebase.auth.FirebaseUser;&#10;import com.vhn.doan.data.ChatMessage;&#10;import com.vhn.doan.data.repository.ChatRepository;&#10;import com.vhn.doan.data.repository.RepositoryCallback;&#10;&#10;import java.util.List;&#10;&#10;/**&#10; * Presenter cho Chat feature theo kiến trúc MVP&#10; */&#10;public class ChatPresenter implements ChatContract.Presenter {&#10;&#10;    private static final String TAG = &quot;ChatPresenter&quot;;&#10;&#10;    private final ChatRepository chatRepository;&#10;    private final FirebaseAuth firebaseAuth;&#10;    private ChatContract.View view;&#10;&#10;    public ChatPresenter(ChatRepository chatRepository) {&#10;        this.chatRepository = chatRepository;&#10;        this.firebaseAuth = FirebaseAuth.getInstance();&#10;    }&#10;&#10;    @Override&#10;    public void attachView(ChatContract.View view) {&#10;        this.view = view;&#10;        // Tự động tải tin nhắn khi attach view&#10;        loadMessages();&#10;    }&#10;&#10;    @Override&#10;    public void detachView() {&#10;        this.view = null;&#10;    }&#10;&#10;    private boolean isViewAttached() {&#10;        return view != null;&#10;    }&#10;&#10;    @Override&#10;    public void loadMessages() {&#10;        FirebaseUser currentUser = firebaseAuth.getCurrentUser();&#10;        if (currentUser == null) {&#10;            if (isViewAttached()) {&#10;                view.showLoadMessagesError(&quot;Bạn cần đăng nhập để sử dụng tính năng chat&quot;);&#10;            }&#10;            return;&#10;        }&#10;&#10;        if (isViewAttached()) {&#10;            view.showLoadingMessages();&#10;        }&#10;&#10;        chatRepository.getChatMessages(currentUser.getUid(), new RepositoryCallback&lt;List&lt;ChatMessage&gt;&gt;() {&#10;            @Override&#10;            public void onSuccess(List&lt;ChatMessage&gt; messages) {&#10;                if (isViewAttached()) {&#10;                    view.hideLoadingMessages();&#10;                    view.showMessages(messages);&#10;&#10;                    if (!messages.isEmpty()) {&#10;                        view.scrollToLatestMessage();&#10;                    }&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                Log.e(TAG, &quot;Failed to load messages: &quot; + error);&#10;                if (isViewAttached()) {&#10;                    view.hideLoadingMessages();&#10;                    view.showLoadMessagesError(error);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void sendMessage(String content) {&#10;        if (content == null || content.trim().isEmpty()) {&#10;            if (isViewAttached()) {&#10;                view.showSendMessageError(&quot;Vui lòng nhập nội dung tin nhắn&quot;);&#10;            }&#10;            return;&#10;        }&#10;&#10;        FirebaseUser currentUser = firebaseAuth.getCurrentUser();&#10;        if (currentUser == null) {&#10;            if (isViewAttached()) {&#10;                view.showSendMessageError(&quot;Bạn cần đăng nhập để gửi tin nhắn&quot;);&#10;            }&#10;            return;&#10;        }&#10;&#10;        String trimmedContent = content.trim();&#10;        long timestamp = System.currentTimeMillis();&#10;        String userId = currentUser.getUid();&#10;&#10;        // Hiển thị tin nhắn của người dùng ngay lập tức&#10;        ChatMessage userMessage = new ChatMessage(userId, trimmedContent, true, timestamp);&#10;        String topic = chatRepository.extractTopic(trimmedContent);&#10;        userMessage.setTopic(topic);&#10;&#10;        if (isViewAttached()) {&#10;            view.addMessage(userMessage);&#10;            view.clearMessageInput();&#10;            view.scrollToLatestMessage();&#10;            view.showSendingMessage();&#10;        }&#10;&#10;        // Lưu tin nhắn người dùng vào Firebase&#10;        chatRepository.saveChatMessage(userMessage, new RepositoryCallback&lt;ChatMessage&gt;() {&#10;            @Override&#10;            public void onSuccess(ChatMessage savedMessage) {&#10;                Log.d(TAG, &quot;User message saved successfully&quot;);&#10;                if (isViewAttached()) {&#10;                    view.hideSendingMessage();&#10;                    view.showAiTyping();&#10;                }&#10;&#10;                // Gửi tin nhắn tới AI&#10;                chatRepository.sendMessageToAI(trimmedContent, new RepositoryCallback&lt;String&gt;() {&#10;                    @Override&#10;                    public void onSuccess(String aiResponse) {&#10;                        Log.d(TAG, &quot;AI response received: &quot; + aiResponse);&#10;&#10;                        // Tạo tin nhắn phản hồi từ AI&#10;                        ChatMessage aiMessage = new ChatMessage(conversationId, userId, aiResponse, false, System.currentTimeMillis());&#10;                        ChatMessage aiMessage = new ChatMessage(userId, aiResponse, false, System.currentTimeMillis());&#10;&#10;                        if (isViewAttached()) {&#10;                            view.hideAiTyping();&#10;                            view.addMessage(aiMessage);&#10;                            view.scrollToLatestMessage();&#10;                        }&#10;&#10;                        // Lưu phản hồi AI vào Firebase&#10;                        chatRepository.saveChatMessage(aiMessage, new RepositoryCallback&lt;ChatMessage&gt;() {&#10;                            @Override&#10;                            public void onSuccess(ChatMessage savedAiMessage) {&#10;                                Log.d(TAG, &quot;AI message saved successfully&quot;);&#10;                            }&#10;&#10;                            @Override&#10;                            public void onError(String error) {&#10;                                Log.e(TAG, &quot;Failed to save AI message: &quot; + error);&#10;                                // Không hiển thị lỗi cho người dùng vì tin nhắn đã được hiển thị&#10;                            }&#10;                        });&#10;                    }&#10;&#10;                    @Override&#10;                    public void onError(String error) {&#10;                        Log.e(TAG, &quot;Failed to get AI response: &quot; + error);&#10;&#10;                        if (isViewAttached()) {&#10;                            view.hideAiTyping();&#10;&#10;                            // Hiển thị tin nhắn lỗi từ AI&#10;                            ChatMessage errorMessage = new ChatMessage(conversationId, userId,&#10;                            ChatMessage errorMessage = new ChatMessage(userId,&#10;                                &quot;Xin lỗi, tôi không thể trả lời câu hỏi của bạn lúc này. Vui lòng thử lại sau.&quot;,&#10;                            view.addMessage(errorMessage);&#10;                            view.scrollToLatestMessage();&#10;                            view.showSendMessageError(&quot;Không thể nhận phản hồi từ AI: &quot; + error);&#10;                        }&#10;                    }&#10;                });&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                Log.e(TAG, &quot;Failed to save user message: &quot; + error);&#10;                if (isViewAttached()) {&#10;                    view.hideSendingMessage();&#10;                    view.showSendMessageError(&quot;Không thể lưu tin nhắn: &quot; + error);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void clearChatHistory() {&#10;        FirebaseUser currentUser = firebaseAuth.getCurrentUser();&#10;        if (currentUser == null) {&#10;            if (isViewAttached()) {&#10;                view.showLoadMessagesError(&quot;Bạn cần đăng nhập để xóa lịch sử chat&quot;);&#10;            }&#10;            return;&#10;        }&#10;&#10;        chatRepository.clearChatHistory(currentUser.getUid(), new RepositoryCallback&lt;Boolean&gt;() {&#10;            @Override&#10;            public void onSuccess(Boolean success) {&#10;                Log.d(TAG, &quot;Chat history cleared successfully&quot;);&#10;                if (isViewAttached()) {&#10;                    view.showMessage(&quot;Đã xóa lịch sử chat thành công&quot;);&#10;                    // Tải lại danh sách tin nhắn (sẽ rỗng)&#10;                    loadMessages();&#10;                }&#10;            }&#10;&#10;            @Override&#10;            public void onError(String error) {&#10;                Log.e(TAG, &quot;Failed to clear chat history: &quot; + error);&#10;                if (isViewAttached()) {&#10;                    view.showError(&quot;Không thể xóa lịch sử chat: &quot; + error);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void refreshMessages() {&#10;        loadMessages();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.vhn.doan.presentation.chat;&#13;&#10;&#13;&#10;import android.util.Log;&#13;&#10;&#13;&#10;import com.google.firebase.auth.FirebaseAuth;&#13;&#10;import com.google.firebase.auth.FirebaseUser;&#13;&#10;import com.vhn.doan.data.ChatMessage;&#13;&#10;import com.vhn.doan.data.repository.ChatRepository;&#13;&#10;import com.vhn.doan.data.repository.RepositoryCallback;&#13;&#10;&#13;&#10;import java.util.List;&#13;&#10;&#13;&#10;/**&#13;&#10; * Presenter cho Chat feature theo kiến trúc MVP&#13;&#10; */&#13;&#10;public class ChatPresenter implements ChatContract.Presenter {&#13;&#10;&#13;&#10;    private static final String TAG = &quot;ChatPresenter&quot;;&#13;&#10;&#13;&#10;    private final ChatRepository chatRepository;&#13;&#10;    private final FirebaseAuth firebaseAuth;&#13;&#10;    private ChatContract.View view;&#13;&#10;&#13;&#10;    public ChatPresenter(ChatRepository chatRepository) {&#13;&#10;        this.chatRepository = chatRepository;&#13;&#10;        this.firebaseAuth = FirebaseAuth.getInstance();&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public void attachView(ChatContract.View view) {&#13;&#10;        this.view = view;&#13;&#10;        // Tự động tải tin nhắn khi attach view&#13;&#10;        loadMessages();&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public void detachView() {&#13;&#10;        this.view = null;&#13;&#10;    }&#13;&#10;&#13;&#10;    private boolean isViewAttached() {&#13;&#10;        return view != null;&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public void loadMessages() {&#13;&#10;        FirebaseUser currentUser = firebaseAuth.getCurrentUser();&#13;&#10;        if (currentUser == null) {&#13;&#10;            if (isViewAttached()) {&#13;&#10;                view.showLoadMessagesError(&quot;Bạn cần đăng nhập để sử dụng tính năng chat&quot;);&#13;&#10;            }&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        if (isViewAttached()) {&#13;&#10;            view.showLoadingMessages();&#13;&#10;        }&#13;&#10;&#13;&#10;        chatRepository.getChatMessages(currentUser.getUid(), new RepositoryCallback&lt;List&lt;ChatMessage&gt;&gt;() {&#13;&#10;            @Override&#13;&#10;            public void onSuccess(List&lt;ChatMessage&gt; messages) {&#13;&#10;                if (isViewAttached()) {&#13;&#10;                    view.hideLoadingMessages();&#13;&#10;                    view.showMessages(messages);&#13;&#10;&#13;&#10;                    if (!messages.isEmpty()) {&#13;&#10;                        view.scrollToLatestMessage();&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;            @Override&#13;&#10;            public void onError(String error) {&#13;&#10;                Log.e(TAG, &quot;Failed to load messages: &quot; + error);&#13;&#10;                if (isViewAttached()) {&#13;&#10;                    view.hideLoadingMessages();&#13;&#10;                    view.showLoadMessagesError(error);&#13;&#10;                }&#13;&#10;            }&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public void sendMessage(String content) {&#13;&#10;        if (content == null || content.trim().isEmpty()) {&#13;&#10;            if (isViewAttached()) {&#13;&#10;                view.showSendMessageError(&quot;Vui lòng nhập nội dung tin nhắn&quot;);&#13;&#10;            }&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        FirebaseUser currentUser = firebaseAuth.getCurrentUser();&#13;&#10;        if (currentUser == null) {&#13;&#10;            if (isViewAttached()) {&#13;&#10;                view.showSendMessageError(&quot;Bạn cần đăng nhập để gửi tin nhắn&quot;);&#13;&#10;            }&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        String trimmedContent = content.trim();&#13;&#10;        long timestamp = System.currentTimeMillis();&#13;&#10;        String userId = currentUser.getUid();&#13;&#10;        &#13;&#10;        // Tạo conversationId tạm thời hoặc sử dụng conversationId hiện tại&#13;&#10;        String conversationId = &quot;temp_&quot; + userId + &quot;_&quot; + timestamp; // Tạo conversationId tạm thời&#13;&#10;&#13;&#10;        // Hiển thị tin nhắn của người dùng ngay lập tức&#13;&#10;        ChatMessage userMessage = new ChatMessage(conversationId, userId, trimmedContent, true, timestamp);&#13;&#10;        String topic = chatRepository.extractTopic(trimmedContent);&#13;&#10;        userMessage.setTopic(topic);&#13;&#10;&#13;&#10;        if (isViewAttached()) {&#13;&#10;            view.addMessage(userMessage);&#13;&#10;            view.clearMessageInput();&#13;&#10;            view.scrollToLatestMessage();&#13;&#10;            view.showSendingMessage();&#13;&#10;        }&#13;&#10;&#13;&#10;        // Lưu tin nhắn người dùng vào Firebase&#13;&#10;        chatRepository.saveChatMessage(userMessage, new RepositoryCallback&lt;ChatMessage&gt;() {&#13;&#10;            @Override&#13;&#10;            public void onSuccess(ChatMessage savedMessage) {&#13;&#10;                Log.d(TAG, &quot;User message saved successfully&quot;);&#13;&#10;                if (isViewAttached()) {&#13;&#10;                    view.hideSendingMessage();&#13;&#10;                    view.showAiTyping();&#13;&#10;                }&#13;&#10;&#13;&#10;                // Gửi tin nhắn tới AI&#13;&#10;                chatRepository.sendMessageToAI(trimmedContent, new RepositoryCallback&lt;String&gt;() {&#13;&#10;                    @Override&#13;&#10;                    public void onSuccess(String aiResponse) {&#13;&#10;                        Log.d(TAG, &quot;AI response received: &quot; + aiResponse);&#13;&#10;&#13;&#10;                        // Tạo tin nhắn phản hồi từ AI&#13;&#10;                        ChatMessage aiMessage = new ChatMessage(conversationId, userId, aiResponse, false, System.currentTimeMillis());&#13;&#10;                        aiMessage.setTopic(topic);&#13;&#10;&#13;&#10;                        if (isViewAttached()) {&#13;&#10;                            view.hideAiTyping();&#13;&#10;                            view.addMessage(aiMessage);&#13;&#10;                            view.scrollToLatestMessage();&#13;&#10;                        }&#13;&#10;&#13;&#10;                        // Lưu phản hồi AI vào Firebase&#13;&#10;                        chatRepository.saveChatMessage(aiMessage, new RepositoryCallback&lt;ChatMessage&gt;() {&#13;&#10;                            @Override&#13;&#10;                            public void onSuccess(ChatMessage savedAiMessage) {&#13;&#10;                                Log.d(TAG, &quot;AI message saved successfully&quot;);&#13;&#10;                            }&#13;&#10;&#13;&#10;                            @Override&#13;&#10;                            public void onError(String error) {&#13;&#10;                                Log.e(TAG, &quot;Failed to save AI message: &quot; + error);&#13;&#10;                                // Không hiển thị lỗi cho người dùng vì tin nhắn đã được hiển thị&#13;&#10;                            }&#13;&#10;                        });&#13;&#10;                    }&#13;&#10;&#13;&#10;                    @Override&#13;&#10;                    public void onError(String error) {&#13;&#10;                        Log.e(TAG, &quot;Failed to get AI response: &quot; + error);&#13;&#10;&#13;&#10;                        if (isViewAttached()) {&#13;&#10;                            view.hideAiTyping();&#13;&#10;&#13;&#10;                            // Hiển thị tin nhắn lỗi từ AI&#13;&#10;                            ChatMessage errorMessage = new ChatMessage(conversationId, userId,&#13;&#10;                                &quot;Xin lỗi, tôi không thể trả lời câu hỏi của bạn lúc này. Vui lòng thử lại sau.&quot;,&#13;&#10;                                false, System.currentTimeMillis());&#13;&#10;                            view.addMessage(errorMessage);&#13;&#10;                            view.scrollToLatestMessage();&#13;&#10;                            view.showSendMessageError(&quot;Không thể nhận phản hồi từ AI: &quot; + error);&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                });&#13;&#10;            }&#13;&#10;&#13;&#10;            @Override&#13;&#10;            public void onError(String error) {&#13;&#10;                Log.e(TAG, &quot;Failed to save user message: &quot; + error);&#13;&#10;                if (isViewAttached()) {&#13;&#10;                    view.hideSendingMessage();&#13;&#10;                    view.showSendMessageError(&quot;Không thể lưu tin nhắn: &quot; + error);&#13;&#10;                }&#13;&#10;            }&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public void clearChatHistory() {&#13;&#10;        FirebaseUser currentUser = firebaseAuth.getCurrentUser();&#13;&#10;        if (currentUser == null) {&#13;&#10;            if (isViewAttached()) {&#13;&#10;                view.showLoadMessagesError(&quot;Bạn cần đăng nhập để xóa lịch sử chat&quot;);&#13;&#10;            }&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        chatRepository.clearChatHistory(currentUser.getUid(), new RepositoryCallback&lt;Boolean&gt;() {&#13;&#10;            @Override&#13;&#10;            public void onSuccess(Boolean success) {&#13;&#10;                Log.d(TAG, &quot;Chat history cleared successfully&quot;);&#13;&#10;                if (isViewAttached()) {&#13;&#10;                    view.showMessage(&quot;Đã xóa lịch sử chat thành công&quot;);&#13;&#10;                    // Tải lại danh sách tin nhắn (sẽ rỗng)&#13;&#10;                    loadMessages();&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;            @Override&#13;&#10;            public void onError(String error) {&#13;&#10;                Log.e(TAG, &quot;Failed to clear chat history: &quot; + error);&#13;&#10;                if (isViewAttached()) {&#13;&#10;                    view.showError(&quot;Không thể xóa lịch sử chat: &quot; + error);&#13;&#10;                }&#13;&#10;            }&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public void refreshMessages() {&#13;&#10;        loadMessages();&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/gradle.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/gradle.properties" />
              <option name="originalContent" value="# Project-wide Gradle settings.&#10;# IDE (e.g. Android Studio) users:&#10;# Gradle settings configured through the IDE *will override*&#10;# any settings specified in this file.&#10;# For more details on how to configure your build environment visit&#10;# http://www.gradle.org/docs/current/userguide/build_environment.html&#10;# Specifies the JVM arguments used for the daemon process.&#10;# The setting is particularly useful for tweaking memory settings.&#10;org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8&#10;# When configured, Gradle will run in incubating parallel mode.&#10;# This option should only be used with decoupled projects. For more details, visit&#10;# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects&#10;# org.gradle.parallel=true&#10;# AndroidX package structure to make it clearer which packages are bundled with the&#10;# Android operating system, and which are packaged with your app's APK&#10;# https://developer.android.com/topic/libraries/support-library/androidx-rn&#10;android.useAndroidX=true&#10;# Enables namespacing of each library's R class so that its R class includes only the&#10;# resources declared in the library itself and none from the library's dependencies,&#10;# thereby reducing the size of the R class for that library&#10;android.nonTransitiveRClass=true" />
              <option name="updatedContent" value="# Project-wide Gradle settings.&#13;&#10;# IDE (e.g. Android Studio) users:&#13;&#10;# Gradle settings configured through the IDE *will override*&#13;&#10;# any settings specified in this file.&#13;&#10;# For more details on how to configure your build environment visit&#13;&#10;# http://www.gradle.org/docs/current/userguide/build_environment.html&#13;&#10;# Specifies the JVM arguments used for the daemon process.&#13;&#10;# The setting is particularly useful for tweaking memory settings.&#13;&#10;org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8&#13;&#10;# When configured, Gradle will run in incubating parallel mode.&#13;&#10;# This option should only be used with decoupled projects. For more details, visit&#13;&#10;# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects&#13;&#10;# org.gradle.parallel=true&#13;&#10;# AndroidX package structure to make it clearer which packages are bundled with the&#13;&#10;# Android operating system, and which are packaged with your app's APK&#13;&#10;# https://developer.android.com/topic/libraries/support-library/androidx-rn&#13;&#10;android.useAndroidX=true&#13;&#10;# Enables namespacing of each library's R class so that its R class includes only the&#13;&#10;# resources declared in the library itself and none from the library's dependencies,&#13;&#10;# thereby reducing the size of the R class for that library&#13;&#10;android.nonTransitiveRClass=true&#13;&#10;&#13;&#10;# Suppress Java source/target deprecation warnings&#13;&#10;android.javaCompile.suppressSourceTargetDeprecationWarning=true" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>